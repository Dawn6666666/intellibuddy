![(二)语法分析](https://via.placeholder.com/800x200?text=Syntax+Analysis)

# 编译原理 - (二)语法分析

掌握语法分析方法。

---


### 2.1 递归下降分析器

```python
class Parser:
    def __init__(self, lexer):
        self.lexer = lexer
        self.current_token = self.lexer.get_next_token()
    
    def eat(self, token_type):
        """消费token"""
        if self.current_token[0] == token_type:
            self.current_token = self.lexer.get_next_token()
        else:
            raise Exception(f'Expected {token_type}, got {self.current_token[0]}')
    
    def factor(self):
        """factor: NUMBER | LPAREN expr RPAREN"""
        token = self.current_token
        
        if token[0] == 'NUMBER':
            self.eat('NUMBER')
            return token[1]
        elif token[0] == 'LPAREN':
            self.eat('LPAREN')
            result = self.expr()
            self.eat('RPAREN')
            return result
    
    def term(self):
        """term: factor ((MUL | DIV) factor)*"""
        result = self.factor()
        
        while self.current_token[0] in ('MUL', 'DIV'):
            token = self.current_token
            if token[0] == 'MUL':
                self.eat('MUL')
                result = result * self.factor()
            elif token[0] == 'DIV':
                self.eat('DIV')
                result = result / self.factor()
        
        return result
    
    def expr(self):
        """expr: term ((PLUS | MINUS) term)*"""
        result = self.term()
        
        while self.current_token[0] in ('PLUS', 'MINUS'):
            token = self.current_token
            if token[0] == 'PLUS':
                self.eat('PLUS')
                result = result + self.term()
            elif token[0] == 'MINUS':
                self.eat('MINUS')
                result = result - self.term()
        
        return result

# 测试
lexer = Lexer('3 + 4 * 2')
parser = Parser(lexer)
result = parser.expr()
print(f'Result: {result}')  # 11
```

### 2.2 抽象语法树（AST）

```python
class ASTNode:
    pass

class BinOp(ASTNode):
    def __init__(self, left, op, right):
        self.left = left
        self.token = self.op = op
        self.right = right

class Num(ASTNode):
    def __init__(self, token):
        self.token = token
        self.value = token[1]

class ASTParser:
    def __init__(self, lexer):
        self.lexer = lexer
        self.current_token = self.lexer.get_next_token()
    
    def eat(self, token_type):
        if self.current_token[0] == token_type:
            self.current_token = self.lexer.get_next_token()
        else:
            raise Exception(f'Expected {token_type}')
    
    def factor(self):
        """factor: NUMBER | LPAREN expr RPAREN"""
        token = self.current_token
        
        if token[0] == 'NUMBER':
            self.eat('NUMBER')
            return Num(token)
        elif token[0] == 'LPAREN':
            self.eat('LPAREN')
            node = self.expr()
            self.eat('RPAREN')
            return node
    
    def term(self):
        """term: factor ((MUL | DIV) factor)*"""
        node = self.factor()
        
        while self.current_token[0] in ('MUL', 'DIV'):
            token = self.current_token
            if token[0] == 'MUL':
                self.eat('MUL')
            elif token[0] == 'DIV':
                self.eat('DIV')
            
            node = BinOp(left=node, op=token, right=self.factor())
        
        return node
    
    def expr(self):
        """expr: term ((PLUS | MINUS) term)*"""
        node = self.term()
        
        while self.current_token[0] in ('PLUS', 'MINUS'):
            token = self.current_token
            if token[0] == 'PLUS':
                self.eat('PLUS')
            elif token[0] == 'MINUS':
                self.eat('MINUS')
            
            node = BinOp(left=node, op=token, right=self.term())
        
        return node

class Interpreter:
    def visit(self, node):
        """访问者模式"""
        method_name = 'visit_' + type(node).__name__
        visitor = getattr(self, method_name, self.generic_visit)
        return visitor(node)
    
    def generic_visit(self, node):
        raise Exception(f'No visit_{type(node).__name__} method')
    
    def visit_BinOp(self, node):
        if node.op[0] == 'PLUS':
            return self.visit(node.left) + self.visit(node.right)
        elif node.op[0] == 'MINUS':
            return self.visit(node.left) - self.visit(node.right)
        elif node.op[0] == 'MUL':
            return self.visit(node.left) * self.visit(node.right)
        elif node.op[0] == 'DIV':
            return self.visit(node.left) / self.visit(node.right)
    
    def visit_Num(self, node):
        return node.value

# 测试
lexer = Lexer('2 + 3 * 4')
parser = ASTParser(lexer)
tree = parser.expr()
interpreter = Interpreter()
result = interpreter.visit(tree)
print(f'Result: {result}')  # 14
```

---

## 3. 语义分析