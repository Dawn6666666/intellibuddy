# 网络安全 - (一)密码学基础

学习加密算法与应用。

---

## 1. 密码学基础

### 1.1 对称加密

```python
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
from Crypto.Util.Padding import pad, unpad
import base64

class AESCipher:
    def __init__(self, key=None):
        self.key = key or get_random_bytes(32)  # 256位密钥
    
    def encrypt(self, plaintext):
        """AES加密"""
        cipher = AES.new(self.key, AES.MODE_CBC)
        
        # 填充到16字节的倍数
        padded_text = pad(plaintext.encode(), AES.block_size)
        
        # 加密
        ciphertext = cipher.encrypt(padded_text)
        
        # 返回IV + 密文的Base64编码
        return base64.b64encode(cipher.iv + ciphertext).decode()
    
    def decrypt(self, encrypted_text):
        """AES解密"""
        encrypted_data = base64.b64decode(encrypted_text)
        
        # 提取IV和密文
        iv = encrypted_data[:AES.block_size]
        ciphertext = encrypted_data[AES.block_size:]
        
        # 解密
        cipher = AES.new(self.key, AES.MODE_CBC, iv)
        padded_plaintext = cipher.decrypt(ciphertext)
        
        # 去除填充
        plaintext = unpad(padded_plaintext, AES.block_size)
        
        return plaintext.decode()

# 测试AES加密
aes = AESCipher()
message = "这是一条机密信息"

encrypted = aes.encrypt(message)
print(f"🔒 加密: {encrypted}")

decrypted = aes.decrypt(encrypted)
print(f"🔓 解密: {decrypted}")
```

### 1.2 非对称加密（RSA）

```python
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP
from Crypto.Signature import pkcs1_15
from Crypto.Hash import SHA256
import base64

class RSACipher:
    def __init__(self, key_size=2048):
        self.key_pair = RSA.generate(key_size)
        self.public_key = self.key_pair.publickey()
    
    def get_public_key_pem(self):
        """获取公钥PEM格式"""
        return self.public_key.export_key().decode()
    
    def get_private_key_pem(self):
        """获取私钥PEM格式"""
        return self.key_pair.export_key().decode()
    
    def encrypt(self, plaintext, public_key=None):
        """RSA加密（使用公钥）"""
        key = public_key or self.public_key
        cipher = PKCS1_OAEP.new(key)
        
        # RSA加密有长度限制，需要分块
        max_length = key.size_in_bytes() - 42  # OAEP填充开销
        
        if len(plaintext.encode()) <= max_length:
            ciphertext = cipher.encrypt(plaintext.encode())
            return base64.b64encode(ciphertext).decode()
        else:
            raise ValueError("消息太长，需要分块处理")
    
    def decrypt(self, encrypted_text):
        """RSA解密（使用私钥）"""
        cipher = PKCS1_OAEP.new(self.key_pair)
        ciphertext = base64.b64decode(encrypted_text)
        
        plaintext = cipher.decrypt(ciphertext)
        return plaintext.decode()
    
    def sign(self, message):
        """数字签名"""
        hash_obj = SHA256.new(message.encode())
        signature = pkcs1_15.new(self.key_pair).sign(hash_obj)
        return base64.b64encode(signature).decode()
    
    def verify(self, message, signature, public_key=None):
        """验证签名"""
        key = public_key or self.public_key
        hash_obj = SHA256.new(message.encode())
        signature_bytes = base64.b64decode(signature)
        
        try:
            pkcs1_15.new(key).verify(hash_obj, signature_bytes)
            return True
        except:
            return False

# 测试RSA
rsa = RSACipher()
message = "重要合同内容"

# 加密
encrypted = rsa.encrypt(message)
print(f"🔒 RSA加密: {encrypted[:50]}...")

# 解密
decrypted = rsa.decrypt(encrypted)
print(f"🔓 RSA解密: {decrypted}")

# 数字签名
signature = rsa.sign(message)
print(f"✍️  数字签名: {signature[:50]}...")

# 验证签名
is_valid = rsa.verify(message, signature)
print(f"✅ 签名验证: {is_valid}")
```

### 1.3 哈希函数与消息认证

```python
import hashlib
import hmac
import secrets

class HashUtils:
    @staticmethod
    def sha256(data):
        """SHA-256哈希"""
        return hashlib.sha256(data.encode()).hexdigest()
    
    @staticmethod
    def md5(data):
        """MD5哈希（不安全，仅用于演示）"""
        return hashlib.md5(data.encode()).hexdigest()
    
    @staticmethod
    def hmac_sha256(key, message):
        """HMAC-SHA256消息认证码"""
        return hmac.new(key.encode(), message.encode(), hashlib.sha256).hexdigest()
    
    @staticmethod
    def generate_salt(length=32):
        """生成随机盐值"""
        return secrets.token_hex(length)
    
    @staticmethod
    def hash_password(password, salt=None):
        """安全的密码哈希"""
        if salt is None:
            salt = HashUtils.generate_salt()
        
        # 使用PBKDF2进行密钥拉伸
        import hashlib
        key = hashlib.pbkdf2_hmac('sha256', 
                                  password.encode(), 
                                  salt.encode(), 
                                  100000)  # 10万次迭代
        
        return salt + key.hex()
    
    @staticmethod
    def verify_password(password, hashed):
        """验证密码"""
        salt = hashed[:64]  # 前64个字符是盐值
        key = hashed[64:]
        
        new_key = hashlib.pbkdf2_hmac('sha256',
                                      password.encode(),
                                      salt.encode(),
                                      100000)
        
        return key == new_key.hex()

# 测试哈希和HMAC
data = "敏感数据"
key = "secret_key"

print(f"📊 原始数据: {data}")
print(f"🔢 SHA-256: {HashUtils.sha256(data)}")
print(f"🔐 HMAC-SHA256: {HashUtils.hmac_sha256(key, data)}")

# 测试密码哈希
password = "my_secure_password"
hashed = HashUtils.hash_password(password)
print(f"\n🔒 密码哈希: {hashed}")

is_valid = HashUtils.verify_password(password, hashed)
print(f"✅ 密码验证: {is_valid}")

is_invalid = HashUtils.verify_password("wrong_password", hashed)
print(f"❌ 错误密码: {is_invalid}")
```

---

**本章完**
