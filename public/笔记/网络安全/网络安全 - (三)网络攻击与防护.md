# 网络安全 - (三)网络攻击与防护

理解网络攻防技术。

---

## 3. 网络攻击与防护

### 3.1 DDoS防护

```python
import time
import threading
from collections import defaultdict, deque

class DDoSProtection:
    def __init__(self):
        # 请求计数器
        self.request_counts = defaultdict(deque)
        self.blocked_ips = set()
        
        # 配置参数
        self.rate_limit = 100  # 每分钟最大请求数
        self.time_window = 60  # 时间窗口（秒）
        self.block_duration = 300  # 封禁时长（秒）
        
        # 地理位置异常检测
        self.geo_requests = defaultdict(lambda: defaultdict(int))
        
        # 启动清理线程
        self.cleanup_thread = threading.Thread(target=self._cleanup_expired, daemon=True)
        self.cleanup_thread.start()
    
    def is_request_allowed(self, ip_address, user_agent=None, geo_country=None):
        """检查请求是否被允许"""
        current_time = time.time()
        
        # 检查IP是否被封禁
        if ip_address in self.blocked_ips:
            return False, "IP已被封禁"
        
        # 速率限制检查
        if not self._check_rate_limit(ip_address, current_time):
            self.blocked_ips.add(ip_address)
            # 设置解封定时器
            threading.Timer(self.block_duration, 
                          lambda: self.blocked_ips.discard(ip_address)).start()
            return False, "请求频率过高，IP已被封禁"
        
        # User-Agent检查
        if user_agent and self._is_suspicious_user_agent(user_agent):
            return False, "可疑的User-Agent"
        
        # 地理位置异常检查
        if geo_country and self._is_geo_anomaly(ip_address, geo_country):
            return False, "地理位置异常"
        
        return True, "请求允许"
    
    def _check_rate_limit(self, ip_address, current_time):
        """检查速率限制"""
        requests = self.request_counts[ip_address]
        
        # 移除过期请求
        while requests and current_time - requests[0] > self.time_window:
            requests.popleft()
        
        # 添加当前请求
        requests.append(current_time)
        
        # 检查是否超过限制
        return len(requests) <= self.rate_limit
    
    def _is_suspicious_user_agent(self, user_agent):
        """检查可疑的User-Agent"""
        suspicious_patterns = [
            'bot', 'crawler', 'spider', 'scraper',
            'python-requests', 'curl', 'wget'
        ]
        
        user_agent_lower = user_agent.lower()
        return any(pattern in user_agent_lower for pattern in suspicious_patterns)
    
    def _is_geo_anomaly(self, ip_address, country):
        """检查地理位置异常"""
        # 记录IP的地理位置
        self.geo_requests[ip_address][country] += 1
        
        # 如果同一IP来自多个国家，可能是代理
        countries = list(self.geo_requests[ip_address].keys())
        if len(countries) > 3:  # 超过3个国家
            return True
        
        return False
    
    def _cleanup_expired(self):
        """清理过期数据"""
        while True:
            time.sleep(60)  # 每分钟清理一次
            current_time = time.time()
            
            # 清理过期的请求记录
            for ip in list(self.request_counts.keys()):
                requests = self.request_counts[ip]
                while requests and current_time - requests[0] > self.time_window:
                    requests.popleft()
                
                # 如果队列为空，删除记录
                if not requests:
                    del self.request_counts[ip]

class LoadBalancer:
    def __init__(self, servers):
        self.servers = servers
        self.current_index = 0
        self.server_health = {server: True for server in servers}
    
    def get_server(self):
        """获取可用服务器"""
        # 简单轮询
        attempts = 0
        while attempts < len(self.servers):
            server = self.servers[self.current_index]
            self.current_index = (self.current_index + 1) % len(self.servers)
            
            if self.server_health[server]:
                return server
            
            attempts += 1
        
        return None  # 所有服务器都不可用
    
    def mark_server_down(self, server):
        """标记服务器下线"""
        self.server_health[server] = False
        print(f"🚨 服务器 {server} 标记为下线")
    
    def mark_server_up(self, server):
        """标记服务器上线"""
        self.server_health[server] = True
        print(f"✅ 服务器 {server} 恢复上线")

# 测试DDoS防护
ddos_protection = DDoSProtection()
load_balancer = LoadBalancer(['server1', 'server2', 'server3'])

print("🧪 DDoS防护测试:")

# 模拟正常请求
for i in range(5):
    allowed, reason = ddos_protection.is_request_allowed(
        "192.168.1.100", 
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
    )
    print(f"正常请求 {i+1}: {allowed} - {reason}")

# 模拟攻击请求
print("\n🚨 模拟DDoS攻击:")
for i in range(105):  # 超过速率限制
    allowed, reason = ddos_protection.is_request_allowed("192.168.1.200")
    if not allowed:
        print(f"攻击请求 {i+1}: {allowed} - {reason}")
        break

# 模拟可疑User-Agent
allowed, reason = ddos_protection.is_request_allowed(
    "192.168.1.300", 
    "python-requests/2.25.1"
)
print(f"可疑UA: {allowed} - {reason}")

# 负载均衡测试
print(f"\n⚖️  负载均衡:")
for i in range(5):
    server = load_balancer.get_server()
    print(f"请求 {i+1} -> {server}")
```

---

## 📚 学习建议

### 实践项目

1. **Web应用安全扫描器**
2. **网络入侵检测系统**
3. **密码破解工具**
4. **安全审计系统**

### 推荐工具

🛠️ **安全工具：**
- **Nmap** - 网络扫描
- **Wireshark** - 流量分析
- **Burp Suite** - Web安全测试
- **Metasploit** - 渗透测试

### 认证考试

🏆 **安全认证：**
- **CISSP** - 信息安全专家
- **CEH** - 道德黑客
- **OSCP** - 渗透测试专家

---

> **记住**：安全是一个持续的过程，不是一次性的产品！🛡️

---

**本章完**
