# 数据库系统 - (十)实战案例

数据库实战项目。

---

## 10. 实战案例

### 10.1 电商订单系统

```sql
-- 数据库设计
CREATE TABLE users (
    user_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_email (email)
);

CREATE TABLE products (
    product_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(200) NOT NULL,
    price DECIMAL(10, 2) NOT NULL,
    stock INT NOT NULL DEFAULT 0,
    category_id INT,
    INDEX idx_category (category_id),
    INDEX idx_name (name(20))
);

CREATE TABLE orders (
    order_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    total_amount DECIMAL(10, 2) NOT NULL,
    status ENUM('pending', 'paid', 'shipped', 'completed', 'cancelled'),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(user_id),
    INDEX idx_user_status (user_id, status),
    INDEX idx_created (created_at)
);

CREATE TABLE order_items (
    item_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    order_id BIGINT NOT NULL,
    product_id BIGINT NOT NULL,
    quantity INT NOT NULL,
    price DECIMAL(10, 2) NOT NULL,
    FOREIGN KEY (order_id) REFERENCES orders(order_id),
    FOREIGN KEY (product_id) REFERENCES products(product_id)
);

-- 库存扣减（防止超卖）
START TRANSACTION;

-- 1. 检查库存
SELECT stock FROM products WHERE product_id = 1001 FOR UPDATE;

-- 2. 扣减库存（乐观锁）
UPDATE products 
SET stock = stock - 1
WHERE product_id = 1001 AND stock > 0;

-- 3. 检查更新是否成功
-- 如果affected_rows = 0，说明库存不足

-- 4. 创建订单
INSERT INTO orders (user_id, total_amount, status)
VALUES (123, 99.99, 'pending');

-- 5. 订单详情
INSERT INTO order_items (order_id, product_id, quantity, price)
VALUES (LAST_INSERT_ID(), 1001, 1, 99.99);

COMMIT;
```

### 10.2 用户积分系统

```sql
CREATE TABLE user_points (
    user_id BIGINT PRIMARY KEY,
    points INT NOT NULL DEFAULT 0,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_points (points DESC)
);

CREATE TABLE point_logs (
    log_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    amount INT NOT NULL,  -- 正数为增加，负数为扣减
    reason VARCHAR(100),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_user_time (user_id, created_at)
);

-- 积分变更存储过程
DELIMITER //
CREATE PROCEDURE UpdatePoints(
    IN p_user_id BIGINT,
    IN p_amount INT,
    IN p_reason VARCHAR(100)
)
BEGIN
    DECLARE current_points INT;
    
    START TRANSACTION;
    
    -- 获取当前积分（加锁）
    SELECT points INTO current_points
    FROM user_points
    WHERE user_id = p_user_id
    FOR UPDATE;
    
    -- 检查是否够扣减
    IF p_amount < 0 AND current_points < ABS(p_amount) THEN
        SIGNAL SQLSTATE '45000' 
        SET MESSAGE_TEXT = '积分不足';
    END IF;
    
    -- 更新积分
    UPDATE user_points
    SET points = points + p_amount
    WHERE user_id = p_user_id;
    
    -- 记录日志
    INSERT INTO point_logs (user_id, amount, reason)
    VALUES (p_user_id, p_amount, p_reason);
    
    COMMIT;
END //
DELIMITER ;

-- 使用
CALL UpdatePoints(123, 100, '签到奖励');
CALL UpdatePoints(123, -50, '兑换商品');
```

### 10.3 排行榜系统（Redis实现）

```python
import redis

class Leaderboard:
    """
    排行榜（Redis Sorted Set）
    """
    def __init__(self, redis_client, key='leaderboard'):
        self.redis = redis_client
        self.key = key
    
    def add_score(self, user_id, score):
        """添加/更新分数"""
        self.redis.zadd(self.key, {user_id: score})
    
    def increment_score(self, user_id, delta):
        """增加分数"""
        self.redis.zincrby(self.key, delta, user_id)
    
    def get_rank(self, user_id):
        """获取排名（从1开始）"""
        rank = self.redis.zrevrank(self.key, user_id)
        return rank + 1 if rank is not None else None
    
    def get_top(self, n=10):
        """获取前N名"""
        results = self.redis.zrevrange(self.key, 0, n-1, withscores=True)
        return [(user.decode(), int(score)) for user, score in results]
    
    def get_score(self, user_id):
        """获取用户分数"""
        score = self.redis.zscore(self.key, user_id)
        return int(score) if score else 0
    
    def get_range(self, user_id, context=5):
        """获取用户周围的排名"""
        rank = self.redis.zrevrank(self.key, user_id)
        if rank is None:
            return []
        
        start = max(0, rank - context)
        end = rank + context
        
        results = self.redis.zrevrange(self.key, start, end, withscores=True)
        return [(user.decode(), int(score), start + i + 1) 
                for i, (user, score) in enumerate(results)]

# 示例
r = redis.Redis(host='localhost', port=6379, decode_responses=True)
lb = Leaderboard(r, key='game:leaderboard')

# 添加分数
lb.add_score('user:1', 1000)
lb.add_score('user:2', 1500)
lb.add_score('user:3', 800)

# 增加分数
lb.increment_score('user:1', 500)

# 查询排名
print(f"user:1 排名: {lb.get_rank('user:1')}")

# 前10名
print(f"前10名: {lb.get_top(10)}")

# user:1周围的排名
print(f"周围排名: {lb.get_range('user:1', context=2)}")
```

---

**本章完**
