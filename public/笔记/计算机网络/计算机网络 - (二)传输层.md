![(二)传输层](https://via.placeholder.com/800x200?text=Transport+Layer)

# 计算机网络 - (二)传输层

理解TCP/UDP协议。

---


### 2.1 TCP协议

**三次握手：**

```
客户端                  服务器
  |                        |
  |  SYN (seq=x)          |
  |----------------------->|
  |                        |
  |  SYN-ACK (seq=y,ack=x+1)|
  |<-----------------------|
  |                        |
  |  ACK (ack=y+1)        |
  |----------------------->|
  |                        |
```

**四次挥手：**

```
  |  FIN (seq=u)          |
  |----------------------->|
  |                        |
  |  ACK (ack=u+1)        |
  |<-----------------------|
  |                        |
  |  FIN (seq=v)          |
  |<-----------------------|
  |                        |
  |  ACK (ack=v+1)        |
  |----------------------->|
```

**TCP实现：**

```python
import socket

# TCP服务器
def tcp_server(port=8888):
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(('0.0.0.0', port))
    server.listen(5)
    
    print(f"TCP服务器启动: {port}")
    
    while True:
        client, addr = server.accept()
        print(f"连接来自: {addr}")
        
        data = client.recv(1024)
        print(f"收到: {data.decode()}")
        
        client.send(b"HTTP/1.1 200 OK\r\n\r\nHello!")
        client.close()

# tcp_server()
```

### 2.2 UDP协议

```python
def udp_server(port=9999):
    """UDP服务器"""
    server = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    server.bind(('0.0.0.0', port))
    
    print(f"UDP服务器启动: {port}")
    
    while True:
        data, addr = server.recvfrom(1024)
        print(f"收到来自{addr}: {data.decode()}")
        server.sendto(b"ACK", addr)

# udp_server()
```

### 2.3 拥塞控制

**慢启动 & 拥塞避免：**

```python
class TCPCongestionControl:
    def __init__(self):
        self.cwnd = 1  # 拥塞窗口
        self.ssthresh = 64  # 慢启动阈值
        self.state = 'slow_start'
    
    def on_ack(self):
        """收到ACK"""
        if self.state == 'slow_start':
            self.cwnd *= 2  # 指数增长
            if self.cwnd >= self.ssthresh:
                self.state = 'congestion_avoidance'
        else:
            self.cwnd += 1  # 线性增长
    
    def on_timeout(self):
        """超时"""
        self.ssthresh = self.cwnd // 2
        self.cwnd = 1
        self.state = 'slow_start'
        print("超时！重置窗口")

tcp = TCPCongestionControl()
for i in range(20):
    tcp.on_ack()
    print(f"Round {i+1}: cwnd={tcp.cwnd}, state={tcp.state}")
```

---

## 3. 网络层