![(二)内存管理](https://via.placeholder.com/800x200?text=Memory+Management)

# 操作系统 - (二)内存管理

掌握内存分配与虚拟内存。

---


### 2.1 分页管理

**页表结构：**

```python
class PageTable:
    def __init__(self, page_size=4096):
        self.page_size = page_size
        self.entries = {}  # 页号 → 帧号
    
    def translate(self, virtual_addr):
        """虚拟地址转物理地址"""
        page_num = virtual_addr // self.page_size
        offset = virtual_addr % self.page_size
        
        if page_num not in self.entries:
            raise Exception(f"缺页中断: 页{page_num}不在内存")
        
        frame_num = self.entries[page_num]
        physical_addr = frame_num * self.page_size + offset
        
        return physical_addr
    
    def map_page(self, page_num, frame_num):
        """建立页表项"""
        self.entries[page_num] = frame_num

# 示例
pt = PageTable(page_size=4096)
pt.map_page(0, 5)  # 页0映射到帧5
pt.map_page(1, 8)  # 页1映射到帧8

print(f"虚拟地址0转换: {pt.translate(0)}")      # 5*4096 + 0 = 20480
print(f"虚拟地址4100转换: {pt.translate(4100)}")  # 8*4096 + 4 = 32772
```

### 2.2 页面置换算法

#### LRU（最近最少使用）

```python
class LRUPageReplacement:
    def __init__(self, capacity):
        self.capacity = capacity
        self.memory = []
        self.page_faults = 0
    
    def access(self, page):
        """访问页面"""
        if page in self.memory:
            # 命中，更新位置
            self.memory.remove(page)
            self.memory.append(page)
            print(f"访问页{page}: 命中")
        else:
            # 缺页
            self.page_faults += 1
            
            if len(self.memory) >= self.capacity:
                victim = self.memory.pop(0)  # 淘汰最久未用
                print(f"访问页{page}: 缺页，淘汰页{victim}")
            else:
                print(f"访问页{page}: 缺页")
            
            self.memory.append(page)
        
        print(f"内存: {self.memory}\n")
    
    def get_page_faults(self):
        return self.page_faults

# 示例
lru = LRUPageReplacement(capacity=3)
pages = [7, 0, 1, 2, 0, 3, 0, 4, 2, 3]

for page in pages:
    lru.access(page)

print(f"总缺页次数: {lru.get_page_faults()}")
```

#### Clock算法

```python
class ClockPageReplacement:
    def __init__(self, capacity):
        self.capacity = capacity
        self.memory = [None] * capacity
        self.use_bit = [0] * capacity
        self.pointer = 0
        self.page_faults = 0
    
    def access(self, page):
        """访问页面"""
        # 检查是否在内存
        if page in self.memory:
            idx = self.memory.index(page)
            self.use_bit[idx] = 1  # 设置使用位
            print(f"访问页{page}: 命中")
            return
        
        # 缺页
        self.page_faults += 1
        
        # 寻找替换页
        while True:
            if self.memory[self.pointer] is None:
                # 空闲帧
                self.memory[self.pointer] = page
                self.use_bit[self.pointer] = 1
                print(f"访问页{page}: 缺页，载入帧{self.pointer}")
                self.pointer = (self.pointer + 1) % self.capacity
                break
            elif self.use_bit[self.pointer] == 0:
                # 替换
                victim = self.memory[self.pointer]
                self.memory[self.pointer] = page
                self.use_bit[self.pointer] = 1
                print(f"访问页{page}: 缺页，替换页{victim}")
                self.pointer = (self.pointer + 1) % self.capacity
                break
            else:
                # 给第二次机会
                self.use_bit[self.pointer] = 0
                self.pointer = (self.pointer + 1) % self.capacity

# 测试
clock = ClockPageReplacement(capacity=3)
pages = [1, 2, 3, 4, 1, 2, 5, 1, 2, 3]

for page in pages:
    clock.access(page)
```

---

## 3. 文件系统