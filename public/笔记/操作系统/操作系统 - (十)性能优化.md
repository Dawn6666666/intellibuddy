![(十)性能优化](https://via.placeholder.com/800x200?text=Performance)

# 操作系统 - (十)性能优化

掌握系统性能优化。

---


### 10.1 缓存策略

```python
class BufferCache:
    """
    缓冲区缓存（块设备）
    """
    def __init__(self, cache_size=10):
        self.cache = {}  # 块号 → 数据
        self.cache_size = cache_size
        self.lru_list = []
        self.stats = {'hits': 0, 'misses': 0}
    
    def read_block(self, block_num, disk):
        """读块"""
        if block_num in self.cache:
            # 缓存命中
            self.stats['hits'] += 1
            self._update_lru(block_num)
            print(f"缓存命中: 块{block_num}")
            return self.cache[block_num]
        else:
            # 缓存未命中
            self.stats['misses'] += 1
            print(f"缓存未命中: 块{block_num}, 从磁盘读取")
            
            # 从磁盘读取
            data = disk.read(block_num)
            
            # 加入缓存
            if len(self.cache) >= self.cache_size:
                victim = self.lru_list.pop(0)
                del self.cache[victim]
                print(f"  淘汰块{victim}")
            
            self.cache[block_num] = data
            self.lru_list.append(block_num)
            
            return data
    
    def write_block(self, block_num, data, disk):
        """写块（写回策略）"""
        # 更新缓存
        self.cache[block_num] = data
        self._update_lru(block_num)
        
        # 延迟写回（标记脏）
        print(f"写缓存: 块{block_num} (脏)")
    
    def flush(self, disk):
        """刷新脏块到磁盘"""
        print("刷新缓存到磁盘...")
        for block_num, data in self.cache.items():
            disk.write(block_num, data)
            print(f"  写回块{block_num}")
    
    def _update_lru(self, block_num):
        """更新LRU"""
        if block_num in self.lru_list:
            self.lru_list.remove(block_num)
        self.lru_list.append(block_num)
    
    def get_stats(self):
        """获取统计信息"""
        total = self.stats['hits'] + self.stats['misses']
        hit_rate = self.stats['hits'] / total * 100 if total > 0 else 0
        return {
            '命中': self.stats['hits'],
            '未命中': self.stats['misses'],
            '命中率': f"{hit_rate:.1f}%"
        }

# 模拟磁盘
class SimpleDisk:
    def __init__(self):
        self.blocks = {i: f"Block{i}Data" for i in range(100)}
    
    def read(self, block_num):
        return self.blocks.get(block_num, "")
    
    def write(self, block_num, data):
        self.blocks[block_num] = data

# 示例
disk = SimpleDisk()
cache = BufferCache(cache_size=3)

for block in [1, 2, 3, 1, 4, 1, 2]:
    cache.read_block(block, disk)

print(cache.get_stats())
```

### 10.2 预读机制

```python
class ReadAheadCache:
    """
    预读缓存
    """
    def __init__(self, readahead_size=4):
        self.cache = {}
        self.readahead_size = readahead_size
    
    def read_sequential(self, start_block, count, disk):
        """顺序读取（带预读）"""
        data = []
        
        for block_num in range(start_block, start_block + count):
            if block_num in self.cache:
                print(f"块{block_num}: 缓存命中")
                data.append(self.cache[block_num])
            else:
                # 触发预读
                self._readahead(block_num, disk)
                data.append(self.cache[block_num])
        
        return data
    
    def _readahead(self, block_num, disk):
        """预读后续块"""
        print(f"预读: 块{block_num}到块{block_num + self.readahead_size - 1}")
        
        for i in range(self.readahead_size):
            b = block_num + i
            if b not in self.cache:
                self.cache[b] = disk.read(b)

# 示例
disk = SimpleDisk()
ra_cache = ReadAheadCache(readahead_size=3)

# 顺序读取
ra_cache.read_sequential(10, 8, disk)
```

---

## 📚 学习建议

### 实验项目

1. **XV6操作系统**（MIT 6.828）
   - 理解真实OS实现
   - 完成Lab实验：系统调用、页表、文件系统、网络
   - 阅读xv6源代码（约9000行C代码）

2. **Linux内核模块编程**
   - 编写字符设备驱动
   - 修改进程调度算法
   - 实现自定义文件系统

3. **用户态线程库**
   - 实现协程（coroutine）
   - 上下文切换（setjmp/longjmp或汇编）
   - 协作式/抢占式调度

4. **虚拟内存模拟器**
   - 多级页表实现
   - TLB模拟
   - 页面置换算法对比

### 推荐资源

📖 **经典教材：**
- 《操作系统概念》（Silberschatz，恐龙书）- 理论全面
- 《现代操作系统》（Tanenbaum，第4版）- 原理清晰
- 《深入理解计算机系统》（CSAPP）- 系统级编程
- 《Linux内核设计与实现》（Robert Love）- Linux实战
- 《Operating Systems: Three Easy Pieces》- 免费在线

💻 **在线课程：**
- **MIT 6.828**（Operating System Engineering）
  - xv6操作系统实验
  - 世界顶级OS课程
- **Stanford CS140**（Operating Systems）
  - Pintos项目
- **清华uCore**（操作系统原理）
  - 中文教学
  - 8个实验

🎥 **视频资源：**
- 南京大学《操作系统：设计与实现》（蒋炎岩）
- CMU 15-213（CSAPP配套课程）
- Berkeley CS162（Operating Systems）

### 学习路线

**第1阶段：基础概念（2-3周）**
- ✅ 进程与线程
- ✅ 调度算法
- ✅ 同步原语（信号量、锁、条件变量）

**第2阶段：内存管理（3-4周）**
- ✅ 分页与分段
- ✅ 虚拟内存
- ✅ 页面置换算法

**第3阶段：文件系统（2-3周）**
- ✅ 文件组织
- ✅ 目录结构
- ✅ 磁盘调度

**第4阶段：高级主题（4-5周）**
- ✅ I/O系统
- ✅ 死锁处理
- ✅ 安全机制

**第5阶段：实战项目（持续）**
- ✅ 完成xv6实验
- ✅ 阅读Linux源码
- ✅ 编写内核模块

### 面试高频题

**进程与线程**
1. 进程和线程的区别？
2. 进程间通信方式有哪些？
3. 什么是僵尸进程？如何避免？
4. 孤儿进程是什么？

**内存管理**
1. 虚拟内存的作用？
2. 分页和分段的区别？
3. TLB是什么？为什么需要？
4. 缺页中断处理流程？

**文件系统**
1. inode包含什么信息？
2. 硬链接和软链接的区别？
3. 文件描述符和文件指针的关系？
4. ext4文件系统特点？

**同步与死锁**
1. 生产者消费者问题如何解决？
2. 死锁的四个必要条件？
3. 如何避免死锁？
4. 自旋锁和互斥锁的区别？

### 调试技巧

**GDB调试内核**
```bash
# QEMU + GDB调试xv6
qemu-system-i386 -s -S -hda xv6.img

# 另一终端
gdb kernel
(gdb) target remote localhost:1234
(gdb) break exec
(gdb) continue
```

**strace系统调用跟踪**
```bash
strace -e trace=open,read,write ./program
```

**内核日志**
```bash
dmesg | tail
journalctl -k  # systemd日志
```

### 常见错误

❌ **错误1**：忽略同步问题

- ✅ 多线程必须加锁
- ✅ 理解竞态条件

❌ **错误2**：死锁不知如何排查

- ✅ 使用银行家算法
- ✅ 避免循环等待

❌ **错误3**：内存泄漏

- ✅ malloc/free配对
- ✅ 使用valgrind检测

❌ **错误4**：只看理论不实践

- ✅ 必须写代码！
- ✅ 完成实验项目

### 实用工具

**性能分析**
- `top/htop` - 进程监控
- `vmstat` - 虚拟内存统计
- `iostat` - I/O统计
- `perf` - 性能分析

**调试工具**
- `gdb` - 调试器
- `strace` - 系统调用跟踪
- `valgrind` - 内存检测
- `ftrace` - 内核函数跟踪

---

> **记住**：理解操作系统是成为系统工程师的必经之路！💻
> 
> **学习心得**：
> - 操作系统是抽象的艺术
> - 多动手，少空谈
> - 理论+实践=真正掌握
> - 阅读源码是最好的老师

