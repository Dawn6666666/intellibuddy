![(七)文件系统详解](https://via.placeholder.com/800x200?text=File+System+Details)

# 操作系统 - (七)文件系统详解

深入理解文件系统。

---


### 7.1 inode结构

```python
import time

class Inode:
    """
    Unix风格inode
    """
    def __init__(self, inode_num, file_type='file'):
        self.inode_num = inode_num
        self.file_type = file_type  # 'file', 'dir', 'link'
        self.mode = 0o644  # 权限
        self.uid = 1000    # 用户ID
        self.gid = 1000    # 组ID
        self.size = 0      # 文件大小
        self.atime = time.time()  # 访问时间
        self.mtime = time.time()  # 修改时间
        self.ctime = time.time()  # 状态改变时间
        self.links_count = 1       # 硬链接数
        
        # 数据块指针
        self.direct_blocks = [None] * 12     # 12个直接块
        self.single_indirect = None          # 一级间接块
        self.double_indirect = None          # 二级间接块
        self.triple_indirect = None          # 三级间接块
    
    def allocate_block(self, block_num):
        """分配数据块"""
        # 先分配直接块
        for i in range(len(self.direct_blocks)):
            if self.direct_blocks[i] is None:
                self.direct_blocks[i] = block_num
                return True
        
        # TODO: 间接块分配
        print("直接块已满，需要间接块")
        return False
    
    def get_info(self):
        """获取文件信息"""
        return {
            'inode': self.inode_num,
            'type': self.file_type,
            'size': self.size,
            'links': self.links_count,
            'blocks': [b for b in self.direct_blocks if b is not None]
        }

# 示例
inode = Inode(inode_num=12345)
inode.allocate_block(100)
inode.allocate_block(101)
inode.size = 8192

print(inode.get_info())
```

### 7.2 日志文件系统

```python
class JournalingFileSystem:
    """
    日志文件系统（简化版）
    """
    def __init__(self):
        self.journal = []  # 日志区
        self.metadata = {}  # 元数据区
        self.data = {}      # 数据区
        self.checkpoint = 0
    
    def begin_transaction(self):
        """开始事务"""
        return {
            'id': len(self.journal),
            'operations': []
        }
    
    def log_operation(self, transaction, operation):
        """记录操作到日志"""
        transaction['operations'].append(operation)
    
    def commit_transaction(self, transaction):
        """提交事务"""
        print(f"\n提交事务{transaction['id']}:")
        
        # 1. 写日志（Write-Ahead Logging）
        self.journal.append({
            'id': transaction['id'],
            'ops': transaction['operations'].copy(),
            'status': 'committed'
        })
        print(f"  日志记录: {transaction['operations']}")
        
        # 2. 应用操作
        for op in transaction['operations']:
            self._apply_operation(op)
        
        # 3. 标记完成
        self.journal[-1]['status'] = 'completed'
        print(f"  事务完成")
    
    def _apply_operation(self, operation):
        """应用操作到文件系统"""
        op_type = operation['type']
        
        if op_type == 'write':
            self.data[operation['block']] = operation['data']
            print(f"  写数据: 块{operation['block']}")
        elif op_type == 'update_metadata':
            self.metadata[operation['file']] = operation['meta']
            print(f"  更新元数据: {operation['file']}")
    
    def recover(self):
        """崩溃恢复"""
        print("\n执行恢复...")
        
        for entry in self.journal:
            if entry['status'] == 'committed':
                print(f"重放事务{entry['id']}")
                for op in entry['ops']:
                    self._apply_operation(op)
            elif entry['status'] == 'completed':
                print(f"事务{entry['id']}已完成，跳过")

# 示例
jfs = JournalingFileSystem()

# 事务1：写文件
txn1 = jfs.begin_transaction()
jfs.log_operation(txn1, {
    'type': 'write',
    'block': 100,
    'data': 'Hello World'
})
jfs.log_operation(txn1, {
    'type': 'update_metadata',
    'file': 'test.txt',
    'meta': {'size': 11, 'blocks': [100]}
})
jfs.commit_transaction(txn1)

# 模拟崩溃恢复
jfs.recover()
```

### 7.3 磁盘配额管理

```python
class DiskQuota:
    """
    磁盘配额系统
    """
    def __init__(self):
        self.quotas = {}  # 用户配额
        self.usage = {}   # 用户使用情况
    
    def set_quota(self, user, soft_limit, hard_limit):
        """设置配额"""
        self.quotas[user] = {
            'soft': soft_limit,  # 软限制（警告）
            'hard': hard_limit,  # 硬限制（禁止）
            'grace_period': 7 * 24 * 3600  # 宽限期7天
        }
        
        if user not in self.usage:
            self.usage[user] = {
                'blocks': 0,
                'files': 0,
                'soft_exceeded_time': None
            }
    
    def allocate(self, user, blocks):
        """分配空间"""
        if user not in self.quotas:
            return True, "无配额限制"
        
        quota = self.quotas[user]
        usage = self.usage[user]
        new_usage = usage['blocks'] + blocks
        
        # 检查硬限制
        if new_usage > quota['hard']:
            return False, f"超过硬限制{quota['hard']}块"
        
        # 检查软限制
        if new_usage > quota['soft']:
            if usage['soft_exceeded_time'] is None:
                usage['soft_exceeded_time'] = time.time()
                print(f"⚠️ 用户{user}超过软限制，进入宽限期")
            else:
                elapsed = time.time() - usage['soft_exceeded_time']
                if elapsed > quota['grace_period']:
                    return False, "宽限期已过，拒绝分配"
        
        # 分配成功
        usage['blocks'] += blocks
        return True, f"分配{blocks}块，当前使用{usage['blocks']}/{quota['hard']}"
    
    def get_quota_info(self, user):
        """查询配额信息"""
        if user not in self.quotas:
            return "无配额限制"
        
        quota = self.quotas[user]
        usage = self.usage[user]
        
        return {
            '用户': user,
            '已用': usage['blocks'],
            '软限制': quota['soft'],
            '硬限制': quota['hard'],
            '使用率': f"{usage['blocks']/quota['hard']*100:.1f}%"
        }

# 示例
dq = DiskQuota()
dq.set_quota('alice', soft_limit=1000, hard_limit=1200)

print(dq.allocate('alice', 500))
print(dq.allocate('alice', 600))  # 超过软限制
print(dq.get_quota_info('alice'))
```

---

## 8. I/O系统