![(ä¸€)è¿›ç¨‹ç®¡ç†](https://via.placeholder.com/800x200?text=Process+Management)

# æ“ä½œç³»ç»Ÿ - (ä¸€)è¿›ç¨‹ç®¡ç†

ç†è§£è¿›ç¨‹è°ƒåº¦ä¸åŒæ­¥ã€‚

---

# æ“ä½œç³»ç»Ÿ

> ğŸ’¡ **è¯¾ç¨‹ä¿¡æ¯**
> - å­¦ä¹ æ—¶é•¿ï¼š200å°æ—¶
> - éš¾åº¦ç­‰çº§ï¼šâ­â­â­â­â­ (æé«˜)
> - å‰ç½®è¯¾ç¨‹ï¼šè®¡ç®—æœºç»„æˆåŸç†ã€Cè¯­è¨€
> - **ç³»ç»Ÿè½¯ä»¶çš„æ ¸å¿ƒ**

---

## ğŸ“š è¯¾ç¨‹æ¦‚è¿°

æ“ä½œç³»ç»Ÿæ˜¯ç®¡ç†è®¡ç®—æœºç¡¬ä»¶å’Œè½¯ä»¶èµ„æºçš„ç³»ç»Ÿè½¯ä»¶ï¼Œä¸ºä¸Šå±‚åº”ç”¨æä¾›æ¥å£ã€‚

### æ ¸å¿ƒåŠŸèƒ½

1. **è¿›ç¨‹ç®¡ç†** - è°ƒåº¦ã€åŒæ­¥ã€é€šä¿¡
2. **å†…å­˜ç®¡ç†** - åˆ†é…ã€å›æ”¶ã€è™šæ‹Ÿå†…å­˜
3. **æ–‡ä»¶ç³»ç»Ÿ** - å­˜å‚¨ã€æ£€ç´¢ã€ä¿æŠ¤
4. **I/Oç®¡ç†** - è®¾å¤‡é©±åŠ¨ã€ç¼“å†²ã€è°ƒåº¦

---

## 1. è¿›ç¨‹ç®¡ç†

### 1.1 è¿›ç¨‹æ¦‚å¿µ

**è¿›ç¨‹æ§åˆ¶å—ï¼ˆPCBï¼‰ï¼š**

```c
struct PCB {
    int pid;              // è¿›ç¨‹ID
    int state;            // è¿›ç¨‹çŠ¶æ€
    int priority;         // ä¼˜å…ˆçº§
    void *pc;             // ç¨‹åºè®¡æ•°å™¨
    void *registers[32];  // å¯„å­˜å™¨
    void *mem_limits[2];  // å†…å­˜ç•Œé™
    struct PCB *parent;   // çˆ¶è¿›ç¨‹
    struct PCB *children; // å­è¿›ç¨‹é“¾è¡¨
};
```

**è¿›ç¨‹çŠ¶æ€è½¬æ¢ï¼š**

```
æ–°å»º â†’ å°±ç»ª â‡„ è¿è¡Œ â†’ ç»ˆæ­¢
         â†•
       é˜»å¡
```

### 1.2 è¿›ç¨‹è°ƒåº¦ç®—æ³•

#### å…ˆæ¥å…ˆæœåŠ¡ï¼ˆFCFSï¼‰

```python
def fcfs_scheduling(processes):
    """
    å…ˆæ¥å…ˆæœåŠ¡è°ƒåº¦
    processes: [(pid, arrival_time, burst_time), ...]
    """
    processes.sort(key=lambda x: x[1])  # æŒ‰åˆ°è¾¾æ—¶é—´æ’åº
    
    current_time = 0
    waiting_times = []
    turnaround_times = []
    
    for pid, arrival, burst in processes:
        if current_time < arrival:
            current_time = arrival
        
        waiting_time = current_time - arrival
        turnaround_time = waiting_time + burst
        
        waiting_times.append(waiting_time)
        turnaround_times.append(turnaround_time)
        
        current_time += burst
        
        print(f"P{pid}: ç­‰å¾…æ—¶é—´={waiting_time}, å‘¨è½¬æ—¶é—´={turnaround_time}")
    
    print(f"å¹³å‡ç­‰å¾…æ—¶é—´: {sum(waiting_times) / len(waiting_times):.2f}")
    print(f"å¹³å‡å‘¨è½¬æ—¶é—´: {sum(turnaround_times) / len(turnaround_times):.2f}")

# ç¤ºä¾‹
processes = [
    (1, 0, 24),   # P1: åˆ°è¾¾0, æ‰§è¡Œ24
    (2, 1, 3),    # P2: åˆ°è¾¾1, æ‰§è¡Œ3
    (3, 2, 3)     # P3: åˆ°è¾¾2, æ‰§è¡Œ3
]

fcfs_scheduling(processes)
```

#### æœ€çŸ­ä½œä¸šä¼˜å…ˆï¼ˆSJFï¼‰

```python
def sjf_scheduling(processes):
    """
    æœ€çŸ­ä½œä¸šä¼˜å…ˆï¼ˆéæŠ¢å ï¼‰
    """
    processes.sort(key=lambda x: (x[1], x[2]))  # åˆ°è¾¾æ—¶é—´, æ‰§è¡Œæ—¶é—´
    
    ready_queue = []
    current_time = 0
    completed = []
    
    while len(completed) < len(processes):
        # æ·»åŠ åˆ°è¾¾çš„è¿›ç¨‹åˆ°å°±ç»ªé˜Ÿåˆ—
        for p in processes:
            if p not in completed and p not in ready_queue and p[1] <= current_time:
                ready_queue.append(p)
        
        if not ready_queue:
            current_time += 1
            continue
        
        # é€‰æ‹©æœ€çŸ­ä½œä¸š
        ready_queue.sort(key=lambda x: x[2])
        pid, arrival, burst = ready_queue.pop(0)
        
        waiting_time = current_time - arrival
        current_time += burst
        
        completed.append((pid, arrival, burst))
        print(f"P{pid}: å¼€å§‹={current_time-burst}, ç­‰å¾…={waiting_time}")

# ç¤ºä¾‹
processes = [(1, 0, 6), (2, 2, 8), (3, 4, 7), (4, 5, 3)]
sjf_scheduling(processes)
```

#### æ—¶é—´ç‰‡è½®è½¬ï¼ˆRRï¼‰

```python
from collections import deque

def round_robin(processes, quantum=4):
    """
    æ—¶é—´ç‰‡è½®è½¬
    quantum: æ—¶é—´ç‰‡å¤§å°
    """
    queue = deque(processes)
    current_time = 0
    
    while queue:
        pid, arrival, remaining = queue.popleft()
        
        if current_time < arrival:
            current_time = arrival
        
        # æ‰§è¡Œä¸€ä¸ªæ—¶é—´ç‰‡
        exec_time = min(quantum, remaining)
        current_time += exec_time
        remaining -= exec_time
        
        print(f"æ—¶é—´{current_time-exec_time}-{current_time}: P{pid}")
        
        # å¦‚æœæœªå®Œæˆï¼Œé‡æ–°å…¥é˜Ÿ
        if remaining > 0:
            queue.append((pid, current_time, remaining))

# ç¤ºä¾‹
processes = [(1, 0, 24), (2, 0, 3), (3, 0, 3)]
round_robin(processes, quantum=4)
```

### 1.3 è¿›ç¨‹åŒæ­¥

#### ç”Ÿäº§è€…-æ¶ˆè´¹è€…é—®é¢˜

```python
import threading
import time
from queue import Queue

class ProducerConsumer:
    def __init__(self, buffer_size=5):
        self.buffer = Queue(maxsize=buffer_size)
        self.mutex = threading.Lock()
        self.not_empty = threading.Semaphore(0)
        self.not_full = threading.Semaphore(buffer_size)
    
    def producer(self, id):
        for i in range(5):
            item = f"P{id}-Item{i}"
            
            self.not_full.acquire()  # ç­‰å¾…ç©ºä½
            
            with self.mutex:
                self.buffer.put(item)
                print(f"ç”Ÿäº§è€…{id}ç”Ÿäº§: {item}, ç¼“å†²åŒºå¤§å°: {self.buffer.qsize()}")
            
            self.not_empty.release()  # é€šçŸ¥éç©º
            time.sleep(0.1)
    
    def consumer(self, id):
        for _ in range(5):
            self.not_empty.acquire()  # ç­‰å¾…æœ‰æ•°æ®
            
            with self.mutex:
                item = self.buffer.get()
                print(f"æ¶ˆè´¹è€…{id}æ¶ˆè´¹: {item}, ç¼“å†²åŒºå¤§å°: {self.buffer.qsize()}")
            
            self.not_full.release()  # é€šçŸ¥æœ‰ç©ºä½
            time.sleep(0.15)
    
    def run(self):
        producers = [threading.Thread(target=self.producer, args=(i,)) for i in range(2)]
        consumers = [threading.Thread(target=self.consumer, args=(i,)) for i in range(2)]
        
        for t in producers + consumers:
            t.start()
        
        for t in producers + consumers:
            t.join()

pc = ProducerConsumer()
pc.run()
```

#### å“²å­¦å®¶å°±é¤é—®é¢˜

```python
import threading
import time

class DiningPhilosophers:
    def __init__(self, n=5):
        self.n = n
        self.forks = [threading.Lock() for _ in range(n)]
    
    def philosopher(self, id):
        left = id
        right = (id + 1) % self.n
        
        for _ in range(3):
            # æ€è€ƒ
            print(f"å“²å­¦å®¶{id}åœ¨æ€è€ƒ...")
            time.sleep(0.1)
            
            # æ‹¿èµ·å‰å­ï¼ˆé¿å…æ­»é”ï¼šç¼–å·å°çš„å…ˆæ‹¿ï¼‰
            first = min(left, right)
            second = max(left, right)
            
            self.forks[first].acquire()
            print(f"å“²å­¦å®¶{id}æ‹¿èµ·å‰å­{first}")
            
            self.forks[second].acquire()
            print(f"å“²å­¦å®¶{id}æ‹¿èµ·å‰å­{second}")
            
            # åƒé¥­
            print(f"å“²å­¦å®¶{id}æ­£åœ¨åƒé¥­")
            time.sleep(0.2)
            
            # æ”¾ä¸‹å‰å­
            self.forks[first].release()
            self.forks[second].release()
            print(f"å“²å­¦å®¶{id}æ”¾ä¸‹å‰å­")
    
    def start(self):
        philosophers = [threading.Thread(target=self.philosopher, args=(i,)) 
                       for i in range(self.n)]
        
        for p in philosophers:
            p.start()
        
        for p in philosophers:
            p.join()

dp = DiningPhilosophers(5)
dp.start()
```

### 1.4 æ­»é”

**å¿…è¦æ¡ä»¶ï¼š**

1. **äº’æ–¥** - èµ„æºç‹¬å 
2. **å æœ‰å¹¶ç­‰å¾…** - æŒæœ‰èµ„æºå¹¶ç­‰å¾…å…¶ä»–èµ„æº
3. **éæŠ¢å ** - èµ„æºä¸å¯å¼ºåˆ¶å‰¥å¤º
4. **å¾ªç¯ç­‰å¾…** - å­˜åœ¨èµ„æºè¯·æ±‚ç¯

**é“¶è¡Œå®¶ç®—æ³•ï¼ˆæ­»é”é¿å…ï¼‰ï¼š**

```python
class BankerAlgorithm:
    def __init__(self, available, max_need, allocation):
        self.available = available.copy()
        self.max_need = max_need
        self.allocation = allocation
        self.need = [[max_need[i][j] - allocation[i][j] 
                      for j in range(len(available))] 
                     for i in range(len(allocation))]
    
    def is_safe(self):
        """å®‰å…¨æ€§æ£€æŸ¥"""
        work = self.available.copy()
        finish = [False] * len(self.allocation)
        safe_sequence = []
        
        while len(safe_sequence) < len(self.allocation):
            found = False
            
            for i in range(len(self.allocation)):
                if not finish[i] and all(self.need[i][j] <= work[j] 
                                         for j in range(len(work))):
                    # è¿›ç¨‹iå¯ä»¥å®Œæˆ
                    for j in range(len(work)):
                        work[j] += self.allocation[i][j]
                    
                    finish[i] = True
                    safe_sequence.append(i)
                    found = True
                    break
            
            if not found:
                return False, []
        
        return True, safe_sequence
    
    def request_resources(self, process_id, request):
        """èµ„æºè¯·æ±‚"""
        # æ£€æŸ¥è¯·æ±‚åˆæ³•æ€§
        if any(request[i] > self.need[process_id][i] for i in range(len(request))):
            return False, "è¯·æ±‚è¶…è¿‡éœ€æ±‚"
        
        if any(request[i] > self.available[i] for i in range(len(request))):
            return False, "èµ„æºä¸è¶³"
        
        # è¯•æ¢åˆ†é…
        for i in range(len(request)):
            self.available[i] -= request[i]
            self.allocation[process_id][i] += request[i]
            self.need[process_id][i] -= request[i]
        
        # å®‰å…¨æ€§æ£€æŸ¥
        safe, sequence = self.is_safe()
        
        if safe:
            return True, f"åˆ†é…æˆåŠŸï¼Œå®‰å…¨åºåˆ—: {sequence}"
        else:
            # å›æ»š
            for i in range(len(request)):
                self.available[i] += request[i]
                self.allocation[process_id][i] -= request[i]
                self.need[process_id][i] += request[i]
            return False, "ä¸å®‰å…¨ï¼Œæ‹’ç»åˆ†é…"

# ç¤ºä¾‹
available = [3, 3, 2]  # ABCä¸‰ç§èµ„æº
max_need = [
    [7, 5, 3],  # P0
    [3, 2, 2],  # P1
    [9, 0, 2],  # P2
    [2, 2, 2],  # P3
    [4, 3, 3]   # P4
]
allocation = [
    [0, 1, 0],
    [2, 0, 0],
    [3, 0, 2],
    [2, 1, 1],
    [0, 0, 2]
]

banker = BankerAlgorithm(available, max_need, allocation)
safe, seq = banker.is_safe()
print(f"åˆå§‹çŠ¶æ€: {'å®‰å…¨' if safe else 'ä¸å®‰å…¨'}, åºåˆ—: {seq}")

success, msg = banker.request_resources(1, [1, 0, 2])
print(f"P1è¯·æ±‚[1,0,2]: {msg}")
```

---

## 2. å†…å­˜ç®¡ç†