![(五)高级进程调度](https://via.placeholder.com/800x200?text=Advanced+Scheduling)

# 操作系统 - (五)高级进程调度

深入研究调度算法。

---


### 5.1 多级反馈队列（MLFQ）

```python
class MultilevelFeedbackQueue:
    """
    多级反馈队列调度
    优先级动态调整
    """
    def __init__(self, num_queues=3):
        self.queues = [[] for _ in range(num_queues)]
        self.time_quantum = [2**i for i in range(num_queues)]  # [1, 2, 4, ...]
        self.current_time = 0
    
    def add_process(self, process, priority=0):
        """添加进程到最高优先级队列"""
        self.queues[priority].append(process)
    
    def schedule(self):
        """调度执行"""
        for level in range(len(self.queues)):
            if not self.queues[level]:
                continue
            
            process = self.queues[level].pop(0)
            pid, remaining_time = process
            
            # 执行一个时间片
            exec_time = min(self.time_quantum[level], remaining_time)
            self.current_time += exec_time
            remaining_time -= exec_time
            
            print(f"时间{self.current_time-exec_time}-{self.current_time}: "
                  f"P{pid} (队列{level}, 时间片{self.time_quantum[level]})")
            
            # 未完成则降级
            if remaining_time > 0:
                next_level = min(level + 1, len(self.queues) - 1)
                self.queues[next_level].append((pid, remaining_time))
                print(f"  → P{pid}降级到队列{next_level}")
            else:
                print(f"  → P{pid}完成")
            
            return True
        
        return False

# 示例
mlfq = MultilevelFeedbackQueue(num_queues=3)
mlfq.add_process((1, 7))
mlfq.add_process((2, 4))
mlfq.add_process((3, 1))

while mlfq.schedule():
    pass
```

### 5.2 实时调度（Rate Monotonic）

```python
import math

class RateMonotonicScheduling:
    """
    速率单调调度（RM）
    周期越短，优先级越高
    """
    def __init__(self, tasks):
        """
        tasks: [(period, execution_time), ...]
        """
        self.tasks = sorted(tasks, key=lambda x: x[0])  # 按周期排序
        self.schedule = []
    
    def is_schedulable(self):
        """可调度性分析"""
        n = len(self.tasks)
        utilization = sum(e/p for p, e in self.tasks)
        bound = n * (2**(1/n) - 1)
        
        print(f"利用率: {utilization:.3f}")
        print(f"上界: {bound:.3f}")
        
        return utilization <= bound
    
    def simulate(self, duration):
        """模拟调度"""
        if not self.is_schedulable():
            print("⚠️ 可能不可调度")
        
        # 任务状态：[下次释放时间, 剩余执行时间]
        task_state = [[0, 0] for _ in self.tasks]
        
        for t in range(duration):
            # 释放任务
            for i, (period, exec_time) in enumerate(self.tasks):
                if t % period == 0:
                    task_state[i][0] = t
                    task_state[i][1] = exec_time
            
            # 选择最高优先级就绪任务
            selected = None
            for i in range(len(self.tasks)):
                if task_state[i][1] > 0:
                    selected = i
                    break
            
            if selected is not None:
                task_state[selected][1] -= 1
                print(f"时刻{t}: 执行任务{selected} (周期{self.tasks[selected][0]})")
            else:
                print(f"时刻{t}: 空闲")

# 示例
tasks = [
    (5, 2),   # T1: 周期5, 执行2
    (10, 3),  # T2: 周期10, 执行3
]

rms = RateMonotonicScheduling(tasks)
rms.simulate(20)
```

---

## 6. 虚拟内存深入