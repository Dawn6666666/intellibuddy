# 线性代数 - (一)行列式

学习行列式的定义、性质和计算方法。

---

## 1.1 行列式的定义

**二阶行列式：**

$$
\begin{vmatrix}
a & b \\
c & d
\end{vmatrix} = ad - bc
$$

**三阶行列式（沙路法）：**

$$
\begin{vmatrix}
a_{11} & a_{12} & a_{13} \\
a_{21} & a_{22} & a_{23} \\
a_{31} & a_{32} & a_{33}
\end{vmatrix} = a_{11}a_{22}a_{33} + a_{12}a_{23}a_{31} + a_{13}a_{21}a_{32} - a_{13}a_{22}a_{31} - a_{11}a_{23}a_{32} - a_{12}a_{21}a_{33}
$$

**n阶行列式（递归定义）：**

按第一行展开：

$$
\det(A) = \sum_{j=1}^{n} (-1)^{1+j} a_{1j} M_{1j}
$$

其中 $M_{1j}$ 是余子式。

### 1.2 行列式的性质

**1. 转置不变性**

$$
\det(A^T) = \det(A)
$$

**几何意义**：行列式的值不因转置改变，因为它表示的是体积/面积。

**2. 行（列）交换变号**

$$
\det(..., r_i, ..., r_j, ...) = -\det(..., r_j, ..., r_i, ...)
$$

**应用**：判断矩阵是否为反对称矩阵（若 $A^T = -A$，则 $\det(A) = (-1)^n \det(A)$）

**3. 提取公因子**

$$
\det(..., kr, ...) = k \cdot \det(..., r, ...)
$$

**推论**：$\det(kA) = k^n \det(A)$（$n$ 阶矩阵）

**4. 行（列）相加性**

$$
\det(..., r_i + r_j, ...) = \det(..., r_i, ...) + \det(..., r_j, ...)
$$

**注意**：不同于 $\det(A + B) \neq \det(A) + \det(B)$

**5. 乘法性质**

$$
\det(AB) = \det(A) \cdot \det(B)
$$

**推论**：$\det(A^{-1}) = \frac{1}{\det(A)}$

**6. 行列式为零的充要条件**

- 存在两行（列）成比例
- 存在全零行（列）
- 行（列）向量线性相关

**代码验证性质：**

```python
import numpy as np

A = np.array([[1, 2], [3, 4]])
B = np.array([[5, 6], [7, 8]])

# 性质1: 转置不变
print(f"det(A) = {np.linalg.det(A):.2f}")
print(f"det(A^T) = {np.linalg.det(A.T):.2f}")

# 性质5: 乘法性质
print(f"det(AB) = {np.linalg.det(A @ B):.2f}")
print(f"det(A) * det(B) = {np.linalg.det(A) * np.linalg.det(B):.2f}")

# 性质3: 数乘
k = 3
print(f"det(3A) = {np.linalg.det(k * A):.2f}")
print(f"3^2 * det(A) = {k**2 * np.linalg.det(A):.2f}")
```

**几何意义：行列式表示体积**

```python
import matplotlib.pyplot as plt
from matplotlib.patches import Polygon

# 2D情况：行列式是平行四边形面积
A = np.array([[2, 1], [1, 2]])

# 绘制平行四边形
origin = np.array([0, 0])
v1 = A[:, 0]
v2 = A[:, 1]

parallelogram = np.array([
    origin,
    v1,
    v1 + v2,
    v2,
    origin
])

plt.figure(figsize=(6, 6))
plt.fill(parallelogram[:, 0], parallelogram[:, 1], alpha=0.3, color='blue')
plt.plot(parallelogram[:, 0], parallelogram[:, 1], 'b-', linewidth=2)
plt.arrow(0, 0, v1[0], v1[1], head_width=0.1, color='red', label=f'v1={v1}')
plt.arrow(0, 0, v2[0], v2[1], head_width=0.1, color='green', label=f'v2={v2}')
plt.grid(True)
plt.axis('equal')
plt.title(f'面积 = det(A) = {np.linalg.det(A):.1f}')
plt.legend()
plt.show()
```

### 1.3 行列式的计算

**示例1：三阶行列式**

$$
\begin{vmatrix}
1 & 2 & 3 \\
4 & 5 & 6 \\
7 & 8 & 9
\end{vmatrix} = 1 \cdot \begin{vmatrix} 5 & 6 \\ 8 & 9 \end{vmatrix} - 2 \cdot \begin{vmatrix} 4 & 6 \\ 7 & 9 \end{vmatrix} + 3 \cdot \begin{vmatrix} 4 & 5 \\ 7 & 8 \end{vmatrix}
$$

$$
= 1(45-48) - 2(36-42) + 3(32-35) = -3 + 12 - 9 = 0
$$

**示例2：上三角行列式**

$$
\begin{vmatrix}
a_{11} & a_{12} & a_{13} \\
0 & a_{22} & a_{23} \\
0 & 0 & a_{33}
\end{vmatrix} = a_{11} \cdot a_{22} \cdot a_{33}
$$

（对角线元素之积）

**NumPy实现：**

```python
import numpy as np

A = np.array([
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
])

det_A = np.linalg.det(A)
print(f"行列式: {det_A}")  # 接近0（数值误差）
```

### 1.4 克莱姆法则

对于线性方程组 $Ax = b$，若 $\det(A) \neq 0$，则唯一解为

$$
x_i = \frac{\det(A_i)}{\det(A)}
$$

其中 $A_i$ 是用 $b$ 替换 $A$ 的第 $i$ 列得到的矩阵。

**示例：**

$$
\begin{cases}
2x + y = 5 \\
x - y = 1
\end{cases}
$$

$$
\det(A) = \begin{vmatrix} 2 & 1 \\ 1 & -1 \end{vmatrix} = -3
$$

$$
x = \frac{\begin{vmatrix} 5 & 1 \\ 1 & -1 \end{vmatrix}}{-3} = \frac{-6}{-3} = 2
$$

$$
y = \frac{\begin{vmatrix} 2 & 5 \\ 1 & 1 \end{vmatrix}}{-3} = \frac{-3}{-3} = 1
$$

**Python实现克莱姆法则：**

```python
def cramers_rule(A, b):
    """
    克莱姆法则求解线性方程组
    
    参数:
        A: 系数矩阵 (n×n)
        b: 常数向量 (n×1)
    
    返回:
        x: 解向量
    """
    det_A = np.linalg.det(A)
    
    if abs(det_A) < 1e-10:
        raise ValueError("矩阵不可逆，无法使用克莱姆法则")
    
    n = len(b)
    x = np.zeros(n)
    
    for i in range(n):
        # 用b替换第i列
        A_i = A.copy()
        A_i[:, i] = b
        x[i] = np.linalg.det(A_i) / det_A
    
    return x

# 示例
A = np.array([
    [2, 1],
    [1, -1]
], dtype=float)
b = np.array([5, 1], dtype=float)

x = cramers_rule(A, b)
print(f"解: x={x[0]:.1f}, y={x[1]:.1f}")  # x=2.0, y=1.0

# 验证
print(f"验证: Ax = {A @ x}, b = {b}")
```

**复杂示例：三元方程组**

$$
\begin{cases}
x + 2y + 3z = 14 \\
2x + y + z = 9 \\
3x + y + 2z = 13
\end{cases}
$$

```python
A = np.array([
    [1, 2, 3],
    [2, 1, 1],
    [3, 1, 2]
], dtype=float)
b = np.array([14, 9, 13], dtype=float)

x = cramers_rule(A, b)
print(f"解: x={x[0]:.0f}, y={x[1]:.0f}, z={x[2]:.0f}")  # x=1, y=2, z=3
```

**时间复杂度分析：**

- 克莱姆法则：$O(n! \cdot n)$（计算 $n+1$ 个行列式）
- 高斯消元：$O(n^3)$
- **结论**：克莱姆法则仅适用于小规模问题（$n \leq 3$），大规模用高斯消元

---

**本章完**
