![(七)汇编语言编程](https://via.placeholder.com/800x200?text=Assembly+Programming)

# 计算机组成原理 - (七)汇编语言编程

掌握汇编语言的基本编程。

---


### 8.1 MIPS 汇编基础

**寄存器约定：**

| 寄存器 | 名称 | 用途 |
|--------|------|------|
| $0 | $zero | 常量0 |
| $1 | $at | 汇编器临时变量 |
| $2-$3 | $v0-$v1 | 函数返回值 |
| $4-$7 | $a0-$a3 | 函数参数 |
| $8-$15 | $t0-$t7 | 临时变量 |
| $16-$23 | $s0-$s7 | 保存的变量 |
| $28 | $gp | 全局指针 |
| $29 | $sp | 栈指针 |
| $30 | $fp | 帧指针 |
| $31 | $ra | 返回地址 |

**示例1：简单的加法**

```asm
# 计算 c = a + b
    .data
a:  .word 5
b:  .word 10
c:  .word 0

    .text
main:
    lw   $t0, a       # 加载a到$t0
    lw   $t1, b       # 加载b到$t1
    add  $t2, $t0, $t1  # $t2 = $t0 + $t1
    sw   $t2, c       # 存储结果到c
    
    # 退出程序
    li   $v0, 10
    syscall
```

**示例2：数组求和**

```asm
# 计算数组元素之和
    .data
array:  .word 1, 2, 3, 4, 5
size:   .word 5
sum:    .word 0

    .text
main:
    la   $t0, array   # 数组地址
    lw   $t1, size    # 数组大小
    li   $t2, 0       # sum = 0
    li   $t3, 0       # i = 0

loop:
    beq  $t3, $t1, done  # if i == size, goto done
    lw   $t4, 0($t0)     # 加载array[i]
    add  $t2, $t2, $t4   # sum += array[i]
    addi $t0, $t0, 4     # 移动到下一个元素
    addi $t3, $t3, 1     # i++
    j    loop

done:
    sw   $t2, sum     # 保存结果
    
    li   $v0, 10
    syscall
```

**示例3：函数调用（阶乘）**

```asm
# 计算n! (阶乘)
    .data
n:      .word 5
result: .word 0

    .text
main:
    lw   $a0, n       # 加载n作为参数
    jal  factorial    # 调用factorial函数
    sw   $v0, result  # 保存结果
    
    li   $v0, 10
    syscall

# 函数: int factorial(int n)
factorial:
    addi $sp, $sp, -8  # 分配栈空间
    sw   $ra, 4($sp)   # 保存返回地址
    sw   $a0, 0($sp)   # 保存参数n
    
    li   $v0, 1        # 默认返回值 = 1
    ble  $a0, 1, fact_done  # if n <= 1, return 1
    
    # 递归调用
    addi $a0, $a0, -1  # n-1
    jal  factorial     # factorial(n-1)
    
    lw   $a0, 0($sp)   # 恢复n
    mul  $v0, $v0, $a0 # result = factorial(n-1) * n

fact_done:
    lw   $ra, 4($sp)   # 恢复返回地址
    addi $sp, $sp, 8   # 释放栈空间
    jr   $ra           # 返回
```

**示例4：字符串处理**

```asm
# 计算字符串长度
    .data
str:    .asciiz "Hello, World!"
length: .word 0

    .text
main:
    la   $t0, str     # 字符串地址
    li   $t1, 0       # length = 0

count_loop:
    lb   $t2, 0($t0)  # 加载字符
    beq  $t2, $zero, count_done  # 如果是'\0'，结束
    addi $t1, $t1, 1  # length++
    addi $t0, $t0, 1  # 下一个字符
    j    count_loop

count_done:
    sw   $t1, length
    
    # 打印长度
    li   $v0, 1
    move $a0, $t1
    syscall
    
    li   $v0, 10
    syscall
```

### 8.2 x86 汇编示例

**示例1：基本算术（AT&T语法）**

```asm
.section .data
    a: .long 10
    b: .long 20
    c: .long 0

.section .text
.globl _start

_start:
    movl a, %eax      # eax = a
    addl b, %eax      # eax += b
    movl %eax, c      # c = eax
    
    # 系统调用退出
    movl $1, %eax
    xorl %ebx, %ebx
    int $0x80
```

**示例2：条件分支（if-else）**

```asm
# 伪代码：if (a > b) c = a; else c = b;
.section .data
    a: .long 15
    b: .long 10
    c: .long 0

.section .text
.globl _start

_start:
    movl a, %eax
    movl b, %ebx
    cmpl %ebx, %eax   # 比较 a 和 b
    jle  else_branch  # 如果 a <= b，跳转
    
    # if分支
    movl %eax, c
    jmp  end_if

else_branch:
    movl %ebx, c

end_if:
    # 退出
    movl $1, %eax
    xorl %ebx, %ebx
    int $0x80
```

### 8.3 内联汇编（C语言中使用）

**示例1：读取CPU时间戳计数器**

```c
#include <stdio.h>
#include <stdint.h>

uint64_t rdtsc() {
    uint32_t lo, hi;
    __asm__ __volatile__ (
        "rdtsc"
        : "=a" (lo), "=d" (hi)
    );
    return ((uint64_t)hi << 32) | lo;
}

int main() {
    uint64_t start = rdtsc();
    
    // 执行一些操作
    volatile int sum = 0;
    for (int i = 0; i < 1000000; i++) {
        sum += i;
    }
    
    uint64_t end = rdtsc();
    printf("Cycles: %llu\n", end - start);
    return 0;
}
```

**示例2：原子操作**

```c
#include <stdio.h>

int atomic_add(int *ptr, int value) {
    int result;
    __asm__ __volatile__ (
        "lock; xaddl %0, %1"
        : "=r" (result), "+m" (*ptr)
        : "0" (value)
        : "memory"
    );
    return result;
}

int main() {
    int counter = 0;
    int old_value = atomic_add(&counter, 5);
    printf("Old: %d, New: %d\n", old_value, counter);
    return 0;
}
```

---

## 9. 实验指导与实践