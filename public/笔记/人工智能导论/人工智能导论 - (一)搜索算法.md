![(ä¸€)æœç´¢ç®—æ³•](https://via.placeholder.com/800x200?text=Search+Algorithms)

# äººå·¥æ™ºèƒ½å¯¼è®º - (ä¸€)æœç´¢ç®—æ³•

å­¦ä¹ AIæœç´¢ç­–ç•¥ã€‚

---

# äººå·¥æ™ºèƒ½å¯¼è®º

> ğŸ’¡ **è¯¾ç¨‹ä¿¡æ¯**
> - å­¦ä¹ æ—¶é•¿ï¼š120å°æ—¶
> - éš¾åº¦ç­‰çº§ï¼šâ­â­â­ (ä¸­é«˜)
> - **AIæ—¶ä»£çš„å…¥é—¨æŒ‡å—**

---

## ğŸ“š AIå‘å±•å†ç¨‹

```
1950s: å›¾çµæµ‹è¯• â†’ 1960s: ä¸“å®¶ç³»ç»Ÿ â†’ 1980s: æœºå™¨å­¦ä¹  â†’ 2010s: æ·±åº¦å­¦ä¹  â†’ 2020s: å¤§æ¨¡å‹
```

---

## 1. æœç´¢ç®—æ³•

### 1.1 å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰

```python
from collections import deque

def bfs(graph, start, goal):
    """å¹¿åº¦ä¼˜å…ˆæœç´¢"""
    queue = deque([(start, [start])])
    visited = {start}
    
    while queue:
        node, path = queue.popleft()
        
        if node == goal:
            return path
        
        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append((neighbor, path + [neighbor]))
    
    return None

# ç¤ºä¾‹
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}

path = bfs(graph, 'A', 'F')
print(f"è·¯å¾„: {path}")
```

### 1.2 A*ç®—æ³•

```python
import heapq

def a_star(graph, start, goal, heuristic):
    """A*æœç´¢ç®—æ³•"""
    open_set = [(0, start, [start])]
    closed_set = set()
    g_score = {start: 0}
    
    while open_set:
        f_score, current, path = heapq.heappop(open_set)
        
        if current == goal:
            return path
        
        if current in closed_set:
            continue
        
        closed_set.add(current)
        
        for neighbor, cost in graph.get(current, []):
            tentative_g = g_score[current] + cost
            
            if neighbor not in g_score or tentative_g < g_score[neighbor]:
                g_score[neighbor] = tentative_g
                f_score = tentative_g + heuristic(neighbor, goal)
                heapq.heappush(open_set, (f_score, neighbor, path + [neighbor]))
    
    return None

# å¯å‘å¼å‡½æ•°ï¼ˆæ›¼å“ˆé¡¿è·ç¦»ï¼‰
def manhattan_distance(a, b):
    return abs(a[0] - b[0]) + abs(a[1] - b[1])
```

---

## 2. æœºå™¨å­¦ä¹ åŸºç¡€