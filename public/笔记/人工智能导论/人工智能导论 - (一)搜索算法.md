![(一)搜索算法](https://via.placeholder.com/800x200?text=Search+Algorithms)

# 人工智能导论 - (一)搜索算法

学习AI搜索策略。

---

# 人工智能导论

> 💡 **课程信息**
> - 学习时长：120小时
> - 难度等级：⭐⭐⭐ (中高)
> - **AI时代的入门指南**

---

## 📚 AI发展历程

```
1950s: 图灵测试 → 1960s: 专家系统 → 1980s: 机器学习 → 2010s: 深度学习 → 2020s: 大模型
```

---

## 1. 搜索算法

### 1.1 广度优先搜索（BFS）

```python
from collections import deque

def bfs(graph, start, goal):
    """广度优先搜索"""
    queue = deque([(start, [start])])
    visited = {start}
    
    while queue:
        node, path = queue.popleft()
        
        if node == goal:
            return path
        
        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append((neighbor, path + [neighbor]))
    
    return None

# 示例
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}

path = bfs(graph, 'A', 'F')
print(f"路径: {path}")
```

### 1.2 A*算法

```python
import heapq

def a_star(graph, start, goal, heuristic):
    """A*搜索算法"""
    open_set = [(0, start, [start])]
    closed_set = set()
    g_score = {start: 0}
    
    while open_set:
        f_score, current, path = heapq.heappop(open_set)
        
        if current == goal:
            return path
        
        if current in closed_set:
            continue
        
        closed_set.add(current)
        
        for neighbor, cost in graph.get(current, []):
            tentative_g = g_score[current] + cost
            
            if neighbor not in g_score or tentative_g < g_score[neighbor]:
                g_score[neighbor] = tentative_g
                f_score = tentative_g + heuristic(neighbor, goal)
                heapq.heappush(open_set, (f_score, neighbor, path + [neighbor]))
    
    return None

# 启发式函数（曼哈顿距离）
def manhattan_distance(a, b):
    return abs(a[0] - b[0]) + abs(a[1] - b[1])
```

---

## 2. 机器学习基础