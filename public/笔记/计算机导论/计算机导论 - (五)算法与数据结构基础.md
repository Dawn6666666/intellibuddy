# 计算机导论 - (五)算法与数据结构基础

初步了解算法和数据结构的基本概念。

---


### 5.1 算法的概念

**定义**：解决问题的步骤和方法。

**特性：**
1. **有穷性**：有限步骤内完成
2. **确定性**：每步含义明确
3. **输入**：零个或多个输入
4. **输出**：一个或多个输出
5. **可行性**：每步都可实现

### 5.2 算法复杂度

#### 时间复杂度

**常见复杂度：**

| 复杂度 | 名称 | 示例 |
|--------|------|------|
| $O(1)$ | 常数 | 数组访问 |
| $O(\log n)$ | 对数 | 二分查找 |
| $O(n)$ | 线性 | 遍历数组 |
| $O(n \log n)$ | 线性对数 | 归并排序 |
| $O(n^2)$ | 平方 | 冒泡排序 |
| $O(2^n)$ | 指数 | 递归斐波那契 |
| $O(n!)$ | 阶乘 | 全排列 |

**增长趋势：**

$$
O(1) < O(\log n) < O(n) < O(n \log n) < O(n^2) < O(2^n) < O(n!)
$$

#### 空间复杂度

表示算法占用的额外存储空间。

### 5.3 基本数据结构

#### 线性结构

**数组（Array）：**
- 连续存储
- 随机访问 $O(1)$
- 插入删除 $O(n)$

**链表（Linked List）：**
- 非连续存储
- 随机访问 $O(n)$
- 插入删除 $O(1)$

**栈（Stack）：**
- 后进先出（LIFO）
- 操作：push、pop、peek

**队列（Queue）：**
- 先进先出（FIFO）
- 操作：enqueue、dequeue

#### 非线性结构

**树（Tree）：**
- 二叉树
- 二叉搜索树
- 平衡树（AVL、红黑树）

**图（Graph）：**
- 有向图、无向图
- 加权图

**哈希表（Hash Table）：**
- 键值对存储
- 平均 $O(1)$ 访问

### 5.4 经典算法

#### 排序算法

| 算法 | 时间复杂度（平均） | 空间复杂度 | 稳定性 |
|------|-------------------|-----------|--------|
| 冒泡排序 | $O(n^2)$ | $O(1)$ | 稳定 |
| 选择排序 | $O(n^2)$ | $O(1)$ | 不稳定 |
| 插入排序 | $O(n^2)$ | $O(1)$ | 稳定 |
| 快速排序 | $O(n \log n)$ | $O(\log n)$ | 不稳定 |
| 归并排序 | $O(n \log n)$ | $O(n)$ | 稳定 |
| 堆排序 | $O(n \log n)$ | $O(1)$ | 不稳定 |

#### 查找算法

**线性查找：** $O(n)$

**二分查找：** $O(\log n)$（要求有序）

```python
mid = (left + right) // 2
if arr[mid] == target:  # 找到
    return mid
elif arr[mid] < target:  # 搜索右半部分
    left = mid + 1
else:  # 搜索左半部分
    right = mid - 1
```

### 5.5 算法实战案例

#### 案例1：冒泡排序实现

**伪代码：**

```python
def BubbleSort(arr, n):
    for i in range(n):
        for j in range(n - i - 1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
```

**可视化示例：**

对数组 `[5, 2, 8, 1, 9]` 排序：

```plain
初始: [5, 2, 8, 1, 9]

第1轮:
[2, 5, 8, 1, 9]  → 比较5和2，交换
[2, 5, 8, 1, 9]  → 5和8不换
[2, 5, 1, 8, 9]  → 8和1交换
[2, 5, 1, 8, 9]  → 8和9不换

第2轮:
[2, 5, 1, 8, 9]  → 2和5不换
[2, 1, 5, 8, 9]  → 5和1交换
[2, 1, 5, 8, 9]  → 5和8不换

第3轮:
[1, 2, 5, 8, 9]  → 2和1交换
[1, 2, 5, 8, 9]  → 2和5不换

第4轮:
[1, 2, 5, 8, 9]  → 已排序

结果: [1, 2, 5, 8, 9]
```

**复杂度分析：**
- 外层循环：$n-1$ 次
- 内层循环：$(n-1) + (n-2) + ... + 1 = \frac{n(n-1)}{2}$
- 时间复杂度：$O(n^2)$

#### 案例2：二分查找实现

**问题：** 在有序数组 `[1, 3, 5, 7, 9, 11, 13, 15]` 中查找 `7`

**步骤：**

```plain
数组: [1, 3, 5, 7, 9, 11, 13, 15]
索引:  0  1  2  3  4   5   6   7

第1次: left=0, right=7
      mid = (0+7)//2 = 3
      arr[3] = 7 = target ✓ 找到！
```

**另一个例子：** 查找 `11`

```plain
第1次: left=0, right=7
      mid = 3, arr[3] = 7 < 11
      → 搜索右半部分 [9, 11, 13, 15]

第2次: left=4, right=7
      mid = 5, arr[5] = 11 = target ✓ 找到！
```

**复杂度：** $O(\log n)$，最多比较 $\log_2 8 = 3$ 次

#### 案例3：递归算法 - 斐波那契数列

**递归实现：**

```python
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)
```

**调用树（计算 fib(5)）：**

```plain
                    fib(5)
                  /        \
            fib(4)          fib(3)
           /      \        /      \
      fib(3)    fib(2)  fib(2)  fib(1)
      /   \     /   \   /   \
  fib(2) fib(1) f(1) f(0) f(1) f(0)
  /   \
f(1) f(0)
```

**问题：** 大量重复计算，时间复杂度 $O(2^n)$

**优化：** 动态规划

```python
def fibonacci_dp(n):
    if n <= 1:
        return n
    dp = [0] * (n+1)
    dp[1] = 1
    for i in range(2, n+1):
        dp[i] = dp[i-1] + dp[i-2]
    return dp[n]
```

**优化后复杂度：** $O(n)$

#### 案例4：哈希表应用 - 查重

**问题：** 判断数组中是否有重复元素

**方法1：暴力法** $O(n^2)$

```python
for i in range(n):
    for j in range(i+1, n):
        if arr[i] == arr[j]:
            return True
return False
```

**方法2：哈希表** $O(n)$

```python
seen = {}
for num in arr:
    if num in seen:
        return True
    seen[num] = True
return False
```

**示例：**

```plain
数组: [1, 3, 5, 3, 7]

num=1: seen={1}
num=3: seen={1, 3}
num=5: seen={1, 3, 5}
num=3: 已在seen中！返回True
```

### 5.6 算法设计策略

#### 1. 分治法（Divide and Conquer）

**思想：** 将问题分解为子问题，递归求解。

**示例：** 归并排序

```python
def MergeSort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = MergeSort(arr[0:mid])
    right = MergeSort(arr[mid:])
    return Merge(left, right)
```

#### 2. 贪心算法（Greedy）

**思想：** 每步选择当前最优解。

**示例：** 找零钱问题

```plain
硬币：25¢, 10¢, 5¢, 1¢
找67¢：2×25¢ + 1×10¢ + 1×5¢ + 2×1¢
```

#### 3. 动态规划（Dynamic Programming）

**思想：** 保存子问题解，避免重复计算。

**示例：** 背包问题、最长公共子序列

#### 4. 回溯法（Backtracking）

**思想：** 尝试所有可能，不满足则回退。

**示例：** N皇后问题、数独求解

---

## 6. 计算机网络基础