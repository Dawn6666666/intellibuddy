![(二)无监督学习](https://via.placeholder.com/800x200?text=Unsupervised+Learning)

# 机器学习 - (二)无监督学习

学习聚类与降维技术。

---


### 2.1 主成分分析（PCA）

```python
class PCA:
    def __init__(self, n_components):
        self.n_components = n_components
        self.components = None
        self.mean = None
    
    def fit(self, X):
        """训练PCA"""
        # 中心化数据
        self.mean = np.mean(X, axis=0)
        X_centered = X - self.mean
        
        # 计算协方差矩阵
        cov_matrix = np.cov(X_centered.T)
        
        # 特征值分解
        eigenvalues, eigenvectors = np.linalg.eig(cov_matrix)
        
        # 按特征值排序
        idxs = np.argsort(eigenvalues)[::-1]
        eigenvalues = eigenvalues[idxs]
        eigenvectors = eigenvectors[:, idxs]
        
        # 选择前n_components个主成分
        self.components = eigenvectors[:, :self.n_components]
    
    def transform(self, X):
        """降维"""
        X_centered = X - self.mean
        return np.dot(X_centered, self.components)
    
    def fit_transform(self, X):
        """训练并降维"""
        self.fit(X)
        return self.transform(X)

# 示例
X = np.random.randn(100, 5)
pca = PCA(n_components=2)
X_reduced = pca.fit_transform(X)
print(f"原始维度: {X.shape}, 降维后: {X_reduced.shape}")
```

### 2.2 DBSCAN聚类

```python
class DBSCAN:
    def __init__(self, eps=0.5, min_samples=5):
        self.eps = eps
        self.min_samples = min_samples
    
    def euclidean_distance(self, p1, p2):
        """欧几里得距离"""
        return np.sqrt(np.sum((p1 - p2) ** 2))
    
    def get_neighbors(self, X, point_idx):
        """获取邻居点"""
        neighbors = []
        for i, point in enumerate(X):
            if self.euclidean_distance(X[point_idx], point) <= self.eps:
                neighbors.append(i)
        return neighbors
    
    def fit_predict(self, X):
        """聚类"""
        n_points = len(X)
        labels = [-1] * n_points  # -1表示噪声点
        cluster_id = 0
        
        for i in range(n_points):
            if labels[i] != -1:  # 已处理
                continue
            
            neighbors = self.get_neighbors(X, i)
            
            if len(neighbors) < self.min_samples:
                labels[i] = -1  # 噪声点
            else:
                # 开始新聚类
                labels[i] = cluster_id
                
                # 扩展聚类
                seed_set = neighbors[:]
                j = 0
                while j < len(seed_set):
                    q = seed_set[j]
                    
                    if labels[q] == -1:
                        labels[q] = cluster_id
                    
                    if labels[q] != -1:
                        j += 1
                        continue
                    
                    labels[q] = cluster_id
                    new_neighbors = self.get_neighbors(X, q)
                    
                    if len(new_neighbors) >= self.min_samples:
                        seed_set.extend(new_neighbors)
                    
                    j += 1
                
                cluster_id += 1
        
        return np.array(labels)

# 示例
X = np.vstack([
    np.random.randn(20, 2) + [2, 2],
    np.random.randn(20, 2) + [-2, -2]
])

dbscan = DBSCAN(eps=1.0, min_samples=3)
labels = dbscan.fit_predict(X)
print(f"聚类标签: {np.unique(labels)}")
```

---

## 3. 深度学习基础