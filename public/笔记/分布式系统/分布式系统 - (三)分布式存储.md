![(ä¸‰)åˆ†å¸ƒå¼å­˜å‚¨](https://via.placeholder.com/800x200?text=Distributed+Storage)

# åˆ†å¸ƒå¼ç³»ç»Ÿ - (ä¸‰)åˆ†å¸ƒå¼å­˜å‚¨

å­¦ä¹ åˆ†å¸ƒå¼å­˜å‚¨ç³»ç»Ÿã€‚

---


### 3.1 ä¸€è‡´æ€§å“ˆå¸Œ

```python
import hashlib
import bisect

class ConsistentHash:
    def __init__(self, replicas=3):
        self.replicas = replicas
        self.ring = {}  # hash -> node
        self.sorted_keys = []
    
    def _hash(self, key):
        """è®¡ç®—å“ˆå¸Œå€¼"""
        return int(hashlib.md5(key.encode()).hexdigest(), 16)
    
    def add_node(self, node):
        """æ·»åŠ èŠ‚ç‚¹"""
        for i in range(self.replicas):
            key = self._hash(f"{node}:{i}")
            self.ring[key] = node
            bisect.insort(self.sorted_keys, key)
        
        print(f"â• æ·»åŠ èŠ‚ç‚¹: {node}")
    
    def remove_node(self, node):
        """ç§»é™¤èŠ‚ç‚¹"""
        for i in range(self.replicas):
            key = self._hash(f"{node}:{i}")
            if key in self.ring:
                del self.ring[key]
                self.sorted_keys.remove(key)
        
        print(f"â– ç§»é™¤èŠ‚ç‚¹: {node}")
    
    def get_node(self, key):
        """è·å–keyå¯¹åº”çš„èŠ‚ç‚¹"""
        if not self.ring:
            return None
        
        hash_key = self._hash(key)
        
        # æ‰¾åˆ°ç¬¬ä¸€ä¸ªå¤§äºç­‰äºhash_keyçš„èŠ‚ç‚¹
        idx = bisect.bisect_right(self.sorted_keys, hash_key)
        
        if idx == len(self.sorted_keys):
            idx = 0  # ç¯å½¢ç»“æ„
        
        return self.ring[self.sorted_keys[idx]]
    
    def get_nodes_for_key(self, key, count=3):
        """è·å–keyçš„å¤šä¸ªå‰¯æœ¬èŠ‚ç‚¹"""
        if not self.ring:
            return []
        
        hash_key = self._hash(key)
        idx = bisect.bisect_right(self.sorted_keys, hash_key)
        
        nodes = []
        seen = set()
        
        for _ in range(count):
            if idx >= len(self.sorted_keys):
                idx = 0
            
            node = self.ring[self.sorted_keys[idx]]
            if node not in seen:
                nodes.append(node)
                seen.add(node)
            
            idx += 1
            
            if len(nodes) == count or len(seen) == len(set(self.ring.values())):
                break
        
        return nodes

# æµ‹è¯•ä¸€è‡´æ€§å“ˆå¸Œ
ch = ConsistentHash()

# æ·»åŠ èŠ‚ç‚¹
for i in range(4):
    ch.add_node(f"server{i}")

# æµ‹è¯•æ•°æ®åˆ†å¸ƒ
keys = ['user1', 'user2', 'user3', 'user4', 'user5']
print("\nğŸ“Š æ•°æ®åˆ†å¸ƒ:")
for key in keys:
    nodes = ch.get_nodes_for_key(key, 3)
    print(f"{key} -> {nodes}")

# æ¨¡æ‹ŸèŠ‚ç‚¹æ•…éšœ
print("\nğŸ’¥ server1æ•…éšœ:")
ch.remove_node('server1')

print("\nğŸ“Š æ•…éšœåæ•°æ®åˆ†å¸ƒ:")
for key in keys:
    nodes = ch.get_nodes_for_key(key, 3)
    print(f"{key} -> {nodes}")
```

### 3.2 åˆ†å¸ƒå¼é”

```python
import time
import threading
import uuid

class DistributedLock:
    def __init__(self, redis_client=None):
        self.redis = redis_client or {}  # æ¨¡æ‹ŸRedis
        self.lock_timeout = 30  # 30ç§’è¶…æ—¶
    
    def acquire(self, resource, timeout=10):
        """è·å–åˆ†å¸ƒå¼é”"""
        identifier = str(uuid.uuid4())
        end_time = time.time() + timeout
        
        while time.time() < end_time:
            # å°è¯•è·å–é”
            if self._set_if_not_exists(resource, identifier, self.lock_timeout):
                return identifier
            
            time.sleep(0.001)  # 1ms
        
        return None
    
    def release(self, resource, identifier):
        """é‡Šæ”¾åˆ†å¸ƒå¼é”"""
        # Luaè„šæœ¬ä¿è¯åŸå­æ€§
        current_value = self.redis.get(resource)
        if current_value == identifier:
            del self.redis[resource]
            return True
        return False
    
    def _set_if_not_exists(self, key, value, ttl):
        """æ¨¡æ‹ŸRedis SETNX"""
        if key not in self.redis:
            self.redis[key] = value
            # ç®€åŒ–ï¼šä¸å®ç°çœŸæ­£çš„TTL
            return True
        return False

# ä½¿ç”¨åˆ†å¸ƒå¼é”
class Counter:
    def __init__(self):
        self.value = 0
        self.lock = DistributedLock()
    
    def increment(self, worker_id):
        """çº¿ç¨‹å®‰å…¨çš„é€’å¢"""
        lock_id = self.lock.acquire('counter_lock')
        
        if lock_id:
            try:
                old_value = self.value
                time.sleep(0.01)  # æ¨¡æ‹Ÿä¸šåŠ¡å¤„ç†
                self.value = old_value + 1
                print(f"Worker {worker_id}: {old_value} -> {self.value}")
            finally:
                self.lock.release('counter_lock', lock_id)
        else:
            print(f"Worker {worker_id}: è·å–é”å¤±è´¥")

# æµ‹è¯•åˆ†å¸ƒå¼é”
counter = Counter()
threads = []

for i in range(5):
    t = threading.Thread(target=counter.increment, args=(i,))
    threads.append(t)
    t.start()

for t in threads:
    t.join()

print(f"æœ€ç»ˆè®¡æ•°: {counter.value}")
```

---

## 4. å¾®æœåŠ¡æ¶æ„