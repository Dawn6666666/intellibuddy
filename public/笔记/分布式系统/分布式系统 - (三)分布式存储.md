![(三)分布式存储](https://via.placeholder.com/800x200?text=Distributed+Storage)

# 分布式系统 - (三)分布式存储

学习分布式存储系统。

---


### 3.1 一致性哈希

```python
import hashlib
import bisect

class ConsistentHash:
    def __init__(self, replicas=3):
        self.replicas = replicas
        self.ring = {}  # hash -> node
        self.sorted_keys = []
    
    def _hash(self, key):
        """计算哈希值"""
        return int(hashlib.md5(key.encode()).hexdigest(), 16)
    
    def add_node(self, node):
        """添加节点"""
        for i in range(self.replicas):
            key = self._hash(f"{node}:{i}")
            self.ring[key] = node
            bisect.insort(self.sorted_keys, key)
        
        print(f"➕ 添加节点: {node}")
    
    def remove_node(self, node):
        """移除节点"""
        for i in range(self.replicas):
            key = self._hash(f"{node}:{i}")
            if key in self.ring:
                del self.ring[key]
                self.sorted_keys.remove(key)
        
        print(f"➖ 移除节点: {node}")
    
    def get_node(self, key):
        """获取key对应的节点"""
        if not self.ring:
            return None
        
        hash_key = self._hash(key)
        
        # 找到第一个大于等于hash_key的节点
        idx = bisect.bisect_right(self.sorted_keys, hash_key)
        
        if idx == len(self.sorted_keys):
            idx = 0  # 环形结构
        
        return self.ring[self.sorted_keys[idx]]
    
    def get_nodes_for_key(self, key, count=3):
        """获取key的多个副本节点"""
        if not self.ring:
            return []
        
        hash_key = self._hash(key)
        idx = bisect.bisect_right(self.sorted_keys, hash_key)
        
        nodes = []
        seen = set()
        
        for _ in range(count):
            if idx >= len(self.sorted_keys):
                idx = 0
            
            node = self.ring[self.sorted_keys[idx]]
            if node not in seen:
                nodes.append(node)
                seen.add(node)
            
            idx += 1
            
            if len(nodes) == count or len(seen) == len(set(self.ring.values())):
                break
        
        return nodes

# 测试一致性哈希
ch = ConsistentHash()

# 添加节点
for i in range(4):
    ch.add_node(f"server{i}")

# 测试数据分布
keys = ['user1', 'user2', 'user3', 'user4', 'user5']
print("\n📊 数据分布:")
for key in keys:
    nodes = ch.get_nodes_for_key(key, 3)
    print(f"{key} -> {nodes}")

# 模拟节点故障
print("\n💥 server1故障:")
ch.remove_node('server1')

print("\n📊 故障后数据分布:")
for key in keys:
    nodes = ch.get_nodes_for_key(key, 3)
    print(f"{key} -> {nodes}")
```

### 3.2 分布式锁

```python
import time
import threading
import uuid

class DistributedLock:
    def __init__(self, redis_client=None):
        self.redis = redis_client or {}  # 模拟Redis
        self.lock_timeout = 30  # 30秒超时
    
    def acquire(self, resource, timeout=10):
        """获取分布式锁"""
        identifier = str(uuid.uuid4())
        end_time = time.time() + timeout
        
        while time.time() < end_time:
            # 尝试获取锁
            if self._set_if_not_exists(resource, identifier, self.lock_timeout):
                return identifier
            
            time.sleep(0.001)  # 1ms
        
        return None
    
    def release(self, resource, identifier):
        """释放分布式锁"""
        # Lua脚本保证原子性
        current_value = self.redis.get(resource)
        if current_value == identifier:
            del self.redis[resource]
            return True
        return False
    
    def _set_if_not_exists(self, key, value, ttl):
        """模拟Redis SETNX"""
        if key not in self.redis:
            self.redis[key] = value
            # 简化：不实现真正的TTL
            return True
        return False

# 使用分布式锁
class Counter:
    def __init__(self):
        self.value = 0
        self.lock = DistributedLock()
    
    def increment(self, worker_id):
        """线程安全的递增"""
        lock_id = self.lock.acquire('counter_lock')
        
        if lock_id:
            try:
                old_value = self.value
                time.sleep(0.01)  # 模拟业务处理
                self.value = old_value + 1
                print(f"Worker {worker_id}: {old_value} -> {self.value}")
            finally:
                self.lock.release('counter_lock', lock_id)
        else:
            print(f"Worker {worker_id}: 获取锁失败")

# 测试分布式锁
counter = Counter()
threads = []

for i in range(5):
    t = threading.Thread(target=counter.increment, args=(i,))
    threads.append(t)
    t.start()

for t in threads:
    t.join()

print(f"最终计数: {counter.value}")
```

---

## 4. 微服务架构