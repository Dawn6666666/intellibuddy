![(十)实战项目集锦](https://via.placeholder.com/800x200?text=Practice+Projects)

# 大学物理 - (十)实战项目集锦

综合物理知识的实践项目。

---


### 项目1：2D物理引擎

```python
class RigidBody:
    """刚体类"""
    def __init__(self, pos, vel, mass, shape='circle', radius=1):
        self.pos = np.array(pos, dtype=float)
        self.vel = np.array(vel, dtype=float)
        self.mass = mass
        self.shape = shape
        self.radius = radius
    
    def apply_force(self, force, dt):
        """施加力"""
        acc = force / self.mass
        self.vel += acc * dt
    
    def update(self, dt):
        """更新位置"""
        self.pos += self.vel * dt
    
    def check_collision(self, other):
        """检测碰撞（圆形）"""
        if self.shape == 'circle' and other.shape == 'circle':
            dist = np.linalg.norm(self.pos - other.pos)
            return dist < (self.radius + other.radius)
        return False
    
    def resolve_collision(self, other):
        """解决碰撞（弹性碰撞）"""
        # 碰撞法线方向
        normal = (other.pos - self.pos) / np.linalg.norm(other.pos - self.pos)
        
        # 相对速度
        rel_vel = self.vel - other.vel
        
        # 法线方向相对速度
        vel_along_normal = np.dot(rel_vel, normal)
        
        # 不处理分离情况
        if vel_along_normal > 0:
            return
        
        # 恢复系数（完全弹性 = 1）
        e = 1.0
        
        # 冲量
        j = -(1 + e) * vel_along_normal / (1/self.mass + 1/other.mass)
        
        # 应用冲量
        impulse = j * normal
        self.vel -= impulse / self.mass
        other.vel += impulse / other.mass

class PhysicsEngine:
    """物理引擎"""
    def __init__(self, width=800, height=600):
        self.bodies = []
        self.width = width
        self.height = height
        self.gravity = np.array([0, -9.8])
    
    def add_body(self, body):
        self.bodies.append(body)
    
    def step(self, dt):
        """时间步进"""
        # 应用重力
        for body in self.bodies:
            body.apply_force(self.gravity * body.mass, dt)
        
        # 更新位置
        for body in self.bodies:
            body.update(dt)
        
        # 边界检测
        for body in self.bodies:
            if body.pos[1] - body.radius < 0:
                body.pos[1] = body.radius
                body.vel[1] = -body.vel[1] * 0.8  # 反弹（能量损失）
        
        # 碰撞检测与响应
        for i, body1 in enumerate(self.bodies):
            for body2 in self.bodies[i+1:]:
                if body1.check_collision(body2):
                    body1.resolve_collision(body2)
    
    def simulate(self, duration=10, dt=0.01):
        """运行模拟"""
        steps = int(duration / dt)
        trajectories = [[] for _ in self.bodies]
        
        for _ in range(steps):
            self.step(dt)
            for i, body in enumerate(self.bodies):
                trajectories[i].append(body.pos.copy())
        
        return trajectories

# 使用示例
engine = PhysicsEngine()
engine.add_body(RigidBody(pos=[0, 50], vel=[10, 0], mass=1, radius=1))
engine.add_body(RigidBody(pos=[20, 60], vel=[-5, 0], mass=2, radius=1.5))

trajectories = engine.simulate(duration=5)

# 可视化
plt.figure(figsize=(12, 6))
for i, traj in enumerate(trajectories):
    traj = np.array(traj)
    plt.plot(traj[:, 0], traj[:, 1], label=f'物体{i+1}')
plt.xlabel('x (m)')
plt.ylabel('y (m)')
plt.title('2D物理模拟')
plt.legend()
plt.grid()
plt.axis('equal')
plt.show()
```

### 项目2：光线追踪渲染器

```python
class Ray:
    """光线"""
    def __init__(self, origin, direction):
        self.origin = np.array(origin, dtype=float)
        self.direction = np.array(direction, dtype=float)
        self.direction /= np.linalg.norm(self.direction)
    
    def at(self, t):
        """光线上的点"""
        return self.origin + t * self.direction

class Sphere:
    """球体"""
    def __init__(self, center, radius, color, material):
        self.center = np.array(center, dtype=float)
        self.radius = radius
        self.color = np.array(color, dtype=float)
        self.material = material  # {'diffuse': 0.7, 'specular': 0.3, 'shininess': 10}
    
    def intersect(self, ray):
        """光线与球体相交检测"""
        oc = ray.origin - self.center
        a = np.dot(ray.direction, ray.direction)
        b = 2.0 * np.dot(oc, ray.direction)
        c = np.dot(oc, oc) - self.radius**2
        
        discriminant = b**2 - 4*a*c
        
        if discriminant < 0:
            return None
        
        t = (-b - np.sqrt(discriminant)) / (2*a)
        if t < 0:
            t = (-b + np.sqrt(discriminant)) / (2*a)
        
        if t < 0:
            return None
        
        hit_point = ray.at(t)
        normal = (hit_point - self.center) / self.radius
        
        return {'t': t, 'point': hit_point, 'normal': normal, 'object': self}

class RayTracer:
    """光线追踪器"""
    def __init__(self, width=400, height=300):
        self.width = width
        self.height = height
        self.objects = []
        self.lights = []
    
    def add_object(self, obj):
        self.objects.append(obj)
    
    def add_light(self, position, intensity=1.0):
        self.lights.append({'pos': np.array(position), 'intensity': intensity})
    
    def trace_ray(self, ray, depth=0, max_depth=3):
        """追踪光线"""
        if depth > max_depth:
            return np.array([0, 0, 0])
        
        # 找最近的交点
        closest_hit = None
        min_t = float('inf')
        
        for obj in self.objects:
            hit = obj.intersect(ray)
            if hit and hit['t'] < min_t:
                min_t = hit['t']
                closest_hit = hit
        
        if not closest_hit:
            return np.array([0.5, 0.7, 1.0])  # 天空色
        
        # 计算光照
        hit_point = closest_hit['point']
        normal = closest_hit['normal']
        obj = closest_hit['object']
        
        color = np.zeros(3)
        
        for light in self.lights:
            # 光源方向
            light_dir = light['pos'] - hit_point
            light_dist = np.linalg.norm(light_dir)
            light_dir /= light_dist
            
            # 漫反射
            diffuse = max(0, np.dot(normal, light_dir))
            
            # 镜面反射
            reflect_dir = 2 * np.dot(light_dir, normal) * normal - light_dir
            view_dir = -ray.direction
            specular = max(0, np.dot(reflect_dir, view_dir)) ** obj.material['shininess']
            
            # 组合
            color += obj.color * (
                obj.material['diffuse'] * diffuse + 
                obj.material['specular'] * specular
            ) * light['intensity']
        
        return np.clip(color, 0, 1)
    
    def render(self):
        """渲染场景"""
        image = np.zeros((self.height, self.width, 3))
        
        # 相机参数
        camera_pos = np.array([0, 0, 0])
        viewport_height = 2.0
        viewport_width = viewport_height * self.width / self.height
        focal_length = 1.0
        
        for y in range(self.height):
            for x in range(self.width):
                # 计算光线方向
                u = (x / self.width) * 2 - 1
                v = 1 - (y / self.height) * 2
                
                direction = np.array([
                    u * viewport_width / 2,
                    v * viewport_height / 2,
                    -focal_length
                ])
                
                ray = Ray(camera_pos, direction)
                color = self.trace_ray(ray)
                image[y, x] = color
        
        return image

# 创建场景
tracer = RayTracer(width=400, height=300)

# 添加球体
tracer.add_object(Sphere(
    center=[0, 0, -5],
    radius=1,
    color=[1, 0, 0],
    material={'diffuse': 0.7, 'specular': 0.3, 'shininess': 10}
))

tracer.add_object(Sphere(
    center=[2, 0, -6],
    radius=0.7,
    color=[0, 1, 0],
    material={'diffuse': 0.6, 'specular': 0.4, 'shininess': 20}
))

# 添加光源
tracer.add_light(position=[5, 5, 0], intensity=1.0)

# 渲染
image = tracer.render()

# 显示
plt.figure(figsize=(12, 9))
plt.imshow(image)
plt.title('光线追踪渲染')
plt.axis('off')
plt.show()
```

### 项目3：声波模拟器

```python
def simulate_sound_wave(frequency=440, duration=1, sample_rate=44100):
    """模拟声波（A4音符）"""
    t = np.linspace(0, duration, int(sample_rate * duration))
    
    # 基频
    fundamental = np.sin(2 * np.pi * frequency * t)
    
    # 添加谐波（更真实的音色）
    harmonic2 = 0.5 * np.sin(2 * np.pi * 2 * frequency * t)
    harmonic3 = 0.25 * np.sin(2 * np.pi * 3 * frequency * t)
    
    wave = fundamental + harmonic2 + harmonic3
    wave = wave / np.max(np.abs(wave))  # 归一化
    
    # 绘制波形
    plt.figure(figsize=(14, 6))
    
    plt.subplot(2, 1, 1)
    plt.plot(t[:1000], wave[:1000])
    plt.title(f'声波波形 ({frequency} Hz)')
    plt.xlabel('时间 (s)')
    plt.ylabel('振幅')
    plt.grid()
    
    # 频谱分析
    from scipy.fft import fft, fftfreq
    
    fft_vals = fft(wave)
    fft_freq = fftfreq(len(wave), 1/sample_rate)
    
    plt.subplot(2, 1, 2)
    plt.plot(fft_freq[:len(fft_freq)//2], np.abs(fft_vals[:len(fft_vals)//2]))
    plt.title('频谱')
    plt.xlabel('频率 (Hz)')
    plt.ylabel('幅度')
    plt.xlim(0, 2000)
    plt.grid()
    
    plt.tight_layout()
    plt.show()
    
    return wave, t

# 生成A4音符
wave, t = simulate_sound_wave(frequency=440, duration=1)

# 可以用sounddevice播放
# import sounddevice as sd
# sd.play(wave, samplerate=44100)
# sd.wait()
```

### 项目4：电磁场可视化

```python
def visualize_electric_field(charges):
    """
    可视化电场
    
    charges: [(q, x, y), ...] 电荷列表
    """
    # 创建网格
    x = np.linspace(-5, 5, 30)
    y = np.linspace(-5, 5, 30)
    X, Y = np.meshgrid(x, y)
    
    # 初始化电场
    Ex = np.zeros_like(X)
    Ey = np.zeros_like(Y)
    
    k = 9e9  # 库仑常数（简化）
    
    for q, qx, qy in charges:
        # 计算每个电荷的贡献
        dx = X - qx
        dy = Y - qy
        r = np.sqrt(dx**2 + dy**2)
        
        # 避免除零
        r = np.where(r < 0.1, 0.1, r)
        
        Ex += k * q * dx / r**3
        Ey += k * q * dy / r**3
    
    # 绘制
    plt.figure(figsize=(10, 8))
    
    # 电场线
    plt.streamplot(X, Y, Ex, Ey, color=np.sqrt(Ex**2 + Ey**2), 
                  cmap='plasma', density=1.5, linewidth=1)
    
    # 标记电荷
    for q, qx, qy in charges:
        color = 'red' if q > 0 else 'blue'
        plt.plot(qx, qy, 'o', color=color, markersize=15)
        plt.text(qx, qy+0.3, f'{q:+.1f}', ha='center', fontsize=12)
    
    plt.xlabel('x')
    plt.ylabel('y')
    plt.title('电场分布')
    plt.colorbar(label='场强')
    plt.axis('equal')
    plt.grid(alpha=0.3)
    plt.show()

# 示例：偶极子
charges = [
    (1, -1, 0),   # 正电荷
    (-1, 1, 0)    # 负电荷
]

visualize_electric_field(charges)
```

### 项目5：量子隧穿模拟

```python
def quantum_tunneling_simulation():
    """量子隧穿效应模拟"""
    # 参数
    hbar = 1.055e-34
    m = 9.11e-31  # 电子质量
    
    # 空间网格
    x = np.linspace(-10e-9, 10e-9, 1000)
    dx = x[1] - x[0]
    
    # 势垒
    V = np.zeros_like(x)
    barrier_start = 400
    barrier_end = 600
    barrier_height = 1e-18  # J
    V[barrier_start:barrier_end] = barrier_height
    
    # 初始波包（高斯波包）
    k0 = 5e9  # 波数
    x0 = -5e-9
    sigma = 1e-9
    
    psi = np.exp(-(x - x0)**2 / (2*sigma**2)) * np.exp(1j * k0 * x)
    psi = psi / np.sqrt(np.sum(np.abs(psi)**2) * dx)  # 归一化
    
    # 时间演化（简化）
    dt = 1e-17
    steps = 500
    
    plt.figure(figsize=(14, 10))
    
    for i in range(0, steps, 50):
        # 简化的薛定谔方程演化（分步傅里叶法）
        # 这里用简单的近似
        
        # 动能算符（动量空间）
        psi_k = np.fft.fft(psi)
        k = 2 * np.pi * np.fft.fftfreq(len(x), dx)
        psi_k *= np.exp(-1j * hbar * k**2 / (2*m) * dt / 2)
        psi = np.fft.ifft(psi_k)
        
        # 势能算符
        psi *= np.exp(-1j * V / hbar * dt)
        
        # 再次动能
        psi_k = np.fft.fft(psi)
        psi_k *= np.exp(-1j * hbar * k**2 / (2*m) * dt / 2)
        psi = np.fft.ifft(psi_k)
        
        # 归一化
        psi = psi / np.sqrt(np.sum(np.abs(psi)**2) * dx)
    
    # 绘制结果
    plt.subplot(2, 1, 1)
    plt.plot(x*1e9, V/1e-18, 'k-', linewidth=2, label='势垒')
    plt.xlabel('位置 (nm)')
    plt.ylabel('势能 (aJ)')
    plt.legend()
    plt.grid()
    
    plt.subplot(2, 1, 2)
    plt.plot(x*1e9, np.abs(psi)**2, 'b-', linewidth=2)
    plt.fill_between(x*1e9, 0, np.abs(psi)**2, alpha=0.3)
    plt.xlabel('位置 (nm)')
    plt.ylabel('概率密度')
    plt.title('量子隧穿：波函数演化')
    plt.grid()
    
    plt.tight_layout()
    plt.show()
    
    # 计算透射率
    transmitted = np.sum(np.abs(psi[barrier_end:])**2) * dx
    print(f"透射概率: {transmitted*100:.2f}%")

# 运行模拟
quantum_tunneling_simulation()
```

---

## 11. 物理常数速查表