![(ä¹)å®æˆ˜é¡¹ç›®](https://via.placeholder.com/800x200?text=Practice+Projects)

# ç¦»æ•£æ•°å­¦ - (ä¹)å®æˆ˜é¡¹ç›®

é€šè¿‡é¡¹ç›®åº”ç”¨ç¦»æ•£æ•°å­¦çŸ¥è¯†ã€‚

---


### é¡¹ç›®1ï¼šé€»è¾‘è¡¨è¾¾å¼æ±‚å€¼å™¨

```python
class LogicEvaluator:
    """å‘½é¢˜é€»è¾‘æ±‚å€¼å™¨"""
    
    def __init__(self, expression):
        self.expression = expression
    
    def evaluate(self, values):
        """
        æ±‚å€¼é€»è¾‘è¡¨è¾¾å¼
        
        å‚æ•°:
            values: å˜é‡èµ‹å€¼å­—å…¸ {'p': True, 'q': False, ...}
        """
        expr = self.expression
        
        # æ›¿æ¢å˜é‡
        for var, val in values.items():
            expr = expr.replace(var, str(val))
        
        # æ›¿æ¢é€»è¾‘ç¬¦å·
        expr = expr.replace('NOT', ' not ')
        expr = expr.replace('AND', ' and ')
        expr = expr.replace('OR', ' or ')
        expr = expr.replace('â†’', ' <= ')  # pâ†’q ç­‰ä»·äº not p or q
        
        return eval(expr)
    
    def truth_table(self, variables):
        """ç”ŸæˆçœŸå€¼è¡¨"""
        from itertools import product
        
        print(f"{'  '.join(variables)}  |  {self.expression}")
        print("-" * (4 * len(variables) + len(self.expression) + 5))
        
        for values in product([True, False], repeat=len(variables)):
            assignment = dict(zip(variables, values))
            result = self.evaluate(assignment)
            vals_str = '  '.join('T' if v else 'F' for v in values)
            res_str = 'T' if result else 'F'
            print(f"{vals_str}  |  {res_str}")

# ç¤ºä¾‹
logic = LogicEvaluator("(p OR q) AND NOT (p AND q)")
logic.truth_table(['p', 'q'])
```

### é¡¹ç›®2ï¼šå›¾ç®—æ³•å¯è§†åŒ–

```python
import matplotlib.pyplot as plt
import networkx as nx

class GraphVisualizer:
    """å›¾ç®—æ³•å¯è§†åŒ–"""
    
    def __init__(self, graph_dict):
        self.G = nx.Graph(graph_dict)
    
    def visualize_dfs(self, start):
        """å¯è§†åŒ–DFSè¿‡ç¨‹"""
        visited = set()
        path = []
        
        def dfs(node):
            visited.add(node)
            path.append(node)
            for neighbor in self.G[node]:
                if neighbor not in visited:
                    dfs(neighbor)
        
        dfs(start)
        
        # ç»˜åˆ¶
        pos = nx.spring_layout(self.G)
        colors = ['lightgreen' if n in path else 'lightblue' for n in self.G.nodes()]
        
        plt.figure(figsize=(10, 6))
        nx.draw(self.G, pos, node_color=colors, with_labels=True, 
                node_size=800, font_size=16, font_weight='bold')
        plt.title(f"DFSéå†é¡ºåº: {' â†’ '.join(map(str, path))}")
        plt.show()
    
    def visualize_shortest_path(self, start, end):
        """å¯è§†åŒ–æœ€çŸ­è·¯å¾„"""
        try:
            path = nx.shortest_path(self.G, start, end)
            
            pos = nx.spring_layout(self.G)
            
            # è·¯å¾„ä¸Šçš„è¾¹
            path_edges = [(path[i], path[i+1]) for i in range(len(path)-1)]
            
            plt.figure(figsize=(10, 6))
            nx.draw(self.G, pos, with_labels=True, node_size=800, 
                   font_size=16, font_weight='bold', node_color='lightblue')
            nx.draw_networkx_edges(self.G, pos, edgelist=path_edges, 
                                  edge_color='r', width=3)
            plt.title(f"æœ€çŸ­è·¯å¾„ {start} â†’ {end}: {' â†’ '.join(map(str, path))}")
            plt.show()
        except nx.NetworkXNoPath:
            print(f"æ— è·¯å¾„ä» {start} åˆ° {end}")

# ä½¿ç”¨ç¤ºä¾‹
# graph = {1: [2, 3], 2: [1, 4], 3: [1, 4], 4: [2, 3, 5], 5: [4]}
# viz = GraphVisualizer(graph)
# viz.visualize_dfs(1)
# viz.visualize_shortest_path(1, 5)
```

### é¡¹ç›®3ï¼šç»„åˆæ•°å­¦è®¡ç®—å™¨

```python
class CombinatoricsCalculator:
    """ç»„åˆæ•°å­¦è®¡ç®—å™¨"""
    
    @staticmethod
    def factorial(n):
        """é˜¶ä¹˜"""
        if n == 0 or n == 1:
            return 1
        return n * CombinatoricsCalculator.factorial(n - 1)
    
    @staticmethod
    def permutation(n, r):
        """æ’åˆ— P(n, r)"""
        return CombinatoricsCalculator.factorial(n) // CombinatoricsCalculator.factorial(n - r)
    
    @staticmethod
    def combination(n, r):
        """ç»„åˆ C(n, r)"""
        return CombinatoricsCalculator.factorial(n) // (
            CombinatoricsCalculator.factorial(r) * CombinatoricsCalculator.factorial(n - r)
        )
    
    @staticmethod
    def binomial_expansion(a, b, n):
        """äºŒé¡¹å¼å±•å¼€ (a + b)^n"""
        terms = []
        for k in range(n + 1):
            coeff = CombinatoricsCalculator.combination(n, k)
            term = f"{coeff}*{a}^{n-k}*{b}^{k}"
            terms.append(term)
        return " + ".join(terms)
    
    @staticmethod
    def stirling_second(n, k):
        """ç¬¬äºŒç±»Stirlingæ•°ï¼šå°†nä¸ªå…ƒç´ åˆ†æˆkä¸ªéç©ºé›†åˆçš„æ–¹æ³•æ•°"""
        if n == 0 and k == 0:
            return 1
        if n == 0 or k == 0:
            return 0
        if k == 1 or k == n:
            return 1
        
        # é€’æ¨ï¼šS(n,k) = k*S(n-1,k) + S(n-1,k-1)
        return (k * CombinatoricsCalculator.stirling_second(n-1, k) + 
                CombinatoricsCalculator.stirling_second(n-1, k-1))
    
    @staticmethod
    def catalan_number(n):
        """Catalanæ•°ï¼šC_n = C(2n, n) / (n+1)"""
        return CombinatoricsCalculator.combination(2*n, n) // (n + 1)

# ä½¿ç”¨ç¤ºä¾‹
calc = CombinatoricsCalculator()
print(f"P(5, 3) = {calc.permutation(5, 3)}")  # 60
print(f"C(5, 3) = {calc.combination(5, 3)}")  # 10
print(f"(x+y)^3 = {calc.binomial_expansion('x', 'y', 3)}")
print(f"Catalan(4) = {calc.catalan_number(4)}")  # 14ï¼ˆ4ä¸ªèŠ‚ç‚¹çš„äºŒå‰æ ‘ç§æ•°ï¼‰
```

### é¡¹ç›®4ï¼šå…³ç³»åˆ†æå™¨

```python
class RelationAnalyzer:
    """å…³ç³»æ€§è´¨åˆ†æå™¨"""
    
    def __init__(self, relation, universe):
        """
        relation: å…³ç³»é›†åˆ {(a, b), ...}
        universe: å…¨é›†
        """
        self.relation = set(relation)
        self.universe = set(universe)
    
    def is_reflexive(self):
        """åˆ¤æ–­è‡ªåæ€§"""
        for a in self.universe:
            if (a, a) not in self.relation:
                return False
        return True
    
    def is_symmetric(self):
        """åˆ¤æ–­å¯¹ç§°æ€§"""
        for (a, b) in self.relation:
            if (b, a) not in self.relation:
                return False
        return True
    
    def is_transitive(self):
        """åˆ¤æ–­ä¼ é€’æ€§"""
        for (a, b) in self.relation:
            for (c, d) in self.relation:
                if b == c and (a, d) not in self.relation:
                    return False
        return True
    
    def is_equivalence(self):
        """åˆ¤æ–­æ˜¯å¦ä¸ºç­‰ä»·å…³ç³»"""
        return (self.is_reflexive() and 
                self.is_symmetric() and 
                self.is_transitive())
    
    def equivalence_classes(self):
        """æ±‚ç­‰ä»·ç±»ï¼ˆå¦‚æœæ˜¯ç­‰ä»·å…³ç³»ï¼‰"""
        if not self.is_equivalence():
            return None
        
        classes = []
        remaining = set(self.universe)
        
        while remaining:
            element = remaining.pop()
            eq_class = {element}
            
            for (a, b) in self.relation:
                if a == element:
                    eq_class.add(b)
                    remaining.discard(b)
            
            classes.append(eq_class)
        
        return classes

# ç¤ºä¾‹ï¼šæ¨¡3åŒä½™å…³ç³»
universe = range(10)
relation = {(a, b) for a in universe for b in universe if (a - b) % 3 == 0}

analyzer = RelationAnalyzer(relation, universe)
print(f"è‡ªåæ€§: {analyzer.is_reflexive()}")  # True
print(f"å¯¹ç§°æ€§: {analyzer.is_symmetric()}")  # True
print(f"ä¼ é€’æ€§: {analyzer.is_transitive()}")  # True
print(f"ç­‰ä»·å…³ç³»: {analyzer.is_equivalence()}")  # True
print(f"ç­‰ä»·ç±»: {analyzer.equivalence_classes()}")  # [{0, 3, 6, 9}, {1, 4, 7}, {2, 5, 8}]
```

### é¡¹ç›®5ï¼šå¯†ç å­¦åº”ç”¨

```python
class CryptographyTools:
    """ç¦»æ•£æ•°å­¦åœ¨å¯†ç å­¦ä¸­çš„åº”ç”¨"""
    
    @staticmethod
    def caesar_cipher(text, shift):
        """å‡¯æ’’å¯†ç ï¼ˆæ¨¡è¿ç®—ï¼‰"""
        result = ""
        for char in text:
            if char.isalpha():
                base = ord('A') if char.isupper() else ord('a')
                result += chr((ord(char) - base + shift) % 26 + base)
            else:
                result += char
        return result
    
    @staticmethod
    def vigenere_cipher(text, key):
        """ç»´å‰å°¼äºšå¯†ç """
        result = ""
        key_index = 0
        
        for char in text:
            if char.isalpha():
                base = ord('A') if char.isupper() else ord('a')
                shift = ord(key[key_index % len(key)].upper()) - ord('A')
                result += chr((ord(char) - base + shift) % 26 + base)
                key_index += 1
            else:
                result += char
        
        return result
    
    @staticmethod
    def diffie_hellman_demo():
        """Diffie-Hellmanå¯†é’¥äº¤æ¢æ¼”ç¤º"""
        # å…¬å¼€å‚æ•°
        p = 23  # ç´ æ•°
        g = 5   # åŸæ ¹
        
        # Aliceçš„ç§é’¥
        a = 6
        A = mod_exp(g, a, p)  # å…¬é’¥
        
        # Bobçš„ç§é’¥
        b = 15
        B = mod_exp(g, b, p)  # å…¬é’¥
        
        # å…±äº«å¯†é’¥
        shared_key_alice = mod_exp(B, a, p)
        shared_key_bob = mod_exp(A, b, p)
        
        print(f"Aliceå…¬é’¥: {A}")
        print(f"Bobå…¬é’¥: {B}")
        print(f"Aliceè®¡ç®—çš„å…±äº«å¯†é’¥: {shared_key_alice}")
        print(f"Bobè®¡ç®—çš„å…±äº«å¯†é’¥: {shared_key_bob}")
        assert shared_key_alice == shared_key_bob

# ä½¿ç”¨ç¤ºä¾‹
crypto = CryptographyTools()
print(crypto.caesar_cipher("HELLO", 3))  # "KHOOR"
print(crypto.vigenere_cipher("ATTACKATDAWN", "LEMON"))  # "LXFOPVEFRNHR"
crypto.diffie_hellman_demo()
```

---

> **ä¸‹ä¸€æ­¥**ï¼šå°†ç¦»æ•£æ•°å­¦åº”ç”¨åˆ°ç®—æ³•è®¾è®¡ä¸åˆ†æã€ç¼–è¯‘åŸç†ã€äººå·¥æ™ºèƒ½ä¸­ï¼ğŸ¯

