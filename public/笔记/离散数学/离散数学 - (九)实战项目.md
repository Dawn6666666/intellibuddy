![(九)实战项目](https://via.placeholder.com/800x200?text=Practice+Projects)

# 离散数学 - (九)实战项目

通过项目应用离散数学知识。

---


### 项目1：逻辑表达式求值器

```python
class LogicEvaluator:
    """命题逻辑求值器"""
    
    def __init__(self, expression):
        self.expression = expression
    
    def evaluate(self, values):
        """
        求值逻辑表达式
        
        参数:
            values: 变量赋值字典 {'p': True, 'q': False, ...}
        """
        expr = self.expression
        
        # 替换变量
        for var, val in values.items():
            expr = expr.replace(var, str(val))
        
        # 替换逻辑符号
        expr = expr.replace('NOT', ' not ')
        expr = expr.replace('AND', ' and ')
        expr = expr.replace('OR', ' or ')
        expr = expr.replace('→', ' <= ')  # p→q 等价于 not p or q
        
        return eval(expr)
    
    def truth_table(self, variables):
        """生成真值表"""
        from itertools import product
        
        print(f"{'  '.join(variables)}  |  {self.expression}")
        print("-" * (4 * len(variables) + len(self.expression) + 5))
        
        for values in product([True, False], repeat=len(variables)):
            assignment = dict(zip(variables, values))
            result = self.evaluate(assignment)
            vals_str = '  '.join('T' if v else 'F' for v in values)
            res_str = 'T' if result else 'F'
            print(f"{vals_str}  |  {res_str}")

# 示例
logic = LogicEvaluator("(p OR q) AND NOT (p AND q)")
logic.truth_table(['p', 'q'])
```

### 项目2：图算法可视化

```python
import matplotlib.pyplot as plt
import networkx as nx

class GraphVisualizer:
    """图算法可视化"""
    
    def __init__(self, graph_dict):
        self.G = nx.Graph(graph_dict)
    
    def visualize_dfs(self, start):
        """可视化DFS过程"""
        visited = set()
        path = []
        
        def dfs(node):
            visited.add(node)
            path.append(node)
            for neighbor in self.G[node]:
                if neighbor not in visited:
                    dfs(neighbor)
        
        dfs(start)
        
        # 绘制
        pos = nx.spring_layout(self.G)
        colors = ['lightgreen' if n in path else 'lightblue' for n in self.G.nodes()]
        
        plt.figure(figsize=(10, 6))
        nx.draw(self.G, pos, node_color=colors, with_labels=True, 
                node_size=800, font_size=16, font_weight='bold')
        plt.title(f"DFS遍历顺序: {' → '.join(map(str, path))}")
        plt.show()
    
    def visualize_shortest_path(self, start, end):
        """可视化最短路径"""
        try:
            path = nx.shortest_path(self.G, start, end)
            
            pos = nx.spring_layout(self.G)
            
            # 路径上的边
            path_edges = [(path[i], path[i+1]) for i in range(len(path)-1)]
            
            plt.figure(figsize=(10, 6))
            nx.draw(self.G, pos, with_labels=True, node_size=800, 
                   font_size=16, font_weight='bold', node_color='lightblue')
            nx.draw_networkx_edges(self.G, pos, edgelist=path_edges, 
                                  edge_color='r', width=3)
            plt.title(f"最短路径 {start} → {end}: {' → '.join(map(str, path))}")
            plt.show()
        except nx.NetworkXNoPath:
            print(f"无路径从 {start} 到 {end}")

# 使用示例
# graph = {1: [2, 3], 2: [1, 4], 3: [1, 4], 4: [2, 3, 5], 5: [4]}
# viz = GraphVisualizer(graph)
# viz.visualize_dfs(1)
# viz.visualize_shortest_path(1, 5)
```

### 项目3：组合数学计算器

```python
class CombinatoricsCalculator:
    """组合数学计算器"""
    
    @staticmethod
    def factorial(n):
        """阶乘"""
        if n == 0 or n == 1:
            return 1
        return n * CombinatoricsCalculator.factorial(n - 1)
    
    @staticmethod
    def permutation(n, r):
        """排列 P(n, r)"""
        return CombinatoricsCalculator.factorial(n) // CombinatoricsCalculator.factorial(n - r)
    
    @staticmethod
    def combination(n, r):
        """组合 C(n, r)"""
        return CombinatoricsCalculator.factorial(n) // (
            CombinatoricsCalculator.factorial(r) * CombinatoricsCalculator.factorial(n - r)
        )
    
    @staticmethod
    def binomial_expansion(a, b, n):
        """二项式展开 (a + b)^n"""
        terms = []
        for k in range(n + 1):
            coeff = CombinatoricsCalculator.combination(n, k)
            term = f"{coeff}*{a}^{n-k}*{b}^{k}"
            terms.append(term)
        return " + ".join(terms)
    
    @staticmethod
    def stirling_second(n, k):
        """第二类Stirling数：将n个元素分成k个非空集合的方法数"""
        if n == 0 and k == 0:
            return 1
        if n == 0 or k == 0:
            return 0
        if k == 1 or k == n:
            return 1
        
        # 递推：S(n,k) = k*S(n-1,k) + S(n-1,k-1)
        return (k * CombinatoricsCalculator.stirling_second(n-1, k) + 
                CombinatoricsCalculator.stirling_second(n-1, k-1))
    
    @staticmethod
    def catalan_number(n):
        """Catalan数：C_n = C(2n, n) / (n+1)"""
        return CombinatoricsCalculator.combination(2*n, n) // (n + 1)

# 使用示例
calc = CombinatoricsCalculator()
print(f"P(5, 3) = {calc.permutation(5, 3)}")  # 60
print(f"C(5, 3) = {calc.combination(5, 3)}")  # 10
print(f"(x+y)^3 = {calc.binomial_expansion('x', 'y', 3)}")
print(f"Catalan(4) = {calc.catalan_number(4)}")  # 14（4个节点的二叉树种数）
```

### 项目4：关系分析器

```python
class RelationAnalyzer:
    """关系性质分析器"""
    
    def __init__(self, relation, universe):
        """
        relation: 关系集合 {(a, b), ...}
        universe: 全集
        """
        self.relation = set(relation)
        self.universe = set(universe)
    
    def is_reflexive(self):
        """判断自反性"""
        for a in self.universe:
            if (a, a) not in self.relation:
                return False
        return True
    
    def is_symmetric(self):
        """判断对称性"""
        for (a, b) in self.relation:
            if (b, a) not in self.relation:
                return False
        return True
    
    def is_transitive(self):
        """判断传递性"""
        for (a, b) in self.relation:
            for (c, d) in self.relation:
                if b == c and (a, d) not in self.relation:
                    return False
        return True
    
    def is_equivalence(self):
        """判断是否为等价关系"""
        return (self.is_reflexive() and 
                self.is_symmetric() and 
                self.is_transitive())
    
    def equivalence_classes(self):
        """求等价类（如果是等价关系）"""
        if not self.is_equivalence():
            return None
        
        classes = []
        remaining = set(self.universe)
        
        while remaining:
            element = remaining.pop()
            eq_class = {element}
            
            for (a, b) in self.relation:
                if a == element:
                    eq_class.add(b)
                    remaining.discard(b)
            
            classes.append(eq_class)
        
        return classes

# 示例：模3同余关系
universe = range(10)
relation = {(a, b) for a in universe for b in universe if (a - b) % 3 == 0}

analyzer = RelationAnalyzer(relation, universe)
print(f"自反性: {analyzer.is_reflexive()}")  # True
print(f"对称性: {analyzer.is_symmetric()}")  # True
print(f"传递性: {analyzer.is_transitive()}")  # True
print(f"等价关系: {analyzer.is_equivalence()}")  # True
print(f"等价类: {analyzer.equivalence_classes()}")  # [{0, 3, 6, 9}, {1, 4, 7}, {2, 5, 8}]
```

### 项目5：密码学应用

```python
class CryptographyTools:
    """离散数学在密码学中的应用"""
    
    @staticmethod
    def caesar_cipher(text, shift):
        """凯撒密码（模运算）"""
        result = ""
        for char in text:
            if char.isalpha():
                base = ord('A') if char.isupper() else ord('a')
                result += chr((ord(char) - base + shift) % 26 + base)
            else:
                result += char
        return result
    
    @staticmethod
    def vigenere_cipher(text, key):
        """维吉尼亚密码"""
        result = ""
        key_index = 0
        
        for char in text:
            if char.isalpha():
                base = ord('A') if char.isupper() else ord('a')
                shift = ord(key[key_index % len(key)].upper()) - ord('A')
                result += chr((ord(char) - base + shift) % 26 + base)
                key_index += 1
            else:
                result += char
        
        return result
    
    @staticmethod
    def diffie_hellman_demo():
        """Diffie-Hellman密钥交换演示"""
        # 公开参数
        p = 23  # 素数
        g = 5   # 原根
        
        # Alice的私钥
        a = 6
        A = mod_exp(g, a, p)  # 公钥
        
        # Bob的私钥
        b = 15
        B = mod_exp(g, b, p)  # 公钥
        
        # 共享密钥
        shared_key_alice = mod_exp(B, a, p)
        shared_key_bob = mod_exp(A, b, p)
        
        print(f"Alice公钥: {A}")
        print(f"Bob公钥: {B}")
        print(f"Alice计算的共享密钥: {shared_key_alice}")
        print(f"Bob计算的共享密钥: {shared_key_bob}")
        assert shared_key_alice == shared_key_bob

# 使用示例
crypto = CryptographyTools()
print(crypto.caesar_cipher("HELLO", 3))  # "KHOOR"
print(crypto.vigenere_cipher("ATTACKATDAWN", "LEMON"))  # "LXFOPVEFRNHR"
crypto.diffie_hellman_demo()
```

---

> **下一步**：将离散数学应用到算法设计与分析、编译原理、人工智能中！🎯

