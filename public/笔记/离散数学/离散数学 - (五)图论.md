![(五)图论](https://via.placeholder.com/800x200?text=Graph+Theory)

# 离散数学 - (五)图论

掌握图的基本概念和算法。

---


### 5.1 图的基本概念

**定义**：图 $G = (V, E)$，其中：
- $V$：顶点集合
- $E$：边集合

**分类：**

| 类型 | 定义 | 示例 |
|------|------|------|
| 无向图 | 边无方向 | 社交网络 |
| 有向图 | 边有方向 | 网页链接 |
| 加权图 | 边有权值 | 路网 |
| 简单图 | 无重边、无自环 | 大多数图 |

**术语：**

- **度**（Degree）：与顶点相连的边数
- **路径**（Path）：顶点序列
- **回路**（Cycle）：起点和终点相同的路径
- **连通**（Connected）：任意两点间存在路径

**握手定理**：

$$
\sum_{v \in V} \deg(v) = 2|E|
$$

（所有顶点的度数和等于边数的2倍）

### 5.2 图的表示

**1. 邻接矩阵**

$$
A[i][j] = \begin{cases}
1 & \text{if } (i, j) \in E \\
0 & \text{otherwise}
\end{cases}
$$

**示例：**

图：$V = \{1, 2, 3\}$，$E = \{(1,2), (2,3)\}$

$$
A = \begin{bmatrix}
0 & 1 & 0 \\
1 & 0 & 1 \\
0 & 1 & 0
\end{bmatrix}
$$

**2. 邻接表**

```python
graph = {
    1: [2],
    2: [1, 3],
    3: [2]
}
```

**对比：**

| 方法 | 空间复杂度 | 判断边存在 | 遍历邻居 |
|------|-----------|-----------|---------|
| 邻接矩阵 | $O(V^2)$ | $O(1)$ | $O(V)$ |
| 邻接表 | $O(V+E)$ | $O(\deg(v))$ | $O(\deg(v))$ |

### 5.3 图的遍历

**深度优先搜索（DFS）**：

```python
def dfs(graph, start, visited=None):
    if visited is None:
        visited = set()
    visited.add(start)
    print(start)
    
    for neighbor in graph[start]:
        if neighbor not in visited:
            dfs(graph, neighbor, visited)
```

**广度优先搜索（BFS）**：

```python
from collections import deque

def bfs(graph, start):
    visited = set([start])
    queue = deque([start])
    
    while queue:
        vertex = queue.popleft()
        print(vertex)
        
        for neighbor in graph[vertex]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
```

### 5.4 最短路径

**Dijkstra算法**（单源最短路径）：

```python
import heapq

def dijkstra(graph, start):
    distances = {node: float('inf') for node in graph}
    distances[start] = 0
    pq = [(0, start)]
    
    while pq:
        current_dist, current_node = heapq.heappop(pq)
        
        if current_dist > distances[current_node]:
            continue
        
        for neighbor, weight in graph[current_node].items():
            distance = current_dist + weight
            
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(pq, (distance, neighbor))
    
    return distances
```

**时间复杂度**：$O((V + E) \log V)$（使用优先队列）

### 5.5 最小生成树

**Kruskal算法**（贪心 + 并查集）：

```python
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
    
    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def union(self, x, y):
        px, py = self.find(x), self.find(y)
        if px != py:
            self.parent[px] = py
            return True
        return False

def kruskal(n, edges):
    """
    n: 顶点数
    edges: [(weight, u, v), ...]
    """
    edges.sort()  # 按权值排序
    uf = UnionFind(n)
    mst = []
    total_weight = 0
    
    for weight, u, v in edges:
        if uf.union(u, v):
            mst.append((u, v, weight))
            total_weight += weight
    
    return mst, total_weight
```

**时间复杂度**：$O(E \log E)$

---

## 6. 递归与递推