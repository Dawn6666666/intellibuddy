# 数据结构与算法 - (二)线性结构

掌握数组、链表、栈、队列等线性数据结构。

---

## 2. 线性结构

### 2.1 数组

#### 动态数组实现

```python
class DynamicArray:
    def __init__(self):
        self._capacity = 1
        self._size = 0
        self._data = [None] * self._capacity
    
    def append(self, item):
        if self._size == self._capacity:
            self._resize(2 * self._capacity)  # 扩容
        self._data[self._size] = item
        self._size += 1
    
    def _resize(self, new_capacity):
        new_data = [None] * new_capacity
        for i in range(self._size):
            new_data[i] = self._data[i]
        self._data = new_data
        self._capacity = new_capacity
    
    def __getitem__(self, index):
        if not 0 <= index < self._size:
            raise IndexError("Index out of range")
        return self._data[index]
```

**均摊分析：**
- 单次 `append`：O(1)（大部分情况）
- 扩容时：O(n)
- **均摊复杂度**：O(1)

#### 双指针技巧

**示例：两数之和（有序数组）**

```python
def two_sum(arr, target):
    """O(n) 时间，O(1) 空间"""
    left, right = 0, len(arr) - 1
    while left < right:
        current_sum = arr[left] + arr[right]
        if current_sum == target:
            return [left, right]
        elif current_sum < target:
            left += 1
        else:
            right -= 1
    return []
```

#### 滑动窗口

**示例：最长无重复子串**

```python
def length_of_longest_substring(s):
    """滑动窗口 O(n)"""
    char_set = set()
    left = 0
    max_len = 0
    
    for right in range(len(s)):
        while s[right] in char_set:
            char_set.remove(s[left])
            left += 1
        char_set.add(s[right])
        max_len = max(max_len, right - left + 1)
    
    return max_len
```

### 2.2 链表

#### 单链表实现

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class LinkedList:
    def __init__(self):
        self.head = None
    
    def append(self, val):
        """在尾部添加节点"""
        if not self.head:
            self.head = ListNode(val)
            return
        
        current = self.head
        while current.next:
            current = current.next
        current.next = ListNode(val)
    
    def insert(self, index, val):
        """在指定位置插入"""
        if index == 0:
            self.head = ListNode(val, self.head)
            return
        
        current = self.head
        for _ in range(index - 1):
            if not current:
                raise IndexError("Index out of range")
            current = current.next
        current.next = ListNode(val, current.next)
    
    def delete(self, val):
        """删除第一个值为val的节点"""
        if not self.head:
            return
        
        if self.head.val == val:
            self.head = self.head.next
            return
        
        current = self.head
        while current.next and current.next.val != val:
            current = current.next
        
        if current.next:
            current.next = current.next.next
```

#### 反转链表

```python
def reverse_list(head):
    """迭代法 O(n)"""
    prev = None
    current = head
    
    while current:
        next_node = current.next
        current.next = prev
        prev = current
        current = next_node
    
    return prev

def reverse_list_recursive(head):
    """递归法"""
    if not head or not head.next:
        return head
    
    new_head = reverse_list_recursive(head.next)
    head.next.next = head
    head.next = None
    return new_head
```

#### 快慢指针

**检测环：**

```python
def has_cycle(head):
    """Floyd判圈算法"""
    slow = fast = head
    
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
    
    return False

def detect_cycle(head):
    """找到环的起点"""
    slow = fast = head
    
    # 找到相遇点
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            break
    else:
        return None
    
    # 从头和相遇点同时走，再次相遇即为起点
    slow = head
    while slow != fast:
        slow = slow.next
        fast = fast.next
    
    return slow
```

### 2.3 栈

#### 栈的实现

```python
class Stack:
    def __init__(self):
        self._items = []
    
    def push(self, item):
        self._items.append(item)
    
    def pop(self):
        if self.is_empty():
            raise IndexError("Pop from empty stack")
        return self._items.pop()
    
    def peek(self):
        if self.is_empty():
            raise IndexError("Peek from empty stack")
        return self._items[-1]
    
    def is_empty(self):
        return len(self._items) == 0
    
    def size(self):
        return len(self._items)
```

#### 应用：表达式求值

**中缀转后缀（调度场算法）：**

```python
def infix_to_postfix(expression):
    """中缀转后缀"""
    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}
    stack = []
    output = []
    
    for char in expression:
        if char.isalnum():
            output.append(char)
        elif char == '(':
            stack.append(char)
        elif char == ')':
            while stack and stack[-1] != '(':
                output.append(stack.pop())
            stack.pop()  # 弹出 '('
        else:  # 运算符
            while (stack and stack[-1] != '(' and
                   precedence.get(stack[-1], 0) >= precedence[char]):
                output.append(stack.pop())
            stack.append(char)
    
    while stack:
        output.append(stack.pop())
    
    return ''.join(output)

def evaluate_postfix(expression):
    """计算后缀表达式"""
    stack = []
    
    for char in expression:
        if char.isdigit():
            stack.append(int(char))
        else:
            b = stack.pop()
            a = stack.pop()
            if char == '+':
                stack.append(a + b)
            elif char == '-':
                stack.append(a - b)
            elif char == '*':
                stack.append(a * b)
            elif char == '/':
                stack.append(a // b)
    
    return stack[0]
```

#### 单调栈

**下一个更大元素：**

```python
def next_greater_element(nums):
    """单调栈 O(n)"""
    stack = []
    result = [-1] * len(nums)
    
    for i in range(len(nums) - 1, -1, -1):
        while stack and stack[-1] <= nums[i]:
            stack.pop()
        
        if stack:
            result[i] = stack[-1]
        
        stack.append(nums[i])
    
    return result

# 示例
nums = [2, 1, 2, 4, 3]
print(next_greater_element(nums))  # [4, 2, 4, -1, -1]
```

### 2.4 队列

#### 循环队列实现

```python
class CircularQueue:
    def __init__(self, k):
        self.size = k
        self.queue = [None] * k
        self.head = -1
        self.tail = -1
    
    def enqueue(self, value):
        if self.is_full():
            return False
        
        if self.is_empty():
            self.head = 0
        
        self.tail = (self.tail + 1) % self.size
        self.queue[self.tail] = value
        return True
    
    def dequeue(self):
        if self.is_empty():
            return False
        
        if self.head == self.tail:
            self.head = -1
            self.tail = -1
        else:
            self.head = (self.head + 1) % self.size
        
        return True
    
    def is_empty(self):
        return self.head == -1
    
    def is_full(self):
        return (self.tail + 1) % self.size == self.head
```

#### 优先队列（堆）

```python
import heapq

class PriorityQueue:
    def __init__(self):
        self._queue = []
        self._index = 0
    
    def push(self, item, priority):
        heapq.heappush(self._queue, (priority, self._index, item))
        self._index += 1
    
    def pop(self):
        return heapq.heappop(self._queue)[-1]
    
    def is_empty(self):
        return len(self._queue) == 0

# 使用
pq = PriorityQueue()
pq.push("task1", 3)
pq.push("task2", 1)
pq.push("task3", 2)

while not pq.is_empty():
    print(pq.pop())  # task2, task3, task1
```

---

**本章完**
