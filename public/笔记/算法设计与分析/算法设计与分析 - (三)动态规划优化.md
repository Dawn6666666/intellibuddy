# 算法设计与分析 - (三)动态规划优化

学习动态规划优化技巧。

---

## 3. 动态规划优化

### 3.1 单调队列优化

**问题：**滑动窗口最大值

```python
from collections import deque

def sliding_window_maximum(nums, k):
    """
    O(n)单调队列优化
    """
    dq = deque()  # 单调递减队列（存索引）
    result = []
    
    for i in range(len(nums)):
        # 移除超出窗口的元素
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        
        # 维护单调性
        while dq and nums[dq[-1]] < nums[i]:
            dq.pop()
        
        dq.append(i)
        
        # 窗口形成后记录结果
        if i >= k - 1:
            result.append(nums[dq[0]])
    
    return result

nums = [1, 3, -1, -3, 5, 3, 6, 7]
k = 3
print(sliding_window_maximum(nums, k))  # [3, 3, 5, 5, 6, 7]
```

### 3.2 斜率优化DP

**问题：**任务分配（凸优化）

```python
def convex_hull_trick(tasks):
    """
    斜率优化DP（凸包技巧）
    问题：将n个任务分配到若干批次，最小化代价
    """
    n = len(tasks)
    dp = [float('inf')] * n
    dp[0] = 0
    
    # 维护下凸包
    hull = []
    
    def slope(i, j):
        """计算斜率"""
        return (dp[j] - dp[i]) / (tasks[j] - tasks[i])
    
    for i in range(1, n):
        # 添加新线段到凸包
        while len(hull) >= 2 and slope(hull[-2], hull[-1]) >= slope(hull[-1], i):
            hull.pop()
        hull.append(i)
        
        # 查询最优点
        dp[i] = min(dp[j] + cost(j, i) for j in hull)
    
    return dp[n-1]

def cost(i, j):
    """代价函数"""
    return (j - i) ** 2
```

### 3.3 状态压缩DP

**问题：**旅行商问题（TSP）

```python
def tsp_dp(dist):
    """
    状态压缩DP解TSP
    dist: 距离矩阵
    """
    n = len(dist)
    INF = float('inf')
    
    # dp[mask][i]: 访问状态为mask，当前在i的最短路径
    dp = [[INF] * n for _ in range(1 << n)]
    dp[1][0] = 0  # 从0出发
    
    for mask in range(1 << n):
        for u in range(n):
            if not (mask & (1 << u)):
                continue
            
            for v in range(n):
                if mask & (1 << v):
                    continue
                
                new_mask = mask | (1 << v)
                dp[new_mask][v] = min(dp[new_mask][v], 
                                      dp[mask][u] + dist[u][v])
    
    # 返回起点
    ans = min(dp[(1 << n) - 1][i] + dist[i][0] for i in range(1, n))
    return ans

# 示例
dist = [
    [0, 10, 15, 20],
    [10, 0, 35, 25],
    [15, 35, 0, 30],
    [20, 25, 30, 0]
]

print(f"最短路径: {tsp_dp(dist)}")  # 80
```

---

**本章完**
