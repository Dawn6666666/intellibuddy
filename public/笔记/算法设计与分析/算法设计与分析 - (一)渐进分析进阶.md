# 算法设计与分析 - (一)渐进分析进阶

深入理解算法复杂度分析。

---

## 1. 渐进分析进阶

### 1.1 渐进符号族

| 符号 | 定义 | 含义 |
|------|------|------|
| $O$ | $f(n) = O(g(n))$ | 上界（≤） |
| $\Omega$ | $f(n) = \Omega(g(n))$ | 下界（≥） |
| $\Theta$ | $f(n) = \Theta(g(n))$ | 紧界（=） |
| $o$ | $f(n) = o(g(n))$ | 严格上界（<） |
| $\omega$ | $f(n) = \omega(g(n))$ | 严格下界（>） |

**示例：**

$$
3n^2 + 2n + 1 = \Theta(n^2)
$$

```python
# 验证渐进关系
import numpy as np
import matplotlib.pyplot as plt

def plot_asymptotic():
    n = np.arange(1, 100)
    
    f = 3*n**2 + 2*n + 1
    g_upper = 4*n**2  # O(n²)的上界常数
    g_lower = 2*n**2  # Ω(n²)的下界常数
    
    plt.plot(n, f, label='f(n) = 3n² + 2n + 1')
    plt.plot(n, g_upper, '--', label='4n² (上界)')
    plt.plot(n, g_lower, '--', label='2n² (下界)')
    plt.xlabel('n')
    plt.ylabel('运行时间')
    plt.title('渐进符号可视化')
    plt.legend()
    plt.grid()
    plt.show()

plot_asymptotic()
```

### 1.2 主定理（Master Theorem）

**形式：**$T(n) = aT(n/b) + f(n)$

**判别：**

1. 若 $f(n) = O(n^{\log_b a - \epsilon})$ → $T(n) = \Theta(n^{\log_b a})$
2. 若 $f(n) = \Theta(n^{\log_b a})$ → $T(n) = \Theta(n^{\log_b a} \log n)$
3. 若 $f(n) = \Omega(n^{\log_b a + \epsilon})$ → $T(n) = \Theta(f(n))$

**示例：**

```python
def master_theorem_solver(a, b, f_complexity):
    """
    主定理求解器
    a: 子问题个数
    b: 规模缩减因子
    f_complexity: f(n)的复杂度（如 "n", "n^2", "nlogn"）
    """
    import math
    
    log_b_a = math.log(a) / math.log(b)
    print(f"递推式: T(n) = {a}T(n/{b}) + {f_complexity}")
    print(f"log_{b}({a}) = {log_b_a:.2f}")
    
    # 简化分析
    if "n^2" in f_complexity and log_b_a < 2:
        print(f"情况3: T(n) = Θ({f_complexity})")
    elif "nlogn" in f_complexity and abs(log_b_a - 1) < 0.01:
        print(f"情况2: T(n) = Θ(n log² n)")
    elif log_b_a > 1:
        print(f"情况1: T(n) = Θ(n^{log_b_a:.2f})")

# 归并排序
master_theorem_solver(2, 2, "n")  # T(n) = 2T(n/2) + n

# Strassen矩阵乘法
master_theorem_solver(7, 2, "n^2")  # T(n) = 7T(n/2) + n²
```

---

**本章完**
