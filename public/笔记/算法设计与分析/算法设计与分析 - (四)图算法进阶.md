# 算法设计与分析 - (四)图算法进阶

深入研究图论算法。

---

## 4. 图算法进阶

### 4.1 强连通分量（Tarjan算法）

```python
def tarjan_scc(graph):
    """
    Tarjan算法求强连通分量
    """
    n = len(graph)
    dfn = [-1] * n  # DFS序号
    low = [-1] * n  # 能到达的最小dfn
    in_stack = [False] * n
    stack = []
    scc = []
    index = [0]  # 时间戳
    
    def dfs(u):
        dfn[u] = low[u] = index[0]
        index[0] += 1
        stack.append(u)
        in_stack[u] = True
        
        for v in graph[u]:
            if dfn[v] == -1:
                dfs(v)
                low[u] = min(low[u], low[v])
            elif in_stack[v]:
                low[u] = min(low[u], dfn[v])
        
        # u是SCC的根
        if dfn[u] == low[u]:
            component = []
            while True:
                v = stack.pop()
                in_stack[v] = False
                component.append(v)
                if v == u:
                    break
            scc.append(component)
    
    for i in range(n):
        if dfn[i] == -1:
            dfs(i)
    
    return scc

# 示例图
graph = [
    [1],      # 0 → 1
    [2],      # 1 → 2
    [0, 3],   # 2 → 0, 3
    [4],      # 3 → 4
    [5],      # 4 → 5
    [3]       # 5 → 3
]

sccs = tarjan_scc(graph)
print(f"强连通分量: {sccs}")
```

### 4.2 网络流（Dinic算法）

```python
from collections import deque

class Dinic:
    def __init__(self, n):
        self.n = n
        self.graph = [[] for _ in range(n)]
    
    def add_edge(self, u, v, cap):
        """添加边"""
        self.graph[u].append([v, cap, len(self.graph[v])])
        self.graph[v].append([u, 0, len(self.graph[u]) - 1])
    
    def bfs(self, s, t):
        """BFS分层"""
        level = [-1] * self.n
        level[s] = 0
        queue = deque([s])
        
        while queue:
            u = queue.popleft()
            for v, cap, _ in self.graph[u]:
                if cap > 0 and level[v] == -1:
                    level[v] = level[u] + 1
                    queue.append(v)
        
        return level[t] != -1, level
    
    def dfs(self, u, t, flow, level, iter):
        """DFS增广"""
        if u == t:
            return flow
        
        for i in range(iter[u], len(self.graph[u])):
            v, cap, rev = self.graph[u][i]
            if cap > 0 and level[u] < level[v]:
                d = self.dfs(v, t, min(flow, cap), level, iter)
                if d > 0:
                    self.graph[u][i][1] -= d
                    self.graph[v][rev][1] += d
                    return d
            iter[u] += 1
        
        return 0
    
    def max_flow(self, s, t):
        """最大流"""
        flow = 0
        
        while True:
            reachable, level = self.bfs(s, t)
            if not reachable:
                return flow
            
            iter = [0] * self.n
            while True:
                f = self.dfs(s, t, float('inf'), level, iter)
                if f == 0:
                    break
                flow += f

# 示例
dinic = Dinic(6)
dinic.add_edge(0, 1, 16)
dinic.add_edge(0, 2, 13)
dinic.add_edge(1, 3, 12)
dinic.add_edge(2, 4, 14)
dinic.add_edge(3, 5, 20)
dinic.add_edge(4, 5, 4)

print(f"最大流: {dinic.max_flow(0, 5)}")
```

---

**本章完**
