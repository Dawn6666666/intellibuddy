# 算法设计与分析 - (五)字符串算法

掌握字符串处理算法。

---

## 5. 字符串算法

### 5.1 KMP算法

```python
def kmp_search(text, pattern):
    """KMP字符串匹配"""
    # 构建部分匹配表
    def build_lps(p):
        lps = [0] * len(p)
        j = 0
        for i in range(1, len(p)):
            while j > 0 and p[i] != p[j]:
                j = lps[j-1]
            if p[i] == p[j]:
                j += 1
            lps[i] = j
        return lps
    
    lps = build_lps(pattern)
    matches = []
    j = 0
    
    for i in range(len(text)):
        while j > 0 and text[i] != pattern[j]:
            j = lps[j-1]
        
        if text[i] == pattern[j]:
            j += 1
        
        if j == len(pattern):
            matches.append(i - j + 1)
            j = lps[j-1]
    
    return matches

text = "ABABDABACDABABCABAB"
pattern = "ABABCABAB"
print(kmp_search(text, pattern))  # [10]
```

### 5.2 后缀数组

```python
def suffix_array(s):
    """
    O(n log n) 后缀数组构建
    """
    n = len(s)
    sa = list(range(n))
    rank = [ord(c) for c in s]
    k = 1
    
    while k < n:
        # 按(rank[i], rank[i+k])排序
        sa.sort(key=lambda i: (rank[i], rank[i+k] if i+k < n else -1))
        
        # 更新rank
        new_rank = [0] * n
        for i in range(1, n):
            prev = (rank[sa[i-1]], rank[sa[i-1]+k] if sa[i-1]+k < n else -1)
            curr = (rank[sa[i]], rank[sa[i]+k] if sa[i]+k < n else -1)
            new_rank[sa[i]] = new_rank[sa[i-1]] + (prev != curr)
        
        rank = new_rank
        k *= 2
    
    return sa

s = "banana"
sa = suffix_array(s)
print("后缀数组:", sa)
for i in sa:
    print(f"{i}: {s[i:]}")
```

---

**本章完**
