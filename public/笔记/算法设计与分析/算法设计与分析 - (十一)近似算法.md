# 算法设计与分析 - (十一)近似算法

学习NP难问题的近似解法。

---

## 11. 近似算法

### 11.1 贪心近似

**顶点覆盖2-近似算法**

```python
def vertex_cover_approx(edges):
    """
    顶点覆盖的2-近似算法
    贪心策略：每次选择一条边的两个端点
    """
    cover = set()
    uncovered = set(edges)
    
    while uncovered:
        # 选择任意一条未覆盖边
        u, v = uncovered.pop()
        cover.add(u)
        cover.add(v)
        
        # 移除所有被覆盖的边
        uncovered = {(a, b) for a, b in uncovered 
                     if a not in {u, v} and b not in {u, v}}
    
    return cover

# 示例
edges = [(0, 1), (0, 2), (1, 2), (1, 3), (2, 3)]
cover = vertex_cover_approx(edges)
print(f"顶点覆盖: {cover}")
```

**TSP 2-近似算法（MST + 欧拉回路）**

```python
def tsp_2_approximation(dist):
    """
    TSP的2-近似算法
    1. 求最小生成树
    2. DFS遍历MST得到哈密顿回路
    """
    n = len(dist)
    
    # 1. Prim算法求MST
    visited = [False] * n
    mst_edges = []
    visited[0] = True
    
    import heapq
    pq = [(dist[0][j], 0, j) for j in range(1, n)]
    heapq.heapify(pq)
    
    while pq:
        w, u, v = heapq.heappop(pq)
        if visited[v]:
            continue
        
        visited[v] = True
        mst_edges.append((u, v))
        
        for j in range(n):
            if not visited[j]:
                heapq.heappush(pq, (dist[v][j], v, j))
    
    # 2. 构建MST邻接表
    mst_adj = [[] for _ in range(n)]
    for u, v in mst_edges:
        mst_adj[u].append(v)
        mst_adj[v].append(u)
    
    # 3. DFS遍历
    path = []
    def dfs(u, parent):
        path.append(u)
        for v in mst_adj[u]:
            if v != parent:
                dfs(v, u)
    
    dfs(0, -1)
    path.append(0)  # 回到起点
    
    # 4. 计算路径长度
    total = sum(dist[path[i]][path[i+1]] for i in range(len(path)-1))
    
    return path, total

# 示例
dist = [
    [0, 10, 15, 20],
    [10, 0, 35, 25],
    [15, 35, 0, 30],
    [20, 25, 30, 0]
]
path, length = tsp_2_approximation(dist)
print(f"近似路径: {path}")
print(f"路径长度: {length}")
```

---

**本章完**
