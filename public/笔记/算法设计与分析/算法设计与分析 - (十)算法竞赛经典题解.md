# 算法设计与分析 - (十)算法竞赛经典题解

解析竞赛级别问题。

---

## 10. 算法竞赛经典题解

### 10.1 背包问题集合

**多重背包（二进制优化）**

```python
def multi_knapsack(weights, values, counts, capacity):
    """
    多重背包问题（二进制优化）
    每种物品有限个
    """
    # 二进制拆分
    new_weights = []
    new_values = []
    
    for w, v, c in zip(weights, values, counts):
        k = 1
        while k <= c:
            new_weights.append(k * w)
            new_values.append(k * v)
            c -= k
            k *= 2
        if c > 0:
            new_weights.append(c * w)
            new_values.append(c * v)
    
    # 01背包
    dp = [0] * (capacity + 1)
    for w, v in zip(new_weights, new_values):
        for j in range(capacity, w - 1, -1):
            dp[j] = max(dp[j], dp[j - w] + v)
    
    return dp[capacity]

# 示例
weights = [2, 3, 4]
values = [3, 4, 5]
counts = [2, 3, 1]  # 每种物品数量
capacity = 10

max_value = multi_knapsack(weights, values, counts, capacity)
print(f"最大价值: {max_value}")
```

**分组背包**

```python
def group_knapsack(groups, capacity):
    """
    分组背包：每组最多选一个物品
    groups: [[(w1,v1), (w2,v2)], ...]
    """
    dp = [0] * (capacity + 1)
    
    for group in groups:
        for j in range(capacity, -1, -1):
            for w, v in group:
                if j >= w:
                    dp[j] = max(dp[j], dp[j - w] + v)
    
    return dp[capacity]

# 示例
groups = [
    [(2, 3), (3, 4)],      # 组1
    [(4, 5), (5, 6)],      # 组2
    [(1, 2), (2, 3), (3, 4)]  # 组3
]
capacity = 8

max_value = group_knapsack(groups, capacity)
print(f"最大价值: {max_value}")
```

### 10.2 区间DP

**矩阵链乘法**

```python
def matrix_chain_order(dimensions):
    """
    矩阵链乘法最优化
    dimensions: [p0, p1, p2, ..., pn]
    矩阵Ai的维度为 p[i-1] × p[i]
    """
    n = len(dimensions) - 1
    m = [[0] * n for _ in range(n)]  # 最少乘法次数
    s = [[0] * n for _ in range(n)]  # 分割点
    
    # 区间DP
    for length in range(2, n + 1):  # 链长度
        for i in range(n - length + 1):
            j = i + length - 1
            m[i][j] = float('inf')
            
            for k in range(i, j):
                cost = (m[i][k] + m[k+1][j] + 
                        dimensions[i] * dimensions[k+1] * dimensions[j+1])
                if cost < m[i][j]:
                    m[i][j] = cost
                    s[i][j] = k
    
    def print_optimal(i, j):
        """打印最优括号化"""
        if i == j:
            return f"A{i}"
        else:
            return f"({print_optimal(i, s[i][j])} x {print_optimal(s[i][j]+1, j)})"
    
    print(f"最少乘法次数: {m[0][n-1]}")
    print(f"最优括号化: {print_optimal(0, n-1)}")
    
    return m[0][n-1]

# 示例：4个矩阵
# A1: 30×35, A2: 35×15, A3: 15×5, A4: 5×10
dimensions = [30, 35, 15, 5, 10]
matrix_chain_order(dimensions)
```

**戳气球**

```python
def max_coins(nums):
    """
    LeetCode 312: 戳气球
    区间DP经典题
    """
    nums = [1] + nums + [1]
    n = len(nums)
    dp = [[0] * n for _ in range(n)]
    
    # 区间长度从小到大
    for length in range(3, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            for k in range(i + 1, j):
                # k是最后戳破的气球
                dp[i][j] = max(dp[i][j],
                              dp[i][k] + dp[k][j] + 
                              nums[i] * nums[k] * nums[j])
    
    return dp[0][n-1]

# 示例
nums = [3, 1, 5, 8]
print(f"最大硬币数: {max_coins(nums)}")  # 167
```

### 10.3 树形DP

**树的最大独立集**

```python
def tree_max_independent_set(tree, root=0):
    """
    树的最大独立集
    tree: 邻接表
    """
    n = len(tree)
    dp = [[0, 0] for _ in range(n)]  # [不选, 选]
    visited = [False] * n
    
    def dfs(u, parent):
        visited[u] = True
        dp[u][0] = 0  # 不选u
        dp[u][1] = 1  # 选u
        
        for v in tree[u]:
            if v == parent or visited[v]:
                continue
            dfs(v, u)
            dp[u][0] += max(dp[v][0], dp[v][1])
            dp[u][1] += dp[v][0]  # 选u则不能选子节点
    
    dfs(root, -1)
    return max(dp[root][0], dp[root][1])

# 示例
tree = [
    [1, 2],     # 0
    [0, 3, 4],  # 1
    [0, 5],     # 2
    [1],        # 3
    [1],        # 4
    [2]         # 5
]
print(f"最大独立集大小: {tree_max_independent_set(tree)}")
```

**树的直径**

```python
def tree_diameter(tree):
    """
    树的直径（最长路径）
    """
    n = len(tree)
    diameter = [0]
    
    def dfs(u, parent):
        max1 = max2 = 0  # 最长和次长路径
        
        for v in tree[u]:
            if v == parent:
                continue
            length = dfs(v, u)
            if length > max1:
                max2 = max1
                max1 = length
            elif length > max2:
                max2 = length
        
        # 更新直径
        diameter[0] = max(diameter[0], max1 + max2)
        
        return max1 + 1
    
    dfs(0, -1)
    return diameter[0]

# 示例
tree = [
    [1, 2],
    [0, 3, 4],
    [0],
    [1],
    [1, 5, 6],
    [4],
    [4]
]
print(f"树的直径: {tree_diameter(tree)}")
```

---

**本章完**
