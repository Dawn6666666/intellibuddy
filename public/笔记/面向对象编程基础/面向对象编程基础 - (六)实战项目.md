![(六)实战项目](https://via.placeholder.com/800x200?text=Practice+Projects)

# 面向对象编程基础 - (六)实战项目

通过大型项目巩固OOP知识。

---


### 项目1：图书管理系统

**需求分析：**
- 图书增删改查
- 借阅管理
- 用户管理

**类设计：**

```python
from datetime import datetime, timedelta

class Book:
    def __init__(self, isbn, title, author):
        self.isbn = isbn
        self.title = title
        self.author = author
        self.is_available = True

class User:
    def __init__(self, user_id, name):
        self.user_id = user_id
        self.name = name
        self.borrowed_books = []

class Library:
    def __init__(self):
        self.books = {}
        self.users = {}
        self.loans = []
    
    def add_book(self, book):
        self.books[book.isbn] = book
    
    def register_user(self, user):
        self.users[user.user_id] = user
    
    def borrow_book(self, user_id, isbn):
        if isbn in self.books and self.books[isbn].is_available:
            book = self.books[isbn]
            user = self.users[user_id]
            
            book.is_available = False
            user.borrowed_books.append(isbn)
            
            loan = {
                'user_id': user_id,
                'isbn': isbn,
                'borrow_date': datetime.now(),
                'return_date': None
            }
            self.loans.append(loan)
            return True
        return False
    
    def return_book(self, user_id, isbn):
        book = self.books[isbn]
        user = self.users[user_id]
        
        book.is_available = True
        user.borrowed_books.remove(isbn)
        
        for loan in self.loans:
            if loan['user_id'] == user_id and loan['isbn'] == isbn:
                loan['return_date'] = datetime.now()
                break
        return True

# 使用
library = Library()
book1 = Book("123", "Python编程", "张三")
user1 = User("001", "李四")

library.add_book(book1)
library.register_user(user1)
library.borrow_book("001", "123")
```

### 项目2：电商系统

**核心类：**

```python
class Product:
    def __init__(self, product_id, name, price, stock):
        self.product_id = product_id
        self.name = name
        self.price = price
        self.stock = stock

class ShoppingCart:
    def __init__(self):
        self.items = []
    
    def add_item(self, product, quantity):
        self.items.append({
            'product': product,
            'quantity': quantity
        })
    
    def total(self):
        return sum(item['product'].price * item['quantity'] 
                   for item in self.items)

class Order:
    def __init__(self, order_id, customer, cart):
        self.order_id = order_id
        self.customer = customer
        self.items = cart.items
        self.total = cart.total()
        self.status = "pending"
    
    def process(self):
        self.status = "processing"
    
    def ship(self):
        self.status = "shipped"

class Customer:
    def __init__(self, customer_id, name, email):
        self.customer_id = customer_id
        self.name = name
        self.email = email
        self.orders = []
    
    def place_order(self, cart):
        order = Order(len(self.orders) + 1, self, cart)
        self.orders.append(order)
        return order
```

---

## 课程大纲

### 第一章：面向对象编程概述 (2周)

#### 1.1 编程范式的演进
- 面向过程编程的局限性
- 面向对象编程的优势
- 面向对象编程语言的发展历史

#### 1.2 面向对象的基本概念
- 现实世界的抽象
- 对象和类的概念
- 面向对象的特征：封装、继承、多态

#### 1.3 面向对象分析与设计
- 问题域分析
- 对象识别方法
- 类图的基本表示

**实验内容**：
- 分析现实世界中的对象和类关系
- 绘制简单的类图

### 第二章：类与对象 (3周)

#### 2.1 类的定义与实现
- 类的基本结构
- 属性和方法的定义
- 访问控制修饰符

#### 2.2 对象的创建与使用
- 对象的实例化过程
- 构造函数和析构函数
- 对象的生命周期

#### 2.3 成员访问与信息隐藏
- 公有、私有、保护成员
- getter和setter方法
- 信息隐藏的重要性

**实验内容**：
- 设计和实现基本的类
- 创建和操作对象
- 实现数据封装

**参考资料**：
> 💡 **扩展学习**: 如需了解Java语言中类与对象的具体实现，可参考：
> - [JavaSE 核心内容 - 面向对象基础](../../../public/笔记/JavaSE%20核心内容/JavaSE%20核心内容%20-%20JavaSE%20笔记（三）面向对象基础.md)

### 第三章：封装 (2周)

#### 3.1 封装的概念与意义
- 数据隐藏与接口分离
- 封装的好处
- 封装的实现方式

#### 3.2 访问控制机制
- 访问权限的层次
- 包的概念和使用
- 模块化设计

#### 3.3 属性和方法的设计
- 属性的封装策略
- 方法的职责分配
- 常量和静态成员

**实验内容**：
- 实现完整的数据封装
- 设计合理的类接口
- 使用包组织代码

### 第四章：继承 (3周)

#### 4.1 继承的基本概念
- 继承关系的建立
- 父类和子类
- 继承的语法和语义

#### 4.2 继承的实现机制
- 成员的继承规则
- 构造函数的调用链
- 方法的重写和重载

#### 4.3 继承层次的设计
- 单继承与多继承
- 抽象类的使用
- 继承与组合的选择

**实验内容**：
- 设计类继承层次
- 实现方法重写
- 使用抽象类

### 第五章：多态 (3周)

#### 5.1 多态的概念与类型
- 编译时多态与运行时多态
- 方法重载与方法重写
- 多态的实现机制

#### 5.2 虚函数与动态绑定
- 虚函数表的概念
- 动态绑定的过程
- 多态的性能考虑

#### 5.3 接口与多态
- 接口的定义和实现
- 接口与抽象类的区别
- 多重继承的替代方案

**实验内容**：
- 实现多态机制
- 设计和使用接口
- 比较不同多态实现方式

### 第六章：高级特性 (2周)

#### 6.1 泛型编程
- 泛型的概念和意义
- 泛型类和泛型方法
- 类型参数的约束

#### 6.2 异常处理
- 异常的概念和分类
- 异常处理机制
- 自定义异常类

#### 6.3 内部类和嵌套类
- 内部类的类型和用途
- 匿名类的使用
- 局部类和静态嵌套类

**实验内容**：
- 使用泛型提高代码复用性
- 实现异常处理机制
- 设计内部类

### 第七章：设计模式入门 (1周)

#### 7.1 设计模式概述
- 设计模式的概念
- 常见设计模式分类
- 设计模式的作用

#### 7.2 基础设计模式
- 单例模式
- 工厂模式
- 观察者模式

**实验内容**：
- 实现基本设计模式
- 分析设计模式的应用场景

## 实验安排

### 实验一：类与对象基础 (第3周)
**目标**: 掌握类的定义和对象的创建
**内容**: 
- 设计学生信息管理类
- 实现基本的增删改查操作
- 验证封装性

### 实验二：继承与多态 (第7周)
**目标**: 理解继承机制和多态特性
**内容**:
- 设计图形类层次结构
- 实现不同图形的面积计算
- 使用多态机制统一处理

### 实验三：接口与抽象类 (第10周)
**目标**: 掌握接口和抽象类的使用
**内容**:
- 设计动物类层次
- 使用接口定义行为
- 实现多重继承效果

### 实验四：综合项目 (第14周)
**目标**: 综合运用面向对象编程技术
**内容**:
- 设计简单的图书管理系统
- 使用面向对象方法分析和设计
- 实现完整的系统功能

## 课程项目

### 项目1：图书管理系统（基础项目）

**项目目标**：实现一个简单的图书馆管理系统，掌握OOP基础概念。

**核心功能**：
- 图书的添加、删除、查询
- 用户借阅、归还图书
- 图书分类管理
- 借阅记录统计

**完整代码示例（Python版）**：

```python
from datetime import datetime, timedelta
from typing import List, Optional

# 基础类：图书
class Book:
    """图书基类"""
    def __init__(self, book_id: str, title: str, author: str, isbn: str):
        self.book_id = book_id
        self.title = title
        self.author = author
        self.isbn = isbn
        self.is_borrowed = False
        self.borrow_date = None
        self.return_date = None
    
    def __str__(self):
        status = "已借出" if self.is_borrowed else "可借阅"
        return f"[{self.book_id}] {self.title} - {self.author} ({status})"
    
    def borrow(self):
        """借出图书"""
        if self.is_borrowed:
            return False
        self.is_borrowed = True
        self.borrow_date = datetime.now()
        self.return_date = self.borrow_date + timedelta(days=30)
        return True
    
    def return_book(self):
        """归还图书"""
        if not self.is_borrowed:
            return False
        self.is_borrowed = False
        self.borrow_date = None
        self.return_date = None
        return True

# 继承：不同类型的图书
class TextBook(Book):
    """教材类"""
    def __init__(self, book_id: str, title: str, author: str, isbn: str, 
                 subject: str, grade: int):
        super().__init__(book_id, title, author, isbn)
        self.subject = subject
        self.grade = grade
    
    def __str__(self):
        return f"[教材] {super().__str__()} - {self.subject} {self.grade}年级"

class NovelBook(Book):
    """小说类"""
    def __init__(self, book_id: str, title: str, author: str, isbn: str, 
                 genre: str):
        super().__init__(book_id, title, author, isbn)
        self.genre = genre
    
    def __str__(self):
        return f"[小说] {super().__str__()} - {self.genre}类"

class TechnicalBook(Book):
    """技术书籍类"""
    def __init__(self, book_id: str, title: str, author: str, isbn: str, 
                 technology: str, level: str):
        super().__init__(book_id, title, author, isbn)
        self.technology = technology
        self.level = level
    
    def __str__(self):
        return f"[技术] {super().__str__()} - {self.technology} ({self.level})"

# 用户类
class User:
    """用户基类"""
    def __init__(self, user_id: str, name: str, email: str):
        self.user_id = user_id
        self.name = name
        self.email = email
        self.borrowed_books: List[Book] = []
        self.max_books = 5  # 默认最多借5本
    
    def can_borrow(self) -> bool:
        """检查是否可以借书"""
        return len(self.borrowed_books) < self.max_books
    
    def borrow_book(self, book: Book) -> bool:
        """借阅图书"""
        if not self.can_borrow():
            print(f"{self.name} 已达到借阅上限！")
            return False
        
        if book.borrow():
            self.borrowed_books.append(book)
            print(f"{self.name} 成功借阅：{book.title}")
            return True
        else:
            print(f"{book.title} 已被借出！")
            return False
    
    def return_book(self, book: Book) -> bool:
        """归还图书"""
        if book in self.borrowed_books:
            book.return_book()
            self.borrowed_books.remove(book)
            print(f"{self.name} 成功归还：{book.title}")
            return True
        else:
            print(f"{self.name} 未借阅此书！")
            return False
    
    def list_borrowed_books(self):
        """列出已借图书"""
        if not self.borrowed_books:
            print(f"{self.name} 当前无借阅图书")
        else:
            print(f"\n{self.name} 的借阅记录：")
            for book in self.borrowed_books:
                print(f"  - {book}")

# 继承：不同类型的用户
class StudentUser(User):
    """学生用户"""
    def __init__(self, user_id: str, name: str, email: str, student_id: str, major: str):
        super().__init__(user_id, name, email)
        self.student_id = student_id
        self.major = major
        self.max_books = 10  # 学生可借10本

class TeacherUser(User):
    """教师用户"""
    def __init__(self, user_id: str, name: str, email: str, department: str):
        super().__init__(user_id, name, email)
        self.department = department
        self.max_books = 20  # 教师可借20本

# 图书馆管理系统（组合模式）
class Library:
    """图书馆管理系统"""
    def __init__(self, name: str):
        self.name = name
        self.books: List[Book] = []
        self.users: List[User] = []
    
    def add_book(self, book: Book):
        """添加图书"""
        self.books.append(book)
        print(f"成功添加图书：{book.title}")
    
    def add_user(self, user: User):
        """添加用户"""
        self.users.append(user)
        print(f"成功添加用户：{user.name}")
    
    def search_book(self, keyword: str) -> List[Book]:
        """搜索图书"""
        results = []
        for book in self.books:
            if (keyword.lower() in book.title.lower() or 
                keyword.lower() in book.author.lower()):
                results.append(book)
        return results
    
    def list_available_books(self):
        """列出可借阅图书"""
        print(f"\n{self.name} - 可借阅图书：")
        available = [book for book in self.books if not book.is_borrowed]
        if not available:
            print("  暂无可借阅图书")
        else:
            for book in available:
                print(f"  {book}")
    
    def generate_report(self):
        """生成统计报告"""
        total_books = len(self.books)
        borrowed_books = sum(1 for book in self.books if book.is_borrowed)
        available_books = total_books - borrowed_books
        
        print(f"\n{'='*50}")
        print(f"{self.name} - 统计报告")
        print(f"{'='*50}")
        print(f"图书总数：{total_books}")
        print(f"已借出：{borrowed_books}")
        print(f"可借阅：{available_books}")
        print(f"注册用户：{len(self.users)}")
        print(f"{'='*50}\n")

# 使用示例
def main():
    # 创建图书馆
    library = Library("计算机学院图书馆")
    
    # 添加图书
    book1 = TextBook("B001", "数据结构与算法", "严蔚敏", "978-7-115-1", "计算机", 2)
    book2 = NovelBook("B002", "三体", "刘慈欣", "978-7-229-2", "科幻")
    book3 = TechnicalBook("B003", "深入理解计算机系统", "Bryant", "978-7-111-3", "系统编程", "进阶")
    
    library.add_book(book1)
    library.add_book(book2)
    library.add_book(book3)
    
    # 添加用户
    student = StudentUser("U001", "张三", "zhangsan@email.com", "2021001", "计算机科学")
    teacher = TeacherUser("U002", "李老师", "li@email.com", "计算机系")
    
    library.add_user(student)
    library.add_user(teacher)
    
    # 查看可借阅图书
    library.list_available_books()
    
    # 学生借书
    student.borrow_book(book1)
    student.borrow_book(book2)
    
    # 教师借书
    teacher.borrow_book(book2)  # 尝试借已被借出的书
    teacher.borrow_book(book3)
    
    # 查看借阅记录
    student.list_borrowed_books()
    teacher.list_borrowed_books()
    
    # 查看可借阅图书
    library.list_available_books()
    
    # 归还图书
    student.return_book(book1)
    
    # 搜索图书
    results = library.search_book("计算机")
    print(f"\n搜索'计算机'的结果：")
    for book in results:
        print(f"  {book}")
    
    # 生成报告
    library.generate_report()

if __name__ == "__main__":
    main()
```

**运行输出**：
```
成功添加图书：数据结构与算法
成功添加图书：三体
成功添加图书：深入理解计算机系统
成功添加用户：张三
成功添加用户：李老师

计算机学院图书馆 - 可借阅图书：
  [教材] [B001] 数据结构与算法 - 严蔚敏 (可借阅) - 计算机 2年级
  [小说] [B002] 三体 - 刘慈欣 (可借阅) - 科幻类
  [技术] [B003] 深入理解计算机系统 - Bryant (可借阅) - 系统编程 (进阶)

张三 成功借阅：数据结构与算法
张三 成功借阅：三体
三体 已被借出！
李老师 成功借阅：深入理解计算机系统

张三 的借阅记录：
  - [教材] [B001] 数据结构与算法 - 严蔚敏 (已借出) - 计算机 2年级
  - [小说] [B002] 三体 - 刘慈欣 (已借出) - 科幻类

李老师 的借阅记录：
  - [技术] [B003] 深入理解计算机系统 - Bryant (已借出) - 系统编程 (进阶)

计算机学院图书馆 - 可借阅图书：
  暂无可借阅图书

张三 成功归还：数据结构与算法

搜索'计算机'的结果：
  [教材] [B001] 数据结构与算法 - 严蔚敏 (可借阅) - 计算机 2年级
  [技术] [B003] 深入理解计算机系统 - Bryant (已借出) - 系统编程 (进阶)

==================================================
计算机学院图书馆 - 统计报告
==================================================
图书总数：3
已借出：2
可借阅：1
注册用户：2
==================================================
```

**项目总结**：
- ✅ 使用了**封装**：私有属性，公共方法
- ✅ 使用了**继承**：TextBook、NovelBook继承自Book
- ✅ 使用了**多态**：不同类型的Book有不同的__str__实现
- ✅ 使用了**组合**：Library包含多个Book和User

---

### 项目2：学生选课系统（进阶项目）

**项目要求**：
1. 使用面向对象方法进行系统分析和设计
2. 实现学生、课程、教师等核心类
3. 支持选课、退课、成绩管理等功能
4. 使用继承和多态机制
5. 应用设计模式（单例、工厂等）

**完整代码示例（Java版）**：

```java
import java.util.*;

// 课程类
class Course {
    private String courseId;
    private String courseName;
    private String teacher;
    private int capacity;
    private int enrolled;
    private List<Student> students;
    
    public Course(String courseId, String courseName, String teacher, int capacity) {
        this.courseId = courseId;
        this.courseName = courseName;
        this.teacher = teacher;
        this.capacity = capacity;
        this.enrolled = 0;
        this.students = new ArrayList<>();
    }
    
    public boolean addStudent(Student student) {
        if (enrolled >= capacity) {
            System.out.println("课程已满！");
            return false;
        }
        students.add(student);
        enrolled++;
        return true;
    }
    
    public boolean removeStudent(Student student) {
        if (students.remove(student)) {
            enrolled--;
            return true;
        }
        return false;
    }
    
    public String getCourseId() { return courseId; }
    public String getCourseName() { return courseName; }
    public int getEnrolled() { return enrolled; }
    public int getCapacity() { return capacity; }
    
    @Override
    public String toString() {
        return String.format("%s - %s (教师: %s, 已选: %d/%d)", 
            courseId, courseName, teacher, enrolled, capacity);
    }
}

// 学生类
class Student {
    private String studentId;
    private String name;
    private String major;
    private List<Course> courses;
    private Map<String, Integer> grades;
    private static final int MAX_COURSES = 6;
    
    public Student(String studentId, String name, String major) {
        this.studentId = studentId;
        this.name = name;
        this.major = major;
        this.courses = new ArrayList<>();
        this.grades = new HashMap<>();
    }
    
    public boolean enrollCourse(Course course) {
        if (courses.size() >= MAX_COURSES) {
            System.out.println("已达到选课上限！");
            return false;
        }
        
        if (courses.contains(course)) {
            System.out.println("已选过该课程！");
            return false;
        }
        
        if (course.addStudent(this)) {
            courses.add(course);
            System.out.println(name + " 成功选课：" + course.getCourseName());
            return true;
        }
        return false;
    }
    
    public boolean dropCourse(Course course) {
        if (courses.remove(course)) {
            course.removeStudent(this);
            grades.remove(course.getCourseId());
            System.out.println(name + " 成功退课：" + course.getCourseName());
            return true;
        }
        System.out.println("未选该课程！");
        return false;
    }
    
    public void setGrade(String courseId, int grade) {
        grades.put(courseId, grade);
    }
    
    public double calculateGPA() {
        if (grades.isEmpty()) return 0.0;
        int sum = 0;
        for (int grade : grades.values()) {
            sum += grade;
        }
        return (double) sum / grades.size();
    }
    
    public void printTranscript() {
        System.out.println("\n学生：" + name + " (" + studentId + ")");
        System.out.println("专业：" + major);
        System.out.println("已选课程：");
        for (Course course : courses) {
            Integer grade = grades.get(course.getCourseId());
            String gradeStr = (grade != null) ? grade.toString() : "未录入";
            System.out.println("  - " + course.getCourseName() + ": " + gradeStr);
        }
        System.out.println("平均分：" + String.format("%.2f", calculateGPA()));
    }
    
    public String getStudentId() { return studentId; }
    public String getName() { return name; }
}

// 选课系统（单例模式）
class CourseSystem {
    private static CourseSystem instance;
    private List<Course> courses;
    private List<Student> students;
    
    private CourseSystem() {
        courses = new ArrayList<>();
        students = new ArrayList<>();
    }
    
    // 单例模式：获取唯一实例
    public static CourseSystem getInstance() {
        if (instance == null) {
            instance = new CourseSystem();
        }
        return instance;
    }
    
    public void addCourse(Course course) {
        courses.add(course);
        System.out.println("添加课程：" + course.getCourseName());
    }
    
    public void addStudent(Student student) {
        students.add(student);
        System.out.println("添加学生：" + student.getName());
    }
    
    public Course findCourse(String courseId) {
        for (Course course : courses) {
            if (course.getCourseId().equals(courseId)) {
                return course;
            }
        }
        return null;
    }
    
    public Student findStudent(String studentId) {
        for (Student student : students) {
            if (student.getStudentId().equals(studentId)) {
                return student;
            }
        }
        return null;
    }
    
    public void listAllCourses() {
        System.out.println("\n所有课程：");
        for (Course course : courses) {
            System.out.println("  " + course);
        }
    }
    
    public void generateReport() {
        System.out.println("\n=== 选课系统报告 ===");
        System.out.println("课程总数：" + courses.size());
        System.out.println("学生总数：" + students.size());
        
        int totalEnrolled = 0;
        for (Course course : courses) {
            totalEnrolled += course.getEnrolled();
        }
        System.out.println("总选课人次：" + totalEnrolled);
    }
}

// 主程序
public class CourseManagementSystem {
    public static void main(String[] args) {
        // 获取选课系统实例（单例模式）
        CourseSystem system = CourseSystem.getInstance();
        
        // 添加课程
        Course course1 = new Course("CS101", "数据结构", "张老师", 30);
        Course course2 = new Course("CS102", "算法设计", "李老师", 25);
        Course course3 = new Course("MATH201", "离散数学", "王老师", 40);
        
        system.addCourse(course1);
        system.addCourse(course2);
        system.addCourse(course3);
        
        // 添加学生
        Student alice = new Student("2021001", "Alice", "计算机科学");
        Student bob = new Student("2021002", "Bob", "软件工程");
        
        system.addStudent(alice);
        system.addStudent(bob);
        
        // 显示所有课程
        system.listAllCourses();
        
        // 学生选课
        alice.enrollCourse(course1);
        alice.enrollCourse(course2);
        alice.enrollCourse(course3);
        
        bob.enrollCourse(course1);
        bob.enrollCourse(course2);
        
        // 录入成绩
        alice.setGrade("CS101", 95);
        alice.setGrade("CS102", 88);
        alice.setGrade("MATH201", 92);
        
        bob.setGrade("CS101", 85);
        bob.setGrade("CS102", 90);
        
        // 打印成绩单
        alice.printTranscript();
        bob.printTranscript();
        
        // 退课
        alice.dropCourse(course3);
        
        // 生成报告
        system.generateReport();
        
        // 显示更新后的课程信息
        system.listAllCourses();
    }
}
```

**运行输出**：
```
添加课程：数据结构
添加课程：算法设计
添加课程：离散数学
添加学生：Alice
添加学生：Bob

所有课程：
  CS101 - 数据结构 (教师: 张老师, 已选: 0/30)
  CS102 - 算法设计 (教师: 李老师, 已选: 0/25)
  MATH201 - 离散数学 (教师: 王老师, 已选: 0/40)

Alice 成功选课：数据结构
Alice 成功选课：算法设计
Alice 成功选课：离散数学
Bob 成功选课：数据结构
Bob 成功选课：算法设计

学生：Alice (2021001)
专业：计算机科学
已选课程：
  - 数据结构: 95
  - 算法设计: 88
  - 离散数学: 92
平均分：91.67

学生：Bob (2021002)
专业：软件工程
已选课程：
  - 数据结构: 85
  - 算法设计: 90
平均分：87.50

Alice 成功退课：离散数学

=== 选课系统报告 ===
课程总数：3
学生总数：2
总选课人次：4

所有课程：
  CS101 - 数据结构 (教师: 张老师, 已选: 2/30)
  CS102 - 算法设计 (教师: 李老师, 已选: 2/25)
  MATH201 - 离散数学 (教师: 王老师, 已选: 0/40)
```

**项目亮点**：
- ✅ **单例模式**：CourseSystem确保全局只有一个实例
- ✅ **封装**：所有属性私有，通过方法访问
- ✅ **业务逻辑**：选课限制、容量检查
- ✅ **数据管理**：成绩录入、GPA计算

---

### 项目3：在线购物系统（综合项目）

**项目目标**：实现一个电商系统，综合运用OOP所有特性和设计模式。

**系统架构**：
```
在线购物系统
├── 用户模块（User, Customer, Admin）
├── 商品模块（Product, Category）
├── 购物车模块（ShoppingCart, CartItem）
├── 订单模块（Order, OrderItem）
└── 支付模块（Payment, 策略模式）
```

**核心代码（Python实现，展示关键部分）**：

```python
from abc import ABC, abstractmethod
from enum import Enum
from datetime import datetime
from typing import List, Dict

# 枚举：订单状态
class OrderStatus(Enum):
    PENDING = "待支付"
    PAID = "已支付"
    SHIPPED = "已发货"
    DELIVERED = "已送达"
    CANCELLED = "已取消"

# 策略模式：支付策略
class PaymentStrategy(ABC):
    @abstractmethod
    def pay(self, amount: float) -> bool:
        pass

class AlipayPayment(PaymentStrategy):
    def pay(self, amount: float) -> bool:
        print(f"使用支付宝支付 ¥{amount:.2f}")
        return True

class WechatPayment(PaymentStrategy):
    def pay(self, amount: float) -> bool:
        print(f"使用微信支付 ¥{amount:.2f}")
        return True

class CreditCardPayment(PaymentStrategy):
    def __init__(self, card_number: str):
        self.card_number = card_number
    
    def pay(self, amount: float) -> bool:
        print(f"使用信用卡 {self.card_number[-4:]} 支付 ¥{amount:.2f}")
        return True

# 商品类
class Product:
    def __init__(self, product_id: str, name: str, price: float, 
                 stock: int, category: str):
        self.product_id = product_id
        self.name = name
        self.price = price
        self.stock = stock
        self.category = category
    
    def __str__(self):
        return f"{self.name} - ¥{self.price:.2f} (库存: {self.stock})"
    
    def reduce_stock(self, quantity: int) -> bool:
        if self.stock >= quantity:
            self.stock -= quantity
            return True
        return False
    
    def restore_stock(self, quantity: int):
        self.stock += quantity

# 购物车项
class CartItem:
    def __init__(self, product: Product, quantity: int):
        self.product = product
        self.quantity = quantity
    
    def get_subtotal(self) -> float:
        return self.product.price * self.quantity
    
    def __str__(self):
        return f"{self.product.name} x{self.quantity} = ¥{self.get_subtotal():.2f}"

# 购物车
class ShoppingCart:
    def __init__(self):
        self.items: List[CartItem] = []
    
    def add_item(self, product: Product, quantity: int = 1):
        # 检查是否已存在
        for item in self.items:
            if item.product.product_id == product.product_id:
                item.quantity += quantity
                print(f"已更新购物车：{product.name} x{item.quantity}")
                return
        
        # 添加新项
        self.items.append(CartItem(product, quantity))
        print(f"已添加到购物车：{product.name} x{quantity}")
    
    def remove_item(self, product_id: str):
        self.items = [item for item in self.items 
                      if item.product.product_id != product_id]
    
    def get_total(self) -> float:
        return sum(item.get_subtotal() for item in self.items)
    
    def clear(self):
        self.items.clear()
    
    def display(self):
        if not self.items:
            print("购物车为空")
            return
        
        print("\n购物车内容：")
        for item in self.items:
            print(f"  {item}")
        print(f"总计：¥{self.get_total():.2f}")

# 订单项
class OrderItem:
    def __init__(self, product_name: str, price: float, quantity: int):
        self.product_name = product_name
        self.price = price
        self.quantity = quantity
    
    def get_subtotal(self) -> float:
        return self.price * self.quantity

# 订单类
class Order:
    _order_counter = 1000
    
    def __init__(self, customer_name: str):
        Order._order_counter += 1
        self.order_id = f"ORD{Order._order_counter}"
        self.customer_name = customer_name
        self.items: List[OrderItem] = []
        self.status = OrderStatus.PENDING
        self.created_at = datetime.now()
        self.total_amount = 0.0
    
    def add_item(self, product: Product, quantity: int):
        order_item = OrderItem(product.name, product.price, quantity)
        self.items.append(order_item)
        self.total_amount += order_item.get_subtotal()
    
    def pay(self, payment_strategy: PaymentStrategy) -> bool:
        if self.status != OrderStatus.PENDING:
            print("订单状态不允许支付")
            return False
        
        if payment_strategy.pay(self.total_amount):
            self.status = OrderStatus.PAID
            print(f"订单 {self.order_id} 支付成功！")
            return True
        return False
    
    def ship(self):
        if self.status == OrderStatus.PAID:
            self.status = OrderStatus.SHIPPED
            print(f"订单 {self.order_id} 已发货")
    
    def deliver(self):
        if self.status == OrderStatus.SHIPPED:
            self.status = OrderStatus.DELIVERED
            print(f"订单 {self.order_id} 已送达")
    
    def cancel(self):
        if self.status in [OrderStatus.PENDING, OrderStatus.PAID]:
            self.status = OrderStatus.CANCELLED
            # 恢复库存
            for item in self.items:
                # 这里简化处理，实际需要通过产品ID恢复
                pass
            print(f"订单 {self.order_id} 已取消")
    
    def display(self):
        print(f"\n订单号：{self.order_id}")
        print(f"客户：{self.customer_name}")
        print(f"状态：{self.status.value}")
        print(f"创建时间：{self.created_at.strftime('%Y-%m-%d %H:%M:%S')}")
        print("订单明细：")
        for item in self.items:
            print(f"  {item.product_name} x{item.quantity} = ¥{item.get_subtotal():.2f}")
        print(f"订单总额：¥{self.total_amount:.2f}")

# 用户类（抽象基类）
class User(ABC):
    def __init__(self, user_id: str, username: str, email: str):
        self.user_id = user_id
        self.username = username
        self.email = email
    
    @abstractmethod
    def get_role(self) -> str:
        pass

# 客户类
class Customer(User):
    def __init__(self, user_id: str, username: str, email: str, address: str):
        super().__init__(user_id, username, email)
        self.address = address
        self.cart = ShoppingCart()
        self.orders: List[Order] = []
    
    def get_role(self) -> str:
        return "顾客"
    
    def view_cart(self):
        self.cart.display()
    
    def checkout(self) -> Order:
        if not self.cart.items:
            print("购物车为空，无法结账")
            return None
        
        # 创建订单
        order = Order(self.username)
        
        # 检查并扣减库存
        for cart_item in self.cart.items:
            if not cart_item.product.reduce_stock(cart_item.quantity):
                print(f"{cart_item.product.name} 库存不足")
                return None
            order.add_item(cart_item.product, cart_item.quantity)
        
        # 清空购物车
        self.cart.clear()
        self.orders.append(order)
        
        print(f"订单创建成功：{order.order_id}")
        return order
    
    def view_orders(self):
        if not self.orders:
            print("暂无订单")
            return
        
        print(f"\n{self.username} 的订单列表：")
        for order in self.orders:
            print(f"  {order.order_id} - {order.status.value} - ¥{order.total_amount:.2f}")

# 管理员类
class Admin(User):
    def get_role(self) -> str:
        return "管理员"
    
    def add_product(self, store, product: Product):
        store.add_product(product)
        print(f"管理员添加商品：{product.name}")
    
    def view_all_orders(self, customers: List[Customer]):
        print("\n所有订单：")
        for customer in customers:
            for order in customer.orders:
                print(f"  {order.order_id} - {customer.username} - {order.status.value}")

# 商店类（单例模式）
class OnlineStore:
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance.products = []
            cls._instance.customers = []
        return cls._instance
    
    def add_product(self, product: Product):
        self.products.append(product)
    
    def search_product(self, keyword: str) -> List[Product]:
        return [p for p in self.products 
                if keyword.lower() in p.name.lower()]
    
    def display_products(self):
        print("\n商品列表：")
        for product in self.products:
            print(f"  {product}")

# 主程序演示
def main():
    # 创建商店（单例）
    store = OnlineStore()
    
    # 添加商品
    p1 = Product("P001", "iPhone 15", 5999.0, 50, "手机")
    p2 = Product("P002", "MacBook Pro", 12999.0, 30, "电脑")
    p3 = Product("P003", "AirPods Pro", 1999.0, 100, "耳机")
    
    store.add_product(p1)
    store.add_product(p2)
    store.add_product(p3)
    
    # 显示商品
    store.display_products()
    
    # 创建客户
    customer = Customer("C001", "张三", "zhangsan@email.com", "北京市朝阳区")
    
    # 购物流程
    customer.cart.add_item(p1, 2)
    customer.cart.add_item(p3, 1)
    customer.view_cart()
    
    # 结账
    order = customer.checkout()
    
    if order:
        order.display()
        
        # 支付（策略模式）
        payment = AlipayPayment()
        order.pay(payment)
        
        # 发货
        order.ship()
        order.deliver()
    
    # 查看订单
    customer.view_orders()
    
    # 再次购物，使用不同支付方式
    customer.cart.add_item(p2, 1)
    order2 = customer.checkout()
    
    if order2:
        # 使用信用卡支付
        credit_card = CreditCardPayment("1234-5678-9012-3456")
        order2.pay(credit_card)
        order2.display()

if __name__ == "__main__":
    main()
```

**运行输出**（部分）：
```
商品列表：
  iPhone 15 - ¥5999.00 (库存: 50)
  MacBook Pro - ¥12999.00 (库存: 30)
  AirPods Pro - ¥1999.00 (库存: 100)

已添加到购物车：iPhone 15 x2
已添加到购物车：AirPods Pro x1

购物车内容：
  iPhone 15 x2 = ¥11998.00
  AirPods Pro x1 = ¥1999.00
总计：¥13997.00

订单创建成功：ORD1001

订单号：ORD1001
客户：张三
状态：待支付
创建时间：2025-10-13 14:30:25
订单明细：
  iPhone 15 x2 = ¥11998.00
  AirPods Pro x1 = ¥1999.00
订单总额：¥13997.00

使用支付宝支付 ¥13997.00
订单 ORD1001 支付成功！
订单 ORD1001 已发货
订单 ORD1001 已送达

张三 的订单列表：
  ORD1001 - 已送达 - ¥13997.00
```

**项目特点**：
- ✅ **多种设计模式**：单例、策略、抽象工厂
- ✅ **完整业务流程**：浏览→加购→结账→支付→发货
- ✅ **面向对象特性**：封装、继承、多态、抽象
- ✅ **实际应用价值**：可扩展为真实电商系统

**评分标准**：
- 需求分析和系统设计 (30%)
- 代码实现质量 (40%)
- 功能完整性 (20%)
- 文档和演示 (10%)

## 考核方式

- **平时成绩** (30%): 出勤、作业、实验报告
- **期中考试** (30%): 理论知识和基础编程
- **期末项目** (40%): 综合项目设计与实现

## 教材与参考资料

### 主要教材
1. 《面向对象程序设计基础》- 清华大学出版社
2. 《设计模式：可复用面向对象软件的基础》- 机械工业出版社

### 参考资料
1. 《重构：改善既有代码的设计》- 人民邮电出版社
2. 《代码大全》- 电子工业出版社
3. 《Effective Java》- 机械工业出版社

### 在线资源
- [面向对象设计原则详解](https://refactoring.guru/design-patterns)
- [UML类图绘制指南](https://www.visual-paradigm.com/guide/uml-unified-modeling-language/what-is-class-diagram/)

## 🐛 常见Bug与调试技巧

### 常见OOP编程错误

#### 1. 忘记调用父类构造函数

**错误示例（Python）**：
```python
class Animal:
    def __init__(self, name):
        self.name = name

class Dog(Animal):
    def __init__(self, name, breed):
        # 忘记调用super().__init__()
        self.breed = breed  # 错误：self.name未初始化
```

**正确做法**：
```python
class Dog(Animal):
    def __init__(self, name, breed):
        super().__init__(name)  # 正确：先调用父类构造
        self.breed = breed
```

#### 2. 可变默认参数陷阱

**错误示例**：
```python
class ShoppingCart:
    def __init__(self, items=[]):  # 危险！
        self.items = items

cart1 = ShoppingCart()
cart1.items.append("Apple")

cart2 = ShoppingCart()
print(cart2.items)  # 输出：['Apple'] - 意外！
```

**正确做法**：
```python
class ShoppingCart:
    def __init__(self, items=None):
        self.items = items if items is not None else []
```

#### 3. 循环引用导致内存泄漏

**问题代码**：
```python
class Node:
    def __init__(self, value):
        self.value = value
        self.parent = None
        self.children = []
    
    def add_child(self, child):
        child.parent = self  # 相互引用
        self.children.append(child)
```

**解决方案**：使用弱引用
```python
import weakref

class Node:
    def __init__(self, value):
        self.value = value
        self._parent = None
        self.children = []
    
    @property
    def parent(self):
        return self._parent() if self._parent else None
    
    @parent.setter
    def parent(self, value):
        self._parent = weakref.ref(value) if value else None
```

#### 4. 多态方法签名不一致

**错误示例（Java）**：
```java
class Shape {
    public double area() {
        return 0;
    }
}

class Rectangle extends Shape {
    // 错误：参数不同，不是重写而是重载
    public double area(double width, double height) {
        return width * height;
    }
}
```

**正确做法**：
```java
class Rectangle extends Shape {
    private double width, height;
    
    public Rectangle(double width, double height) {
        this.width = width;
        this.height = height;
    }
    
    @Override
    public double area() {  // 正确：签名一致
        return width * height;
    }
}
```

#### 5. 忘记实现抽象方法

**错误示例**：
```python
from abc import ABC, abstractmethod

class Vehicle(ABC):
    @abstractmethod
    def start(self):
        pass
    
    @abstractmethod
    def stop(self):
        pass

class Car(Vehicle):
    def start(self):
        print("Car started")
    # 忘记实现stop() - 运行时错误！

# car = Car()  # TypeError: Can't instantiate abstract class
```

**正确做法**：
```python
class Car(Vehicle):
    def start(self):
        print("Car started")
    
    def stop(self):  # 必须实现所有抽象方法
        print("Car stopped")
```

### 调试技巧

#### 1. 使用`__repr__`方便调试

```python
class Student:
    def __init__(self, name, age, gpa):
        self.name = name
        self.age = age
        self.gpa = gpa
    
    def __repr__(self):
        return f"Student(name='{self.name}', age={self.age}, gpa={self.gpa})"
    
    def __str__(self):
        return f"{self.name} ({self.age}岁, GPA: {self.gpa})"

s = Student("Alice", 20, 3.8)
print(s)         # 输出：Alice (20岁, GPA: 3.8)
print(repr(s))   # 输出：Student(name='Alice', age=20, gpa=3.8)
print([s])       # 输出：[Student(name='Alice', age=20, gpa=3.8)]
```

#### 2. 使用断点和日志

```python
import logging

logging.basicConfig(level=logging.DEBUG)

class BankAccount:
    def __init__(self, balance):
        self.balance = balance
        self.logger = logging.getLogger(__name__)
    
    def withdraw(self, amount):
        self.logger.debug(f"尝试取款: {amount}, 当前余额: {self.balance}")
        
        if amount > self.balance:
            self.logger.warning(f"余额不足！需要 {amount}, 仅有 {self.balance}")
            return False
        
        self.balance -= amount
        self.logger.info(f"取款成功: {amount}, 剩余: {self.balance}")
        return True

account = BankAccount(1000)
account.withdraw(500)   # DEBUG: 尝试取款: 500, 当前余额: 1000
                        # INFO: 取款成功: 500, 剩余: 500
account.withdraw(800)   # WARNING: 余额不足！需要 800, 仅有 500
```

#### 3. 单元测试

```python
import unittest

class Rectangle:
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def area(self):
        return self.width * self.height
    
    def perimeter(self):
        return 2 * (self.width + self.height)

class TestRectangle(unittest.TestCase):
    def setUp(self):
        self.rect = Rectangle(4, 5)
    
    def test_area(self):
        self.assertEqual(self.rect.area(), 20)
    
    def test_perimeter(self):
        self.assertEqual(self.rect.perimeter(), 18)
    
    def test_negative_dimensions(self):
        with self.assertRaises(ValueError):
            rect = Rectangle(-1, 5)

if __name__ == '__main__':
    unittest.main()
```

---

## 💡 OOP最佳实践

### 1. SOLID原则详解

#### S - 单一职责原则（Single Responsibility）

**反例**：
```python
class User:
    def __init__(self, name, email):
        self.name = name
        self.email = email
    
    # 职责1：用户数据管理
    def update_email(self, new_email):
        self.email = new_email
    
    # 职责2：数据库操作（不应该在这里）
    def save_to_database(self):
        # 数据库操作...
        pass
    
    # 职责3：邮件发送（不应该在这里）
    def send_email(self, message):
        # 发送邮件...
        pass
```

**正确做法**：
```python
class User:
    """只负责用户数据"""
    def __init__(self, name, email):
        self.name = name
        self.email = email
    
    def update_email(self, new_email):
        self.email = new_email

class UserRepository:
    """只负责数据库操作"""
    def save(self, user: User):
        # 保存到数据库
        pass
    
    def find(self, user_id):
        # 从数据库查询
        pass

class EmailService:
    """只负责邮件发送"""
    def send(self, to_email, message):
        # 发送邮件
        pass
```

#### O - 开闭原则（Open/Closed）

**示例：支付系统**：
```python
from abc import ABC, abstractmethod

# 对扩展开放
class PaymentProcessor(ABC):
    @abstractmethod
    def process(self, amount: float):
        pass

# 基础实现
class CreditCardPayment(PaymentProcessor):
    def process(self, amount: float):
        print(f"信用卡支付 ${amount}")

class PayPalPayment(PaymentProcessor):
    def process(self, amount: float):
        print(f"PayPal支付 ${amount}")

# 新增支付方式（扩展）- 不需要修改现有代码
class CryptoPayment(PaymentProcessor):
    def process(self, amount: float):
        print(f"加密货币支付 ${amount}")

# 使用
def checkout(payment: PaymentProcessor, amount: float):
    payment.process(amount)

checkout(CreditCardPayment(), 100)
checkout(CryptoPayment(), 50)  # 新增的方式无缝接入
```

#### L - 里氏替换原则（Liskov Substitution）

**反例**：
```python
class Bird:
    def fly(self):
        print("飞翔")

class Penguin(Bird):
    def fly(self):
        raise Exception("企鹅不会飞！")  # 违反LSP
```

**正确做法**：
```python
class Bird:
    def move(self):
        pass

class FlyingBird(Bird):
    def move(self):
        self.fly()
    
    def fly(self):
        print("飞翔")

class Penguin(Bird):
    def move(self):
        self.swim()
    
    def swim(self):
        print("游泳")

# 可以安全替换
def let_bird_move(bird: Bird):
    bird.move()

let_bird_move(FlyingBird())  # 飞翔
let_bird_move(Penguin())     # 游泳
```

#### I - 接口隔离原则（Interface Segregation）

**反例**：
```python
class Worker(ABC):
    @abstractmethod
    def work(self):
        pass
    
    @abstractmethod
    def eat(self):
        pass
    
    @abstractmethod
    def sleep(self):
        pass

class Robot(Worker):  # 机器人不需要eat和sleep
    def work(self):
        print("工作")
    
    def eat(self):
        pass  # 不需要但必须实现
    
    def sleep(self):
        pass  # 不需要但必须实现
```

**正确做法**：
```python
class Workable(ABC):
    @abstractmethod
    def work(self):
        pass

class Eatable(ABC):
    @abstractmethod
    def eat(self):
        pass

class Sleepable(ABC):
    @abstractmethod
    def sleep(self):
        pass

class Human(Workable, Eatable, Sleepable):
    def work(self):
        print("工作")
    
    def eat(self):
        print("吃饭")
    
    def sleep(self):
        print("睡觉")

class Robot(Workable):  # 只实现需要的接口
    def work(self):
        print("工作")
```

#### D - 依赖倒置原则（Dependency Inversion）

**反例**：
```python
class MySQLDatabase:
    def save(self, data):
        print(f"保存到MySQL: {data}")

class UserService:
    def __init__(self):
        self.db = MySQLDatabase()  # 依赖具体实现
    
    def save_user(self, user):
        self.db.save(user)
```

**正确做法**：
```python
class Database(ABC):
    @abstractmethod
    def save(self, data):
        pass

class MySQLDatabase(Database):
    def save(self, data):
        print(f"保存到MySQL: {data}")

class MongoDatabase(Database):
    def save(self, data):
        print(f"保存到MongoDB: {data}")

class UserService:
    def __init__(self, db: Database):  # 依赖抽象
        self.db = db
    
    def save_user(self, user):
        self.db.save(user)

# 灵活切换实现
service1 = UserService(MySQLDatabase())
service2 = UserService(MongoDatabase())
```

### 2. 组合优于继承

**继承的问题（多层继承导致复杂）**：
```python
class Employee:
    def work(self):
        print("工作")

class Manager(Employee):
    def manage(self):
        print("管理")

class Engineer(Employee):
    def code(self):
        print("编程")

# 如果需要既是经理又是工程师？多重继承会很复杂
```

**组合的解决方案**：
```python
class WorkCapability:
    def work(self):
        print("工作")

class ManageCapability:
    def manage(self):
        print("管理")

class CodeCapability:
    def code(self):
        print("编程")

class Employee:
    def __init__(self):
        self.capabilities = []
    
    def add_capability(self, capability):
        self.capabilities.append(capability)
    
    def perform_tasks(self):
        for cap in self.capabilities:
            for method in dir(cap):
                if not method.startswith('_'):
                    getattr(cap, method)()

# 灵活组合
emp = Employee()
emp.add_capability(WorkCapability())
emp.add_capability(ManageCapability())
emp.add_capability(CodeCapability())
emp.perform_tasks()  # 工作、管理、编程
```

### 3. 命名规范

| 类型 | Python | Java | 示例 |
|------|--------|------|------|
| 类名 | PascalCase | PascalCase | `UserAccount`, `ShoppingCart` |
| 方法名 | snake_case | camelCase | `get_balance()`, `getBalance()` |
| 常量 | UPPER_CASE | UPPER_CASE | `MAX_SIZE`, `DEFAULT_TIMEOUT` |
| 私有成员 | _leading_underscore | private关键字 | `_internal_data` |
| 抽象类 | Base或Abstract前缀 | Abstract前缀 | `BaseRepository`, `AbstractFactory` |

### 4. 文档字符串

```python
class BankAccount:
    """银行账户类
    
    用于管理用户的银行账户，包括存款、取款、查询余额等功能。
    
    Attributes:
        account_id (str): 账户ID
        balance (float): 账户余额
        owner (str): 账户所有者
    
    Examples:
        >>> account = BankAccount("A001", "Alice", 1000)
        >>> account.deposit(500)
        True
        >>> account.get_balance()
        1500.0
    """
    
    def __init__(self, account_id: str, owner: str, balance: float = 0):
        """初始化银行账户
        
        Args:
            account_id: 账户ID
            owner: 账户所有者姓名
            balance: 初始余额，默认为0
        
        Raises:
            ValueError: 如果初始余额为负数
        """
        if balance < 0:
            raise ValueError("初始余额不能为负数")
        
        self.account_id = account_id
        self.owner = owner
        self.balance = balance
    
    def deposit(self, amount: float) -> bool:
        """存款
        
        Args:
            amount: 存款金额
        
        Returns:
            bool: 存款是否成功
        
        Examples:
            >>> account.deposit(100)
            True
        """
        if amount <= 0:
            return False
        self.balance += amount
        return True
```

---

## 学习建议

1. **理论与实践结合**
   - 每学习一个概念都要通过编程实践加深理解
   - 多分析现实世界中的对象关系

2. **循序渐进**
   - 先掌握基本概念，再学习高级特性
   - 不要急于学习复杂的设计模式

3. **多做练习**
   - 完成所有实验和作业
   - 尝试设计自己的小项目

4. **阅读优秀代码**
   - 学习开源项目的设计思路
   - 分析经典设计模式的实现

## 常见问题解答

**Q: 面向对象编程与面向过程编程有什么区别？**
A: 面向过程编程关注解决问题的步骤，而面向对象编程关注问题域中的对象及其交互。面向对象编程具有更好的可维护性、可扩展性和代码复用性。

**Q: 什么时候使用继承，什么时候使用组合？**
A: 当存在"是一个"(is-a)关系时使用继承，当存在"有一个"(has-a)关系时使用组合。一般来说，优先考虑组合，因为它提供了更好的灵活性。

**Q: 如何设计好的类接口？**
A: 好的类接口应该遵循单一职责原则，提供清晰、一致的方法命名，隐藏实现细节，并且易于使用和理解。

**Q: Python和Java在OOP上有什么区别？**
A: 主要区别：
- Python是动态类型，Java是静态类型
- Python支持多重继承，Java通过接口实现多重继承
- Python使用鸭子类型，Java需要显式声明类型
- Python更灵活，Java更严格

---

## 📚 学习建议与总结

### 学习路径

**阶段1：概念理解（2周）**
- ✅ 理解OOP三大特性
- ✅ 掌握类与对象的基本用法
- ✅ 练习简单的类设计

**阶段2：进阶应用（3周）**
- ✅ 掌握抽象类和接口
- ✅ 理解SOLID原则
- ✅ 学习常用设计模式

**阶段3：实战练习（3周）**
- ✅ 完成综合项目
- ✅ 重构现有代码
- ✅ 参与代码审查

### 学习资源

**📚 推荐书籍：**
1. 《Head First设计模式》- 图文并茂，易于理解
2. 《重构：改善既有代码的设计》- 代码优化必读
3. 《设计模式：可复用面向对象软件的基础》- 经典著作
4. 《Effective Java》- Java最佳实践

**🎥 在线课程：**
- Coursera: Object-Oriented Programming
- Udemy: Python OOP Complete Course
- MIT OpenCourseWare: Software Construction

**💻 实践平台：**
- LeetCode: OOP设计题
- GitHub: 优秀开源项目
- 自己动手：从零实现小项目

### 关键要点总结

**核心概念：**
```
封装：数据隐藏，接口暴露
  ↓
继承：代码复用，层次结构
  ↓
多态：灵活调用，统一接口
```

**设计原则：**
- **单一职责**：一个类只做一件事
- **开闭原则**：对扩展开放，对修改关闭
- **里氏替换**：子类可替换父类
- **接口隔离**：接口小而精
- **依赖倒置**：依赖抽象不依赖具体

**设计模式分类：**

| 类型 | 模式 | 用途 |
|------|------|------|
| **创建型** | 单例、工厂、建造者 | 对象创建 |
| **结构型** | 适配器、装饰器、代理 | 对象组合 |
| **行为型** | 策略、观察者、模板 | 对象协作 |

### 常见错误与避免

**❌ 错误1：过度使用继承**
```python
# 不好：深层继承
class A: pass
class B(A): pass
class C(B): pass
class D(C): pass  # 太深了！
```

**✅ 改进：使用组合**
```python
class A:
    def __init__(self):
        self.component_b = B()
        self.component_c = C()
```

**❌ 错误2：违反封装**
```python
class User:
    def __init__(self):
        self.password = "123456"  # 直接暴露！

user = User()
print(user.password)  # 不安全
```

**✅ 改进：使用私有属性**
```python
class User:
    def __init__(self):
        self.__password = "123456"
    
    def verify_password(self, pwd):
        return pwd == self.__password
```

**❌ 错误3：不合理的类设计**
```python
# 上帝类：什么都做
class System:
    def connect_db(self): pass
    def send_email(self): pass
    def generate_report(self): pass
    def process_payment(self): pass
    # ... 100个方法
```

**✅ 改进：职责分离**
```python
class DatabaseManager: pass
class EmailService: pass
class ReportGenerator: pass
class PaymentProcessor: pass
```

### 实践技巧

**1. 先设计后编码**
```
需求分析 → UML类图 → 编码实现 → 测试优化
```

**2. 遵循命名规范**
- 类名：大驼峰（`UserAccount`）
- 方法名：小驼峰或下划线（`getUserInfo`, `get_user_info`）
- 私有成员：前置下划线（`_private`, `__very_private`）

**3. 编写文档和注释**
```python
class BankAccount:
    """银行账户类
    
    Attributes:
        owner: 账户所有者
        balance: 账户余额
    """
    
    def deposit(self, amount):
        """存款
        
        Args:
            amount: 存款金额
            
        Returns:
            bool: 操作是否成功
        """
        pass
```

**4. 单元测试**
```python
import unittest

class TestBankAccount(unittest.TestCase):
    def setUp(self):
        self.account = BankAccount("Alice", 1000)
    
    def test_deposit(self):
        self.account.deposit(500)
        self.assertEqual(self.account.get_balance(), 1500)
    
    def test_withdraw(self):
        self.account.withdraw(300)
        self.assertEqual(self.account.get_balance(), 700)
```

### 学习检验清单

**基础掌握：**
- [ ] 能够定义类并创建对象
- [ ] 理解封装、继承、多态的概念
- [ ] 掌握访问修饰符的使用
- [ ] 能够重写方法

**进阶应用：**
- [ ] 能够设计抽象类和接口
- [ ] 理解并应用SOLID原则
- [ ] 掌握3种以上设计模式
- [ ] 能够进行UML类图设计

**实战能力：**
- [ ] 独立完成中型项目的类设计
- [ ] 能够重构现有代码
- [ ] 理解框架源码中的OOP应用
- [ ] 能够进行代码审查

---

## 🎯 下一步学习方向

完成本课程后，你可以：

**1. 深入学习设计模式**
- 23种经典设计模式
- 企业级应用架构模式
- 领域驱动设计(DDD)

**2. 框架学习**
- Java: Spring框架
- Python: Django/Flask
- JavaScript: React/Vue

**3. 软件工程**
- UML建模
- 需求分析
- 架构设计

**4. 实践项目**
- 开发完整的Web应用
- 参与开源项目
- 构建自己的框架

---

## 📝 课程总结

面向对象编程是现代软件开发的基石。通过本课程的学习，你已经掌握了：

✨ **核心知识：**
- OOP三大特性的深入理解
- 类与对象的设计与实现
- 抽象与接口的应用

✨ **设计能力：**
- SOLID设计原则
- 常用设计模式
- 系统架构思维

✨ **实践经验：**
- 项目开发流程
- 代码重构技巧
- 最佳实践方法

记住：**OOP不是银弹，但它是强大的工具。关键在于理解问题本质，选择合适的设计方案。**

---

> **继续学习建议：**
> 
> 🔗 **下一门课程**：数据结构与算法、软件工程
> 
> 💡 **项目实践**：用OOP思想重构之前的项目
> 
> 📚 **深入阅读**：设计模式、代码整洁之道
> 
> 🎓 **Keep Coding, Keep Learning!**
