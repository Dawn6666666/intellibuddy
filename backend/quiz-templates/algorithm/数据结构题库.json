{
  "题库说明": "本题库对应《数据结构 (cs103)》知识点，涵盖算法分析、线性结构、树、图、排序算法和动态规划等内容。",
  "题库": [
    {
      "pointId": "cs103",
      "pointTitle": "数据结构",
      "quiz": [
        {
          "question": "时间复杂度 $O(n)$ 和 $O(2n)$ 的关系是？",
          "type": "single",
          "options": [
            "等价，都简化为 $O(n)$",
            "$O(2n)$ 比 $O(n)$ 慢一倍",
            "$O(n)$ 比 $O(2n)$ 快",
            "无法比较"
          ],
          "correctAnswer": 0,
          "explanation": "在大O表示法中，常数因子可以忽略，因此 $O(2n) = O(n)$。大O表示法关注的是增长趋势而非精确值。"
        },
        {
          "question": "以下时间复杂度从小到大排序正确的是？",
          "type": "single",
          "options": [
            "$O(1) < O(\\\\log n) < O(n) < O(n\\\\log n) < O(n^2)$",
            "$O(1) < O(n) < O(\\\\log n) < O(n^2) < O(n\\\\log n)$",
            "$O(\\\\log n) < O(1) < O(n) < O(n^2) < O(n\\\\log n)$",
            "$O(1) < O(n) < O(n\\\\log n) < O(\\\\log n) < O(n^2)$"
          ],
          "correctAnswer": 0,
          "explanation": "正确的时间复杂度排序是：$O(1) < O(\\\\log n) < O(n) < O(n\\\\log n) < O(n^2) < O(2^n) < O(n!)$"
        },
        {
          "question": "栈的特点是什么？",
          "type": "single",
          "options": [
            "先进后出（LIFO）",
            "先进先出（FIFO）",
            "随机访问",
            "优先级访问"
          ],
          "correctAnswer": 0,
          "explanation": "栈是一种后进先出（LIFO, Last In First Out）的数据结构，只能在栈顶进行插入和删除操作。"
        },
        {
          "question": "队列的特点是什么？",
          "type": "single",
          "options": [
            "先进先出（FIFO）",
            "先进后出（LIFO）",
            "随机访问",
            "双向访问"
          ],
          "correctAnswer": 0,
          "explanation": "队列是一种先进先出（FIFO, First In First Out）的数据结构，在队尾插入元素，在队头删除元素。"
        },
        {
          "question": "关于单链表，以下说法正确的是？",
          "type": "multiple",
          "options": [
            "每个节点包含数据域和指针域",
            "只能从头到尾顺序访问",
            "插入和删除操作不需要移动大量元素",
            "可以随机访问任意位置元素"
          ],
          "correctAnswer": [0, 1, 2],
          "explanation": "单链表的每个节点包含数据和指向下一节点的指针，只能单向遍历，插入删除只需修改指针。但不支持随机访问，访问第i个元素需要从头遍历。"
        },
        {
          "question": "双链表相比单链表的优势是？",
          "type": "single",
          "options": [
            "可以双向遍历",
            "占用内存更少",
            "访问速度更快",
            "不需要头指针"
          ],
          "correctAnswer": 0,
          "explanation": "双链表每个节点有两个指针（前驱和后继），可以双向遍历，但占用内存更多。访问速度与单链表相同，都需要顺序遍历。"
        },
        {
          "question": "二叉树的遍历方式包括哪些？",
          "type": "multiple",
          "options": [
            "前序遍历（根-左-右）",
            "中序遍历（左-根-右）",
            "后序遍历（左-右-根）",
            "层序遍历（逐层）"
          ],
          "correctAnswer": [0, 1, 2, 3],
          "explanation": "二叉树的遍历方式主要有四种：前序（根左右）、中序（左根右）、后序（左右根）和层序遍历（BFS广度优先）。"
        },
        {
          "question": "二叉搜索树（BST）的性质是什么？",
          "type": "single",
          "options": [
            "左子树所有节点值小于根，右子树所有节点值大于根",
            "左子树高度等于右子树高度",
            "所有叶子节点在同一层",
            "每个节点最多有两个子节点"
          ],
          "correctAnswer": 0,
          "explanation": "二叉搜索树的核心性质是：对于任意节点，其左子树所有节点值小于该节点值，右子树所有节点值大于该节点值。这个性质使得BST的中序遍历是有序的。"
        },
        {
          "question": "完全二叉树可以用数组高效存储。",
          "type": "boolean",
          "options": ["正确", "错误"],
          "correctAnswer": 0,
          "explanation": "正确。完全二叉树可以用数组按层序存储，父节点索引为i，则左子节点为2i+1，右子节点为2i+2。这种存储方式不浪费空间且访问效率高。"
        },
        {
          "question": "平衡二叉树（AVL树）的平衡因子是什么？",
          "type": "single",
          "options": [
            "左子树高度减去右子树高度",
            "左子树节点数减去右子树节点数",
            "左子树深度加上右子树深度",
            "左右子树的高度差的绝对值"
          ],
          "correctAnswer": 0,
          "explanation": "AVL树的平衡因子是左子树高度减去右子树高度，其绝对值不超过1。当插入或删除导致平衡因子超过1时，需要进行旋转操作恢复平衡。"
        },
        {
          "question": "图的存储方式包括哪些？",
          "type": "multiple",
          "options": [
            "邻接矩阵",
            "邻接表",
            "链表",
            "堆"
          ],
          "correctAnswer": [0, 1],
          "explanation": "图的两种主要存储方式是邻接矩阵（二维数组）和邻接表（链表数组）。邻接矩阵适合稠密图，邻接表适合稀疏图。链表和堆不是图的专用存储结构。"
        },
        {
          "question": "深度优先搜索（DFS）通常使用什么数据结构实现？",
          "type": "single",
          "options": [
            "栈（或递归）",
            "队列",
            "堆",
            "哈希表"
          ],
          "correctAnswer": 0,
          "explanation": "DFS通常使用栈实现（显式栈或递归调用栈）。每次访问一个节点后，将其未访问的邻居压栈，然后从栈顶取出节点继续访问。"
        },
        {
          "question": "广度优先搜索（BFS）通常使用什么数据结构实现？",
          "type": "single",
          "options": [
            "队列",
            "栈",
            "堆",
            "链表"
          ],
          "correctAnswer": 0,
          "explanation": "BFS使用队列实现。从起点开始，将其加入队列，然后循环：取出队头元素，访问其所有未访问的邻居并加入队尾。这样可以保证按层次（距离）顺序访问节点。"
        },
        {
          "question": "最短路径算法Dijkstra适用于哪种图？",
          "type": "single",
          "options": [
            "非负权重的图",
            "有负权重的图",
            "无向图",
            "所有类型的图"
          ],
          "correctAnswer": 0,
          "explanation": "Dijkstra算法只适用于非负权重的图。如果图中有负权重边，应该使用Bellman-Ford算法。对于有负权重环的图，最短路径可能不存在。"
        },
        {
          "question": "冒泡排序的时间复杂度是？",
          "type": "single",
          "options": [
            "平均 $O(n^2)$，最好 $O(n)$，最坏 $O(n^2)$",
            "平均 $O(n\\\\log n)$，最好 $O(n)$，最坏 $O(n^2)$",
            "平均 $O(n)$，最好 $O(n)$，最坏 $O(n)$",
            "平均 $O(n^2)$，最好 $O(n^2)$，最坏 $O(n^2)$"
          ],
          "correctAnswer": 0,
          "explanation": "冒泡排序平均和最坏情况都是 $O(n^2)$。最好情况（已排序）可以优化到 $O(n)$（通过添加标志位检测是否发生交换）。"
        },
        {
          "question": "快速排序的平均时间复杂度是？",
          "type": "single",
          "options": [
            "$O(n\\\\log n)$",
            "$O(n^2)$",
            "$O(n)$",
            "$O(\\\\log n)$"
          ],
          "correctAnswer": 0,
          "explanation": "快速排序的平均时间复杂度是 $O(n\\\\log n)$，但最坏情况（每次选到最大或最小元素作为pivot）是 $O(n^2)$。通过随机选择pivot或三数取中可以避免最坏情况。"
        },
        {
          "question": "哪些排序算法是稳定的？",
          "type": "multiple",
          "options": [
            "归并排序",
            "冒泡排序",
            "插入排序",
            "快速排序",
            "堆排序"
          ],
          "correctAnswer": [0, 1, 2],
          "explanation": "稳定排序算法：归并排序、冒泡排序、插入排序。不稳定排序：快速排序、堆排序、选择排序。稳定性是指相等元素的相对顺序在排序后保持不变。"
        },
        {
          "question": "归并排序的空间复杂度是？",
          "type": "single",
          "options": [
            "$O(n)$",
            "$O(1)$",
            "$O(\\\\log n)$",
            "$O(n^2)$"
          ],
          "correctAnswer": 0,
          "explanation": "归并排序需要额外的 $O(n)$ 空间来存储合并过程中的临时数组。虽然时间复杂度优秀（$O(n\\\\log n)$），但空间复杂度较高，不是原地排序。"
        },
        {
          "question": "堆排序使用什么数据结构？",
          "type": "single",
          "options": [
            "二叉堆",
            "二叉搜索树",
            "AVL树",
            "红黑树"
          ],
          "correctAnswer": 0,
          "explanation": "堆排序使用二叉堆（通常是最大堆或最小堆）。堆是一种完全二叉树，满足堆性质：父节点的值大于（或小于）其子节点。"
        },
        {
          "question": "动态规划的核心思想是什么？",
          "type": "multiple",
          "options": [
            "将问题分解为子问题",
            "保存子问题的解避免重复计算",
            "最优子结构性质",
            "分治算法"
          ],
          "correctAnswer": [0, 1, 2],
          "explanation": "动态规划的核心：1) 将问题分解为重叠子问题；2) 保存子问题的解（记忆化）避免重复计算；3) 利用最优子结构推导原问题的解。虽然与分治有关，但分治的子问题通常不重叠。"
        },
        {
          "question": "斐波那契数列使用动态规划求解的时间复杂度是？",
          "type": "single",
          "options": [
            "$O(n)$",
            "$O(2^n)$",
            "$O(n^2)$",
            "$O(\\\\log n)$"
          ],
          "correctAnswer": 0,
          "explanation": "使用动态规划（或记忆化递归）求斐波那契数列，时间复杂度是 $O(n)$，空间复杂度也是 $O(n)$（可优化到 $O(1)$）。朴素递归的时间复杂度是 $O(2^n)$。"
        },
        {
          "question": "0-1背包问题的状态转移方程中，dp[i][j]表示什么？",
          "type": "single",
          "options": [
            "前i个物品，容量为j时的最大价值",
            "第i个物品的价值",
            "容量为j时可以放入的物品数量",
            "第i个物品的重量"
          ],
          "correctAnswer": 0,
          "explanation": "在0-1背包问题中，dp[i][j]表示考虑前i个物品，背包容量为j时能获得的最大价值。状态转移方程为：dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])。"
        },
        {
          "question": "哈希表的平均查找时间复杂度是？",
          "type": "single",
          "options": [
            "$O(1)$",
            "$O(\\\\log n)$",
            "$O(n)$",
            "$O(n^2)$"
          ],
          "correctAnswer": 0,
          "explanation": "哈希表的平均查找、插入、删除时间复杂度都是 $O(1)$。但最坏情况（所有元素都哈希到同一位置）是 $O(n)$。好的哈希函数和合适的负载因子可以避免最坏情况。"
        },
        {
          "question": "解决哈希冲突的方法包括哪些？",
          "type": "multiple",
          "options": [
            "链地址法（拉链法）",
            "开放寻址法",
            "再哈希法",
            "排序法"
          ],
          "correctAnswer": [0, 1, 2],
          "explanation": "常见的哈希冲突解决方法：1) 链地址法（每个位置用链表存储冲突元素）；2) 开放寻址法（探测下一个空位）；3) 再哈希法（使用另一个哈希函数）。排序不是哈希冲突的解决方法。"
        },
        {
          "question": "Trie树（字典树）主要用于什么场景？",
          "type": "single",
          "options": [
            "字符串检索和前缀匹配",
            "数值排序",
            "图的遍历",
            "动态规划"
          ],
          "correctAnswer": 0,
          "explanation": "Trie树是一种树形数据结构，专门用于字符串检索、前缀匹配、自动补全等场景。每个节点代表一个字符，从根到叶的路径表示一个字符串。"
        }
      ]
    }
  ]
}

