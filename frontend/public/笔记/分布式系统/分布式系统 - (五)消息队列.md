# 分布式系统 - (五)消息队列

掌握消息中间件技术。

---

## 5. 消息队列

### 5.1 发布-订阅模式

```python
import queue
import threading

class MessageBroker:
    """简单消息代理"""
    def __init__(self):
        self.topics = {}  # topic -> [queue1, queue2, ...]
        self.lock = threading.Lock()
    
    def subscribe(self, topic, subscriber_id):
        """订阅主题"""
        with self.lock:
            if topic not in self.topics:
                self.topics[topic] = {}
            
            if subscriber_id not in self.topics[topic]:
                self.topics[topic][subscriber_id] = queue.Queue()
                print(f"✅ {subscriber_id} 订阅主题: {topic}")
    
    def publish(self, topic, message):
        """发布消息"""
        with self.lock:
            if topic not in self.topics:
                print(f"⚠️  主题不存在: {topic}")
                return
            
            # 发送到所有订阅者
            for subscriber_id, q in self.topics[topic].items():
                q.put(message)
            
            print(f"📤 发布消息到 {topic}: {message}")
    
    def consume(self, topic, subscriber_id, timeout=1):
        """消费消息"""
        if topic in self.topics and subscriber_id in self.topics[topic]:
            try:
                message = self.topics[topic][subscriber_id].get(timeout=timeout)
                return message
            except queue.Empty:
                return None
        return None

# 测试消息队列
broker = MessageBroker()

# 订阅
broker.subscribe('orders', 'inventory-service')
broker.subscribe('orders', 'notification-service')

# 发布
broker.publish('orders', {'order_id': 123, 'amount': 100})

# 消费
msg1 = broker.consume('orders', 'inventory-service')
msg2 = broker.consume('orders', 'notification-service')

print(f"📨 inventory收到: {msg1}")
print(f"📨 notification收到: {msg2}")
```

---

**本章完**
