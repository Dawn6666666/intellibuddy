# åˆ†å¸ƒå¼ç³»ç»Ÿ - (äº”)æ¶ˆæ¯é˜Ÿåˆ—

æŒæ¡æ¶ˆæ¯ä¸­é—´ä»¶æŠ€æœ¯ã€‚

---

## 5. æ¶ˆæ¯é˜Ÿåˆ—

### 5.1 å‘å¸ƒ-è®¢é˜…æ¨¡å¼

```python
import queue
import threading

class MessageBroker:
    """ç®€å•æ¶ˆæ¯ä»£ç†"""
    def __init__(self):
        self.topics = {}  # topic -> [queue1, queue2, ...]
        self.lock = threading.Lock()
    
    def subscribe(self, topic, subscriber_id):
        """è®¢é˜…ä¸»é¢˜"""
        with self.lock:
            if topic not in self.topics:
                self.topics[topic] = {}
            
            if subscriber_id not in self.topics[topic]:
                self.topics[topic][subscriber_id] = queue.Queue()
                print(f"âœ… {subscriber_id} è®¢é˜…ä¸»é¢˜: {topic}")
    
    def publish(self, topic, message):
        """å‘å¸ƒæ¶ˆæ¯"""
        with self.lock:
            if topic not in self.topics:
                print(f"âš ï¸  ä¸»é¢˜ä¸å­˜åœ¨: {topic}")
                return
            
            # å‘é€åˆ°æ‰€æœ‰è®¢é˜…è€…
            for subscriber_id, q in self.topics[topic].items():
                q.put(message)
            
            print(f"ğŸ“¤ å‘å¸ƒæ¶ˆæ¯åˆ° {topic}: {message}")
    
    def consume(self, topic, subscriber_id, timeout=1):
        """æ¶ˆè´¹æ¶ˆæ¯"""
        if topic in self.topics and subscriber_id in self.topics[topic]:
            try:
                message = self.topics[topic][subscriber_id].get(timeout=timeout)
                return message
            except queue.Empty:
                return None
        return None

# æµ‹è¯•æ¶ˆæ¯é˜Ÿåˆ—
broker = MessageBroker()

# è®¢é˜…
broker.subscribe('orders', 'inventory-service')
broker.subscribe('orders', 'notification-service')

# å‘å¸ƒ
broker.publish('orders', {'order_id': 123, 'amount': 100})

# æ¶ˆè´¹
msg1 = broker.consume('orders', 'inventory-service')
msg2 = broker.consume('orders', 'notification-service')

print(f"ğŸ“¨ inventoryæ”¶åˆ°: {msg1}")
print(f"ğŸ“¨ notificationæ”¶åˆ°: {msg2}")
```

---

**æœ¬ç« å®Œ**
