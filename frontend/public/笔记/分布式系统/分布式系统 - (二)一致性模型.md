# åˆ†å¸ƒå¼ç³»ç»Ÿ - (äºŒ)ä¸€è‡´æ€§æ¨¡å‹

æŒæ¡åˆ†å¸ƒå¼ä¸€è‡´æ€§ã€‚

---

## 2. ä¸€è‡´æ€§æ¨¡å‹

### 2.1 æœ€ç»ˆä¸€è‡´æ€§

```python
import time
import threading
from collections import defaultdict

class EventualConsistency:
    def __init__(self):
        self.nodes = {
            'node1': {'data': {}, 'vector_clock': defaultdict(int)},
            'node2': {'data': {}, 'vector_clock': defaultdict(int)},
            'node3': {'data': {}, 'vector_clock': defaultdict(int)}
        }
        self.message_queue = []
        self.running = True
    
    def write(self, node_id, key, value):
        """å†™æ“ä½œ"""
        node = self.nodes[node_id]
        
        # æ›´æ–°å‘é‡æ—¶é’Ÿ
        node['vector_clock'][node_id] += 1
        
        # æœ¬åœ°å†™å…¥
        node['data'][key] = {
            'value': value,
            'timestamp': time.time(),
            'vector_clock': dict(node['vector_clock'])
        }
        
        # å¼‚æ­¥å¤åˆ¶åˆ°å…¶ä»–èŠ‚ç‚¹
        for other_node in self.nodes:
            if other_node != node_id:
                self.message_queue.append({
                    'type': 'replicate',
                    'from': node_id,
                    'to': other_node,
                    'key': key,
                    'data': node['data'][key]
                })
        
        print(f"âœ… {node_id}å†™å…¥: {key}={value}")
    
    def read(self, node_id, key):
        """è¯»æ“ä½œ"""
        node = self.nodes[node_id]
        if key in node['data']:
            return node['data'][key]['value']
        return None
    
    def process_messages(self):
        """å¤„ç†å¤åˆ¶æ¶ˆæ¯"""
        while self.message_queue:
            msg = self.message_queue.pop(0)
            
            if msg['type'] == 'replicate':
                target_node = self.nodes[msg['to']]
                key = msg['key']
                data = msg['data']
                
                # æ£€æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°ï¼ˆåŸºäºå‘é‡æ—¶é’Ÿï¼‰
                if (key not in target_node['data'] or 
                    self.is_newer(data['vector_clock'], 
                                 target_node['data'].get(key, {}).get('vector_clock', {}))):
                    
                    target_node['data'][key] = data
                    print(f"ğŸ”„ {msg['to']}å¤åˆ¶: {key}={data['value']}")
    
    def is_newer(self, clock1, clock2):
        """æ¯”è¾ƒå‘é‡æ—¶é’Ÿ"""
        for node in clock1:
            if clock1[node] > clock2.get(node, 0):
                return True
        return False
    
    def show_state(self):
        """æ˜¾ç¤ºæ‰€æœ‰èŠ‚ç‚¹çŠ¶æ€"""
        print("\nğŸ“Š ç³»ç»ŸçŠ¶æ€:")
        for node_id, node in self.nodes.items():
            print(f"{node_id}: {node['data']}")

# æµ‹è¯•æœ€ç»ˆä¸€è‡´æ€§
ec = EventualConsistency()

# å¹¶å‘å†™å…¥
ec.write('node1', 'x', 100)
ec.write('node2', 'y', 200)

print("\nå¤„ç†å¤åˆ¶å‰:")
ec.show_state()

# å¤„ç†å¤åˆ¶æ¶ˆæ¯
ec.process_messages()

print("\nå¤„ç†å¤åˆ¶å:")
ec.show_state()
```

### 2.2 Raftå…±è¯†ç®—æ³•

```python
import random
import time

class RaftNode:
    def __init__(self, node_id, peers):
        self.node_id = node_id
        self.peers = peers
        self.state = 'follower'  # follower, candidate, leader
        
        # æŒä¹…åŒ–çŠ¶æ€
        self.current_term = 0
        self.voted_for = None
        self.log = []  # [(term, command), ...]
        
        # æ˜“å¤±çŠ¶æ€
        self.commit_index = 0
        self.last_applied = 0
        
        # LeaderçŠ¶æ€
        self.next_index = {}
        self.match_index = {}
        
        self.election_timeout = random.uniform(150, 300)  # ms
        self.last_heartbeat = time.time()
    
    def start_election(self):
        """å¼€å§‹é€‰ä¸¾"""
        self.state = 'candidate'
        self.current_term += 1
        self.voted_for = self.node_id
        
        votes = 1  # æŠ•ç¥¨ç»™è‡ªå·±
        
        print(f"ğŸ—³ï¸  {self.node_id} å¼€å§‹é€‰ä¸¾ (term {self.current_term})")
        
        # å‘å…¶ä»–èŠ‚ç‚¹è¯·æ±‚æŠ•ç¥¨
        for peer in self.peers:
            if self.request_vote(peer):
                votes += 1
        
        # æ£€æŸ¥æ˜¯å¦è·å¾—å¤šæ•°ç¥¨
        if votes > len(self.peers) // 2:
            self.become_leader()
        else:
            self.state = 'follower'
    
    def request_vote(self, peer):
        """è¯·æ±‚æŠ•ç¥¨ï¼ˆæ¨¡æ‹Ÿï¼‰"""
        # ç®€åŒ–ï¼šéšæœºå†³å®šæ˜¯å¦è·å¾—æŠ•ç¥¨
        return random.random() > 0.3
    
    def become_leader(self):
        """æˆä¸ºLeader"""
        self.state = 'leader'
        print(f"ğŸ‘‘ {self.node_id} æˆä¸ºLeader (term {self.current_term})")
        
        # åˆå§‹åŒ–LeaderçŠ¶æ€
        for peer in self.peers:
            self.next_index[peer] = len(self.log)
            self.match_index[peer] = 0
    
    def append_entries(self, entries):
        """è¿½åŠ æ—¥å¿—æ¡ç›®"""
        if self.state != 'leader':
            return False
        
        for entry in entries:
            self.log.append((self.current_term, entry))
        
        print(f"ğŸ“ Leader {self.node_id} è¿½åŠ æ—¥å¿—: {entries}")
        
        # å¤åˆ¶åˆ°Followersï¼ˆç®€åŒ–ï¼‰
        return self.replicate_log()
    
    def replicate_log(self):
        """å¤åˆ¶æ—¥å¿—åˆ°Followers"""
        success_count = 1  # Leaderè‡ªå·±
        
        for peer in self.peers:
            if self.send_append_entries(peer):
                success_count += 1
        
        # æ£€æŸ¥æ˜¯å¦è·å¾—å¤šæ•°ç¡®è®¤
        if success_count > len(self.peers) // 2:
            self.commit_index = len(self.log) - 1
            return True
        
        return False
    
    def send_append_entries(self, peer):
        """å‘é€AppendEntries RPCï¼ˆæ¨¡æ‹Ÿï¼‰"""
        return random.random() > 0.2  # 80%æˆåŠŸç‡
    
    def check_election_timeout(self):
        """æ£€æŸ¥é€‰ä¸¾è¶…æ—¶"""
        if (self.state == 'follower' and 
            time.time() - self.last_heartbeat > self.election_timeout / 1000):
            self.start_election()

# Rafté›†ç¾¤
class RaftCluster:
    def __init__(self, node_count=5):
        self.nodes = {}
        node_ids = [f"node{i}" for i in range(node_count)]
        
        for node_id in node_ids:
            peers = [n for n in node_ids if n != node_id]
            self.nodes[node_id] = RaftNode(node_id, peers)
    
    def simulate_election(self):
        """æ¨¡æ‹Ÿé€‰ä¸¾è¿‡ç¨‹"""
        # éšæœºé€‰æ‹©ä¸€ä¸ªèŠ‚ç‚¹å¼€å§‹é€‰ä¸¾
        candidate = random.choice(list(self.nodes.values()))
        candidate.start_election()
    
    def get_leader(self):
        """è·å–å½“å‰Leader"""
        for node in self.nodes.values():
            if node.state == 'leader':
                return node
        return None

# æµ‹è¯•Raft
cluster = RaftCluster(5)
cluster.simulate_election()

leader = cluster.get_leader()
if leader:
    leader.append_entries(['command1', 'command2'])
```

---

**æœ¬ç« å®Œ**
