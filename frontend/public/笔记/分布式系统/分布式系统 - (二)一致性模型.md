# 分布式系统 - (二)一致性模型

掌握分布式一致性。

---

## 2. 一致性模型

### 2.1 最终一致性

```python
import time
import threading
from collections import defaultdict

class EventualConsistency:
    def __init__(self):
        self.nodes = {
            'node1': {'data': {}, 'vector_clock': defaultdict(int)},
            'node2': {'data': {}, 'vector_clock': defaultdict(int)},
            'node3': {'data': {}, 'vector_clock': defaultdict(int)}
        }
        self.message_queue = []
        self.running = True
    
    def write(self, node_id, key, value):
        """写操作"""
        node = self.nodes[node_id]
        
        # 更新向量时钟
        node['vector_clock'][node_id] += 1
        
        # 本地写入
        node['data'][key] = {
            'value': value,
            'timestamp': time.time(),
            'vector_clock': dict(node['vector_clock'])
        }
        
        # 异步复制到其他节点
        for other_node in self.nodes:
            if other_node != node_id:
                self.message_queue.append({
                    'type': 'replicate',
                    'from': node_id,
                    'to': other_node,
                    'key': key,
                    'data': node['data'][key]
                })
        
        print(f"✅ {node_id}写入: {key}={value}")
    
    def read(self, node_id, key):
        """读操作"""
        node = self.nodes[node_id]
        if key in node['data']:
            return node['data'][key]['value']
        return None
    
    def process_messages(self):
        """处理复制消息"""
        while self.message_queue:
            msg = self.message_queue.pop(0)
            
            if msg['type'] == 'replicate':
                target_node = self.nodes[msg['to']]
                key = msg['key']
                data = msg['data']
                
                # 检查是否需要更新（基于向量时钟）
                if (key not in target_node['data'] or 
                    self.is_newer(data['vector_clock'], 
                                 target_node['data'].get(key, {}).get('vector_clock', {}))):
                    
                    target_node['data'][key] = data
                    print(f"🔄 {msg['to']}复制: {key}={data['value']}")
    
    def is_newer(self, clock1, clock2):
        """比较向量时钟"""
        for node in clock1:
            if clock1[node] > clock2.get(node, 0):
                return True
        return False
    
    def show_state(self):
        """显示所有节点状态"""
        print("\n📊 系统状态:")
        for node_id, node in self.nodes.items():
            print(f"{node_id}: {node['data']}")

# 测试最终一致性
ec = EventualConsistency()

# 并发写入
ec.write('node1', 'x', 100)
ec.write('node2', 'y', 200)

print("\n处理复制前:")
ec.show_state()

# 处理复制消息
ec.process_messages()

print("\n处理复制后:")
ec.show_state()
```

### 2.2 Raft共识算法

```python
import random
import time

class RaftNode:
    def __init__(self, node_id, peers):
        self.node_id = node_id
        self.peers = peers
        self.state = 'follower'  # follower, candidate, leader
        
        # 持久化状态
        self.current_term = 0
        self.voted_for = None
        self.log = []  # [(term, command), ...]
        
        # 易失状态
        self.commit_index = 0
        self.last_applied = 0
        
        # Leader状态
        self.next_index = {}
        self.match_index = {}
        
        self.election_timeout = random.uniform(150, 300)  # ms
        self.last_heartbeat = time.time()
    
    def start_election(self):
        """开始选举"""
        self.state = 'candidate'
        self.current_term += 1
        self.voted_for = self.node_id
        
        votes = 1  # 投票给自己
        
        print(f"🗳️  {self.node_id} 开始选举 (term {self.current_term})")
        
        # 向其他节点请求投票
        for peer in self.peers:
            if self.request_vote(peer):
                votes += 1
        
        # 检查是否获得多数票
        if votes > len(self.peers) // 2:
            self.become_leader()
        else:
            self.state = 'follower'
    
    def request_vote(self, peer):
        """请求投票（模拟）"""
        # 简化：随机决定是否获得投票
        return random.random() > 0.3
    
    def become_leader(self):
        """成为Leader"""
        self.state = 'leader'
        print(f"👑 {self.node_id} 成为Leader (term {self.current_term})")
        
        # 初始化Leader状态
        for peer in self.peers:
            self.next_index[peer] = len(self.log)
            self.match_index[peer] = 0
    
    def append_entries(self, entries):
        """追加日志条目"""
        if self.state != 'leader':
            return False
        
        for entry in entries:
            self.log.append((self.current_term, entry))
        
        print(f"📝 Leader {self.node_id} 追加日志: {entries}")
        
        # 复制到Followers（简化）
        return self.replicate_log()
    
    def replicate_log(self):
        """复制日志到Followers"""
        success_count = 1  # Leader自己
        
        for peer in self.peers:
            if self.send_append_entries(peer):
                success_count += 1
        
        # 检查是否获得多数确认
        if success_count > len(self.peers) // 2:
            self.commit_index = len(self.log) - 1
            return True
        
        return False
    
    def send_append_entries(self, peer):
        """发送AppendEntries RPC（模拟）"""
        return random.random() > 0.2  # 80%成功率
    
    def check_election_timeout(self):
        """检查选举超时"""
        if (self.state == 'follower' and 
            time.time() - self.last_heartbeat > self.election_timeout / 1000):
            self.start_election()

# Raft集群
class RaftCluster:
    def __init__(self, node_count=5):
        self.nodes = {}
        node_ids = [f"node{i}" for i in range(node_count)]
        
        for node_id in node_ids:
            peers = [n for n in node_ids if n != node_id]
            self.nodes[node_id] = RaftNode(node_id, peers)
    
    def simulate_election(self):
        """模拟选举过程"""
        # 随机选择一个节点开始选举
        candidate = random.choice(list(self.nodes.values()))
        candidate.start_election()
    
    def get_leader(self):
        """获取当前Leader"""
        for node in self.nodes.values():
            if node.state == 'leader':
                return node
        return None

# 测试Raft
cluster = RaftCluster(5)
cluster.simulate_election()

leader = cluster.get_leader()
if leader:
    leader.append_entries(['command1', 'command2'])
```

---

**本章完**
