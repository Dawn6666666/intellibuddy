# 分布式系统 - (六)分布式事务

学习分布式事务处理。

---

## 6. 分布式事务

### 6.1 两阶段提交（2PC）

```python
class TwoPhaseCommit:
    """两阶段提交协调器"""
    def __init__(self):
        self.participants = []
    
    def add_participant(self, participant):
        """添加参与者"""
        self.participants.append(participant)
    
    def execute(self, transaction):
        """执行分布式事务"""
        print(f"\n🔄 开始分布式事务: {transaction}")
        
        # Phase 1: Prepare
        print("\n📋 Phase 1: Prepare")
        prepared = []
        
        for participant in self.participants:
            if participant.prepare(transaction):
                prepared.append(participant)
                print(f"  ✅ {participant.name} 准备完成")
            else:
                print(f"  ❌ {participant.name} 准备失败")
                # 回滚已准备的参与者
                for p in prepared:
                    p.rollback()
                return False
        
        # Phase 2: Commit
        print("\n📋 Phase 2: Commit")
        for participant in self.participants:
            participant.commit()
            print(f"  ✅ {participant.name} 提交完成")
        
        print("\n✅ 分布式事务成功")
        return True

class Participant:
    """参与者"""
    def __init__(self, name):
        self.name = name
        self.prepared_tx = None
    
    def prepare(self, transaction):
        """准备阶段"""
        # 模拟准备工作
        self.prepared_tx = transaction
        return True  # 简化：总是成功
    
    def commit(self):
        """提交阶段"""
        self.prepared_tx = None
    
    def rollback(self):
        """回滚"""
        self.prepared_tx = None

# 测试2PC
coordinator = TwoPhaseCommit()
coordinator.add_participant(Participant("账户服务"))
coordinator.add_participant(Participant("库存服务"))
coordinator.add_participant(Participant("订单服务"))

coordinator.execute("转账100元")
```

### 6.2 Saga模式

```python
class SagaOrchestrator:
    """Saga编排器"""
    def __init__(self):
        self.steps = []
        self.compensations = []
    
    def add_step(self, action, compensation):
        """添加步骤"""
        self.steps.append(action)
        self.compensations.append(compensation)
    
    def execute(self):
        """执行Saga"""
        executed_steps = []
        
        try:
            for i, step in enumerate(self.steps):
                print(f"🔄 执行步骤 {i+1}: {step.__name__}")
                step()
                executed_steps.append(i)
            
            print("✅ Saga成功完成")
            return True
        
        except Exception as e:
            print(f"❌ 步骤失败: {e}")
            
            # 执行补偿操作
            for i in reversed(executed_steps):
                print(f"↩️  补偿步骤 {i+1}: {self.compensations[i].__name__}")
                self.compensations[i]()
            
            print("✅ 补偿完成")
            return False

# 订单Saga示例
def create_order():
    print("  创建订单")

def reserve_inventory():
    print("  预留库存")
    # raise Exception("库存不足")  # 模拟失败

def deduct_balance():
    print("  扣减余额")

def cancel_order():
    print("  取消订单")

def release_inventory():
    print("  释放库存")

def refund_balance():
    print("  退还余额")

# 执行Saga
saga = SagaOrchestrator()
saga.add_step(create_order, cancel_order)
saga.add_step(reserve_inventory, release_inventory)
saga.add_step(deduct_balance, refund_balance)

saga.execute()
```

---

## 📚 学习建议

### 实践项目推荐

**基础级（2-4周）**
1. **分布式缓存** - Redis Cluster搭建
2. **服务注册与发现** - Consul/Etcd实践
3. **负载均衡** - Nginx/HAProxy配置

**进阶级（1-2月）**
1. **微服务电商系统** - Spring Cloud全家桶
2. **分布式消息系统** - Kafka/RabbitMQ
3. **分布式存储** - HDFS/Ceph
4. **分布式数据库** - TiDB/CockroachDB

**高级项目（2-3月）**
1. **自研分布式框架** - RPC/配置中心
2. **分布式搜索引擎** - Elasticsearch集群
3. **流计算平台** - Flink/Storm
4. **容器编排** - Kubernetes深度实践

### 推荐资源

📖 **经典教材：**
- 《分布式系统原理与范型》- Tanenbaum
- 《设计数据密集型应用》（DDIA）- Martin Kleppmann
- 《大规模分布式存储系统》- 杨传辉

💻 **在线课程：**
- **MIT 6.824** - Distributed Systems
- **极客时间《分布式协议与算法实战》**
- **从零开始学架构** - 李运华

📄 **必读论文：**
- **CAP定理** - Eric Brewer (2000)
- **MapReduce** - Google (2004)
- **BigTable** - Google (2006)
- **Dynamo** - Amazon (2007)
- **Raft** - Diego Ongaro (2013)
- **Paxos** - Leslie Lamport (1998)
- **Spanner** - Google (2012)

### 核心技术栈

**服务注册与发现**
- **Consul** - HashiCorp服务网格
- **Etcd** - 分布式键值存储
- **ZooKeeper** - Apache协调服务
- **Nacos** - 阿里云服务治理

**消息队列**
- **Apache Kafka** - 高吞吐量消息系统
- **RabbitMQ** - AMQP协议实现
- **RocketMQ** - 阿里云消息中间件
- **Pulsar** - Apache流数据平台

**分布式存储**
- **HDFS** - Hadoop分布式文件系统
- **Ceph** - 统一存储系统
- **MinIO** - 对象存储
- **GlusterFS** - 网络文件系统

**容器与编排**
- **Docker** - 容器化技术
- **Kubernetes** - 容器编排
- **Docker Swarm** - Docker集群
- **Nomad** - HashiCorp调度器

**服务网格**
- **Istio** - 服务网格控制平面
- **Linkerd** - 轻量级服务网格
- **Consul Connect** - 服务网格解决方案

### 学习路线（12周计划）

**第1-2周：分布式基础**
- ✅ CAP定理、BASE理论
- ✅ 一致性模型（强一致性、最终一致性）
- ✅ 时间与顺序（向量时钟、逻辑时钟）
- ✅ 分布式ID生成（雪花算法）

**第3-4周：共识算法**
- ✅ Paxos算法原理
- ✅ Raft算法详解
- ✅ ZAB协议（ZooKeeper）
- ✅ 实战：自己实现Raft

**第5-6周：分布式存储**
- ✅ 一致性哈希
- ✅ 分布式文件系统（HDFS）
- ✅ 分布式数据库（NewSQL）
- ✅ 数据分片与复制

**第7-8周：微服务架构**
- ✅ 服务拆分原则
- ✅ API网关（Kong/Gateway）
- ✅ 配置中心（Apollo/Nacos）
- ✅ 链路追踪（Jaeger/Zipkin）

**第9-10周：分布式事务**
- ✅ 两阶段提交（2PC）
- ✅ 三阶段提交（3PC）
- ✅ Saga模式
- ✅ TCC（Try-Confirm-Cancel）

**第11-12周：高级主题**
- ✅ 分布式锁（Redis/ZK）
- ✅ 分布式缓存（Redis Cluster）
- ✅ 消息队列（Kafka深度）
- ✅ 性能优化与故障排查

### 面试高频题

**基础概念**
1. CAP定理是什么？如何取舍？
2. 最终一致性如何保证？
3. 分布式系统的挑战有哪些？
4. 什么是脑裂（Split-Brain）？如何解决？
5. BASE理论和ACID的区别？

**共识算法**
1. Raft和Paxos的区别？
2. Raft的Leader选举流程？
3. 如何保证日志一致性？
4. ZooKeeper的ZAB协议原理？

**分布式存储**
1. 一致性哈希的优势？
2. 数据分片策略有哪些？
3. 主从复制和多主复制的区别？
4. 如何处理数据倾斜？

**微服务**
1. 服务拆分的原则？
2. 如何实现服务发现？
3. 熔断器的作用？
4. 限流算法有哪些？（令牌桶、漏桶）

**分布式事务**
1. 2PC的缺点？
2. Saga模式适用场景？
3. TCC和Saga的区别？
4. 如何避免补偿操作失败？

### 常见问题与解决方案

**问题1：分布式锁死锁**
- ❌ 忘记设置过期时间
- ✅ 使用Redlock算法或ZooKeeper

**问题2：缓存穿透/雪崩**
- ❌ 不设置缓存过期时间
- ✅ 布隆过滤器 + 缓存预热 + 限流

**问题3：消息丢失**
- ❌ 不做持久化
- ✅ 开启Kafka的acks=all + 副本机制

**问题4：服务雪崩**
- ❌ 没有熔断机制
- ✅ Hystrix/Resilience4j熔断降级

**问题5：数据不一致**
- ❌ 依赖分布式事务
- ✅ 最终一致性 + 补偿机制

### 最佳实践

**高可用设计**
```
1. 多副本（3副本起步）
2. 跨可用区部署
3. 健康检查和自动故障转移
4. 限流、降级、熔断三板斧
5. 灰度发布和金丝雀部署
```

**性能优化**
```
1. 本地缓存 + 分布式缓存
2. 异步化（消息队列解耦）
3. 批量操作减少网络开销
4. 数据分片和并行处理
5. CDN加速静态资源
```

**监控与运维**
```
1. 日志聚合（ELK Stack）
2. 监控告警（Prometheus + Grafana）
3. 链路追踪（Zipkin/Jaeger）
4. 性能分析（JProfiler/Arthas）
5. 压测和容量规划
```

**安全性**
```
1. 服务间认证（mTLS）
2. API网关鉴权
3. 敏感数据加密
4. 防止DDoS攻击
5. 审计日志
```

---

## 💡 学习心得

> **重要提醒**：
> - 🌐 **网络不可靠** - 永远假设网络会故障
> - ⏱️  **时间不可信** - 分布式时钟不同步
> - 💥 **节点会故障** - 设计时考虑容错
> - 📊 **一致性有代价** - 强一致性牺牲性能
> - 🔧 **监控很重要** - 看不见就无法优化
> 
> **设计原则**：
> - 尽可能避免分布式（能单机就单机）
> - 异步优于同步（解耦提升性能）
> - 幂等性设计（重试不影响结果）
> - 优雅降级（部分失败不影响整体）
> - 自动化运维（减少人工介入）
> 
> **学习建议**：
> - 先理解理论（CAP、一致性算法）
> - 再动手实践（搭建集群、压测）
> - 阅读优秀开源项目源码（Kafka、Redis）
> - 参与实际项目（积累踩坑经验）
> - 关注大厂技术博客（学习最佳实践）

---

> **记住**：分布式系统是现代互联网的基石！理论+实践=掌握核心竞争力！🌐🚀

---

**本章完**
