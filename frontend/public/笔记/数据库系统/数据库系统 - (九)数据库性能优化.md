# 数据库系统 - (九)数据库性能优化

掌握数据库调优。

---

## 9. 数据库性能优化

### 9.1 缓存策略

```python
import time
from functools import wraps

class QueryCache:
    """
    查询缓存（Redis实现）
    """
    def __init__(self):
        self.cache = {}  # 简化用字典，实际用Redis
        self.stats = {'hits': 0, 'misses': 0}
    
    def cache_query(self, ttl=60):
        """缓存装饰器"""
        def decorator(func):
            @wraps(func)
            def wrapper(*args, **kwargs):
                # 生成缓存键
                cache_key = f"{func.__name__}:{args}:{kwargs}"
                
                # 检查缓存
                if cache_key in self.cache:
                    entry = self.cache[cache_key]
                    if time.time() - entry['time'] < ttl:
                        self.stats['hits'] += 1
                        print(f"缓存命中: {cache_key}")
                        return entry['value']
                
                # 缓存未命中，执行查询
                self.stats['misses'] += 1
                print(f"缓存未命中: {cache_key}")
                result = func(*args, **kwargs)
                
                # 存入缓存
                self.cache[cache_key] = {
                    'value': result,
                    'time': time.time()
                }
                
                return result
            return wrapper
        return decorator
    
    def invalidate(self, pattern):
        """失效缓存"""
        keys_to_delete = [k for k in self.cache.keys() if pattern in k]
        for key in keys_to_delete:
            del self.cache[key]
        print(f"失效缓存: {len(keys_to_delete)}个")

# 使用示例
cache = QueryCache()

@cache.cache_query(ttl=30)
def get_user_by_id(user_id):
    """模拟数据库查询"""
    time.sleep(0.1)  # 模拟查询延迟
    return {'id': user_id, 'name': f'User{user_id}'}

# 第一次查询（未命中）
user = get_user_by_id(1)

# 第二次查询（命中）
user = get_user_by_id(1)

print(f"缓存统计: {cache.stats}")
```

### 9.2 读写分离

```python
import random

class MasterSlaveDB:
    """
    主从数据库（读写分离）
    """
    def __init__(self, master, slaves):
        self.master = master
        self.slaves = slaves
    
    def execute_write(self, query):
        """写操作（主库）"""
        print(f"[Master] 执行写: {query}")
        return self.master.execute(query)
    
    def execute_read(self, query, use_master=False):
        """读操作（从库）"""
        if use_master:
            print(f"[Master] 执行读: {query}")
            return self.master.execute(query)
        
        # 负载均衡：随机选择从库
        slave = random.choice(self.slaves)
        print(f"[Slave{self.slaves.index(slave)}] 执行读: {query}")
        return slave.execute(query)
    
    def transaction(self, queries):
        """事务（使用主库）"""
        print("[Master] 开始事务")
        results = []
        for query in queries:
            results.append(self.master.execute(query))
        print("[Master] 提交事务")
        return results

class MockDatabase:
    """模拟数据库"""
    def __init__(self, name):
        self.name = name
        self.data = {}
    
    def execute(self, query):
        # 简化的查询执行
        return f"{self.name}: {query}"

# 示例
master = MockDatabase("Master")
slaves = [MockDatabase(f"Slave{i}") for i in range(3)]

db = MasterSlaveDB(master, slaves)

# 写操作
db.execute_write("INSERT INTO users VALUES (1, 'Alice')")

# 读操作（从库）
db.execute_read("SELECT * FROM users WHERE id = 1")
db.execute_read("SELECT * FROM users WHERE id = 1")

# 读操作（主库，强一致性）
db.execute_read("SELECT * FROM users WHERE id = 1", use_master=True)
```

### 9.3 分库分表

```python
class ShardingStrategy:
    """
    分片策略
    """
    def __init__(self, shard_count=4):
        self.shard_count = shard_count
    
    def hash_shard(self, user_id):
        """哈希分片"""
        return user_id % self.shard_count
    
    def range_shard(self, user_id):
        """范围分片"""
        # 假设：0-999→shard0, 1000-1999→shard1, ...
        return user_id // 1000
    
    def get_table_name(self, base_table, user_id):
        """获取分表名"""
        shard_id = self.hash_shard(user_id)
        return f"{base_table}_{shard_id}"
    
    def route_query(self, user_id, query):
        """路由查询到对应分片"""
        shard_id = self.hash_shard(user_id)
        table_name = self.get_table_name('users', user_id)
        
        print(f"路由: user_id={user_id} → shard{shard_id}, table={table_name}")
        return shard_id, table_name.replace('users', query)

# 示例
sharding = ShardingStrategy(shard_count=4)

# 插入
sharding.route_query(1001, "INSERT INTO users VALUES (1001, 'Alice')")
sharding.route_query(2005, "INSERT INTO users VALUES (2005, 'Bob')")

# 查询
sharding.route_query(1001, "SELECT * FROM users WHERE id = 1001")
```

---

**本章完**
