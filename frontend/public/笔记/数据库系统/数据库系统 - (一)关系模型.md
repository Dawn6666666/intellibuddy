# 数据库系统 - (一)关系模型

理解关系数据库基础。

---

## 1. 关系模型

### 1.1 关系代数

| 操作 | 符号 | 说明 |
|------|------|------|
| 选择 | σ | $\sigma_{age>18}(Student)$ |
| 投影 | π | $\pi_{name,age}(Student)$ |
| 连接 | ⋈ | $Student \bowtie_{sid=id} Grade$ |
| 并 | ∪ | $R \cup S$ |
| 差 | - | $R - S$ |
| 笛卡尔积 | × | $R \times S$ |

```python
import pandas as pd

# 示例数据
students = pd.DataFrame({
    'sid': [1, 2, 3],
    'name': ['Alice', 'Bob', 'Charlie'],
    'age': [20, 22, 19]
})

grades = pd.DataFrame({
    'id': [1, 2, 3],
    'course': ['Math', 'CS', 'Math'],
    'score': [95, 88, 92]
})

# 选择
result = students[students['age'] > 19]
print("σ_{age>19}(Student):\n", result)

# 投影
result = students[['name', 'age']]
print("\nπ_{name,age}(Student):\n", result)

# 连接
result = pd.merge(students, grades, left_on='sid', right_on='id')
print("\nStudent ⋈ Grade:\n", result)
```

### 1.2 函数依赖

**函数依赖**（Functional Dependency）是关系模型的重要概念。

#### 1.2.1 基本概念

**定义**：如果在关系 $R$ 中，属性集 $X$ 的值能唯一确定属性集 $Y$ 的值，则称 $Y$ 函数依赖于 $X$，记作 $X \rightarrow Y$。

```python
def check_functional_dependency(relation, X, Y):
    """
    检查函数依赖 X -> Y
    
    参数:
        relation: pandas DataFrame
        X: 决定因素列名列表
        Y: 被决定因素列名列表
    """
    # 按X分组，检查Y是否唯一
    grouped = relation.groupby(X)[Y].nunique()
    
    # 如果所有分组的Y都只有1个唯一值，则X->Y成立
    is_fd = (grouped == 1).all().all()
    
    return is_fd

# 示例
import pandas as pd

data = pd.DataFrame({
    'sid': [1, 2, 3, 1],
    'name': ['Alice', 'Bob', 'Charlie', 'Alice'],
    'age': [20, 22, 19, 20],
    'major': ['CS', 'Math', 'CS', 'CS']
})

print("检查 sid -> name:", check_functional_dependency(data, ['sid'], ['name']))
print("检查 name -> age:", check_functional_dependency(data, ['name'], ['age']))
```

#### 1.2.2 函数依赖的类型

```python
def analyze_functional_dependencies(relation):
    """
    分析函数依赖类型
    """
    print("=" * 60)
    print("函数依赖类型分析")
    print("=" * 60)
    
    examples = [
        ("完全函数依赖", "(sid, cid) → grade", "grade完全依赖于(sid, cid)组合"),
        ("部分函数依赖", "(sid, cid) → sname", "sname只依赖于sid，是部分依赖"),
        ("传递函数依赖", "sid → dept_id → dept_name", "dept_name通过dept_id传递依赖于sid"),
        ("平凡函数依赖", "sid → sid", "属性依赖于自身"),
    ]
    
    for fd_type, example, desc in examples:
        print(f"\n{fd_type}:")
        print(f"  示例: {example}")
        print(f"  说明: {desc}")

analyze_functional_dependencies(None)
```

**输出:**

```plain
============================================================
函数依赖类型分析
============================================================

完全函数依赖:
  示例: (sid, cid) → grade
  说明: grade完全依赖于(sid, cid)组合

部分函数依赖:
  示例: (sid, cid) → sname
  说明: sname只依赖于sid，是部分依赖

传递函数依赖:
  示例: sid → dept_id → dept_name
  说明: dept_name通过dept_id传递依赖于sid

平凡函数依赖:
  示例: sid → sid
  说明: 属性依赖于自身
```

#### 1.2.3 Armstrong公理系统

```python
class ArmstrongAxioms:
    """
    Armstrong公理系统
    用于推导函数依赖
    """
    
    @staticmethod
    def reflexivity(Y, X):
        """
        自反律: 如果 Y ⊆ X，则 X → Y
        """
        return set(Y).issubset(set(X))
    
    @staticmethod
    def augmentation(X, Y, Z):
        """
        增补律: 如果 X → Y，则 XZ → YZ
        """
        # 假设 X → Y 成立
        return (set(X) | set(Z), set(Y) | set(Z))
    
    @staticmethod
    def transitivity(X, Y, Y_prime, Z):
        """
        传递律: 如果 X → Y 且 Y → Z，则 X → Z
        """
        # 检查 Y 和 Y' 是否相同
        if set(Y) == set(Y_prime):
            return (X, Z)
        return None
    
    @staticmethod
    def decomposition(X, Y, Z):
        """
        分解律: 如果 X → YZ，则 X → Y 且 X → Z
        """
        return [(X, Y), (X, Z)]
    
    @staticmethod
    def union(X, Y, X_prime, Z):
        """
        合并律: 如果 X → Y 且 X → Z，则 X → YZ
        """
        if set(X) == set(X_prime):
            return (X, set(Y) | set(Z))
        return None
    
    @staticmethod
    def pseudo_transitivity(X, Y, Y_prime, Z, W):
        """
        伪传递律: 如果 X → Y 且 YW → Z，则 XW → Z
        """
        if set(Y) == set(Y_prime):
            return (set(X) | set(W), Z)
        return None

# 测试
axioms = ArmstrongAxioms()

print("\nArmstrong公理系统示例:")
print("1. 自反律: {A, B} → {A}:", axioms.reflexivity(['A'], ['A', 'B']))
print("2. 增补律: {A} → {B}, 增补C:", axioms.augmentation(['A'], ['B'], ['C']))
print("3. 传递律: {A} → {B}, {B} → {C}:", axioms.transitivity(['A'], ['B'], ['B'], ['C']))
```

### 1.3 关系代数详解

#### 1.3.1 基本操作

```python
import pandas as pd

class RelationalAlgebra:
    """关系代数操作实现"""
    
    @staticmethod
    def select(relation, condition):
        """
        选择操作: σ
        返回满足条件的元组
        """
        return relation.query(condition)
    
    @staticmethod
    def project(relation, attributes):
        """
        投影操作: π
        返回指定属性列
        """
        return relation[attributes].drop_duplicates()
    
    @staticmethod
    def union(R, S):
        """
        并操作: ∪
        要求R和S模式相同
        """
        return pd.concat([R, S]).drop_duplicates()
    
    @staticmethod
    def difference(R, S):
        """
        差操作: -
        返回在R中但不在S中的元组
        """
        merged = R.merge(S, how='left', indicator=True)
        return merged[merged['_merge'] == 'left_only'].drop('_merge', axis=1)
    
    @staticmethod
    def cartesian_product(R, S):
        """
        笛卡尔积: ×
        """
        R['_key'] = 1
        S['_key'] = 1
        result = R.merge(S, on='_key', suffixes=('_R', '_S'))
        return result.drop('_key', axis=1)
    
    @staticmethod
    def natural_join(R, S):
        """
        自然连接: ⋈
        在公共属性上连接
        """
        return pd.merge(R, S)
    
    @staticmethod
    def theta_join(R, S, condition):
        """
        θ连接
        根据条件连接
        """
        # 先笛卡尔积，再选择
        product = RelationalAlgebra.cartesian_product(R, S)
        return product.query(condition)
    
    @staticmethod
    def divide(R, S):
        """
        除操作: ÷
        """
        # 复杂操作，简化实现
        pass

# 测试
ra = RelationalAlgebra()

# 创建测试数据
students = pd.DataFrame({
    'sid': [1, 2, 3, 4],
    'name': ['Alice', 'Bob', 'Charlie', 'David'],
    'age': [20, 22, 19, 21]
})

courses = pd.DataFrame({
    'cid': [101, 102, 103],
    'cname': ['Math', 'CS', 'Physics']
})

enrollments = pd.DataFrame({
    'sid': [1, 1, 2, 3],
    'cid': [101, 102, 101, 103],
    'grade': [95, 88, 92, 85]
})

print("\n选择操作 σ_{age>20}(Students):")
print(ra.select(students, 'age > 20'))

print("\n投影操作 π_{name,age}(Students):")
print(ra.project(students, ['name', 'age']))

print("\n自然连接 Students ⋈ Enrollments:")
print(ra.natural_join(students, enrollments))
```

#### 1.3.2 扩展操作

```python
class ExtendedRelationalAlgebra(RelationalAlgebra):
    """扩展的关系代数操作"""
    
    @staticmethod
    def group_by(relation, group_attrs, agg_funcs):
        """
        分组操作
        
        参数:
            group_attrs: 分组属性
            agg_funcs: 聚合函数字典 {列名: 函数}
        """
        return relation.groupby(group_attrs).agg(agg_funcs).reset_index()
    
    @staticmethod
    def outer_join(R, S, how='left'):
        """
        外连接
        
        参数:
            how: 'left', 'right', 'outer'
        """
        return pd.merge(R, S, how=how)
    
    @staticmethod
    def semi_join(R, S, on):
        """
        半连接: R ⋉ S
        返回R中与S匹配的元组
        """
        return R[R[on].isin(S[on])]
    
    @staticmethod
    def anti_join(R, S, on):
        """
        反连接: R ▷ S
        返回R中与S不匹配的元组
        """
        return R[~R[on].isin(S[on])]

# 测试
era = ExtendedRelationalAlgebra()

print("\n分组聚合:")
result = era.group_by(
    enrollments,
    ['sid'],
    {'grade': ['mean', 'count']}
)
print(result)

print("\n半连接 - 选修了课程的学生:")
print(era.semi_join(students, enrollments, 'sid'))

print("\n反连接 - 没有选修课程的学生:")
print(era.anti_join(students, enrollments, 'sid'))
```

### 1.4 关系演算

关系演算是关系模型的另一种形式化语言。

#### 1.4.1 元组关系演算

```python
def tuple_relational_calculus_examples():
    """
    元组关系演算示例
    """
    print("=" * 60)
    print("元组关系演算 (TRC)")
    print("=" * 60)
    
    examples = [
        {
            "查询": "查找年龄大于20的学生",
            "TRC": "{ t | t ∈ Students ∧ t.age > 20 }",
            "SQL": "SELECT * FROM Students WHERE age > 20"
        },
        {
            "查询": "查找选修了课程101的学生姓名",
            "TRC": "{ t.name | t ∈ Students ∧ ∃e(e ∈ Enrollments ∧ e.sid = t.sid ∧ e.cid = 101) }",
            "SQL": "SELECT name FROM Students WHERE sid IN (SELECT sid FROM Enrollments WHERE cid = 101)"
        },
        {
            "查询": "查找选修了所有课程的学生",
            "TRC": "{ t | t ∈ Students ∧ ∀c(c ∈ Courses → ∃e(e ∈ Enrollments ∧ e.sid = t.sid ∧ e.cid = c.cid)) }",
            "SQL": "SELECT * FROM Students s WHERE NOT EXISTS (SELECT * FROM Courses c WHERE NOT EXISTS (SELECT * FROM Enrollments e WHERE e.sid = s.sid AND e.cid = c.cid))"
        }
    ]
    
    for i, ex in enumerate(examples, 1):
        print(f"\n示例{i}: {ex['查询']}")
        print(f"  TRC: {ex['TRC']}")
        print(f"  SQL: {ex['SQL']}")

tuple_relational_calculus_examples()
```

#### 1.4.2 域关系演算

```python
def domain_relational_calculus_examples():
    """
    域关系演算示例
    """
    print("\n" + "=" * 60)
    print("域关系演算 (DRC)")
    print("=" * 60)
    
    examples = [
        {
            "查询": "查找CS专业的学生",
            "DRC": "{ <sid, name, age, major> | <sid, name, age, major> ∈ Students ∧ major = 'CS' }",
            "SQL": "SELECT sid, name, age, major FROM Students WHERE major = 'CS'"
        },
        {
            "查询": "查找成绩大于90的学生和课程",
            "DRC": "{ <sid, cid> | ∃grade(<sid, cid, grade> ∈ Enrollments ∧ grade > 90) }",
            "SQL": "SELECT sid, cid FROM Enrollments WHERE grade > 90"
        }
    ]
    
    for i, ex in enumerate(examples, 1):
        print(f"\n示例{i}: {ex['查询']}")
        print(f"  DRC: {ex['DRC']}")
        print(f"  SQL: {ex['SQL']}")

domain_relational_calculus_examples()
```

### 1.5 关系完整性约束

```python
class IntegrityConstraints:
    """关系完整性约束"""
    
    @staticmethod
    def check_entity_integrity(relation, primary_key):
        """
        实体完整性: 主键不能为空
        """
        null_count = relation[primary_key].isnull().sum()
        
        if null_count > 0:
            return False, f"主键包含{null_count}个空值"
        
        # 检查唯一性
        duplicate_count = relation[primary_key].duplicated().sum()
        
        if duplicate_count > 0:
            return False, f"主键包含{duplicate_count}个重复值"
        
        return True, "实体完整性检查通过"
    
    @staticmethod
    def check_referential_integrity(child, parent, foreign_key, parent_key):
        """
        参照完整性: 外键必须引用存在的主键
        """
        # 忽略空值
        non_null_fk = child[foreign_key].dropna()
        
        # 检查外键值是否都在父表中
        invalid = non_null_fk[~non_null_fk.isin(parent[parent_key])]
        
        if len(invalid) > 0:
            return False, f"外键包含{len(invalid)}个无效引用"
        
        return True, "参照完整性检查通过"
    
    @staticmethod
    def check_user_defined_integrity(relation, constraints):
        """
        用户定义完整性: 自定义约束
        
        参数:
            constraints: 约束条件列表，如 ['age >= 0', 'age <= 150']
        """
        for constraint in constraints:
            try:
                if not relation.query(constraint).equals(relation):
                    return False, f"约束 '{constraint}' 违反"
            except Exception as e:
                return False, f"约束检查失败: {str(e)}"
        
        return True, "用户定义完整性检查通过"

# 测试
ic = IntegrityConstraints()

# 测试数据
students = pd.DataFrame({
    'sid': [1, 2, 3],
    'name': ['Alice', 'Bob', 'Charlie'],
    'age': [20, 22, 19]
})

enrollments = pd.DataFrame({
    'eid': [1, 2, 3],
    'sid': [1, 2, 5],  # 5是无效外键
    'grade': [95, 88, 92]
})

print("\n完整性约束检查:")
print("1. 实体完整性:", ic.check_entity_integrity(students, 'sid'))
print("2. 参照完整性:", ic.check_referential_integrity(enrollments, students, 'sid', 'sid'))
print("3. 用户定义完整性:", ic.check_user_defined_integrity(students, ['age >= 0', 'age <= 150']))
```

### 1.6 关系模型理论总结

```python
def relational_model_summary():
    """
    关系模型理论总结
    """
    print("=" * 70)
    print("关系模型理论总结")
    print("=" * 70)
    
    components = [
        ("数据结构", "关系（表）", "二维表格，行=元组，列=属性"),
        ("数据操作", "关系代数/演算", "查询、插入、删除、更新"),
        ("完整性约束", "实体、参照、用户定义", "保证数据一致性和正确性"),
        ("函数依赖", "X → Y", "规范化理论的基础"),
    ]
    
    print(f"\n{'组成部分':<15} {'核心概念':<20} {'说明':<30}")
    print("-" * 70)
    
    for component, concept, desc in components:
        print(f"{component:<15} {concept:<20} {desc:<30}")
    
    print("\n" + "=" * 70)
    print("关系代数 vs SQL 对应关系")
    print("=" * 70)
    
    mappings = [
        ("选择 σ", "WHERE"),
        ("投影 π", "SELECT"),
        ("连接 ⋈", "JOIN"),
        ("并 ∪", "UNION"),
        ("差 -", "EXCEPT"),
        ("笛卡尔积 ×", "CROSS JOIN"),
        ("分组 γ", "GROUP BY"),
    ]
    
    print(f"\n{'关系代数':<20} {'SQL':<20}")
    print("-" * 40)
    
    for algebra, sql in mappings:
        print(f"{algebra:<20} {sql:<20}")

relational_model_summary()
```

---

**本章完**
