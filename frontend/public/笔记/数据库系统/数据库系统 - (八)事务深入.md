# 数据库系统 - (八)事务深入

深入理解事务机制。

---

## 8. 事务深入

### 8.1 MVCC（多版本并发控制）

```python
class MVCCDatabase:
    """
    MVCC实现（简化版）
    """
    def __init__(self):
        self.data = {}  # key -> [(version, value), ...]
        self.current_version = 0
        self.transactions = {}
    
    def begin_transaction(self):
        """开始事务"""
        txn_id = self.current_version
        self.transactions[txn_id] = {
            'start_version': self.current_version,
            'writes': {}
        }
        return txn_id
    
    def read(self, txn_id, key):
        """读取（读已提交）"""
        if key not in self.data:
            return None
        
        txn_start = self.transactions[txn_id]['start_version']
        
        # 找到小于等于事务开始版本的最新值
        for version, value in reversed(self.data[key]):
            if version <= txn_start:
                return value
        
        return None
    
    def write(self, txn_id, key, value):
        """写入（延迟到提交）"""
        self.transactions[txn_id]['writes'][key] = value
    
    def commit(self, txn_id):
        """提交事务"""
        self.current_version += 1
        txn = self.transactions[txn_id]
        
        # 应用所有写入
        for key, value in txn['writes'].items():
            if key not in self.data:
                self.data[key] = []
            self.data[key].append((self.current_version, value))
        
        print(f"事务{txn_id}提交，版本: {self.current_version}")
        del self.transactions[txn_id]
    
    def rollback(self, txn_id):
        """回滚事务"""
        print(f"事务{txn_id}回滚")
        del self.transactions[txn_id]

# 示例
db = MVCCDatabase()

# 事务1
txn1 = db.begin_transaction()
db.write(txn1, 'balance', 1000)
db.commit(txn1)

# 事务2读取
txn2 = db.begin_transaction()
print(f"事务2读取: {db.read(txn2, 'balance')}")  # 1000

# 事务3修改
txn3 = db.begin_transaction()
db.write(txn3, 'balance', 900)
db.commit(txn3)

# 事务2仍然读到1000（可重复读）
print(f"事务2再次读取: {db.read(txn2, 'balance')}")
```

### 8.2 死锁检测与处理

```python
class DeadlockDetector:
    """
    死锁检测（等待图法）
    """
    def __init__(self):
        self.wait_for = {}  # 事务 → 等待的事务
        self.holds = {}     # 事务 → 持有的锁
    
    def add_wait(self, txn, waiting_for):
        """添加等待关系"""
        if txn not in self.wait_for:
            self.wait_for[txn] = set()
        self.wait_for[txn].add(waiting_for)
        
        # 检测死锁
        if self._has_cycle():
            print(f"⚠️ 检测到死锁！涉及事务: {txn}, {waiting_for}")
            return True
        return False
    
    def _has_cycle(self):
        """检测环（DFS）"""
        visited = set()
        rec_stack = set()
        
        def dfs(node):
            visited.add(node)
            rec_stack.add(node)
            
            for neighbor in self.wait_for.get(node, []):
                if neighbor not in visited:
                    if dfs(neighbor):
                        return True
                elif neighbor in rec_stack:
                    return True
            
            rec_stack.remove(node)
            return False
        
        for txn in self.wait_for:
            if txn not in visited:
                if dfs(txn):
                    return True
        
        return False
    
    def remove_wait(self, txn):
        """移除等待（锁释放）"""
        if txn in self.wait_for:
            del self.wait_for[txn]

# 示例
detector = DeadlockDetector()
detector.add_wait('T1', 'T2')
detector.add_wait('T2', 'T3')
detector.add_wait('T3', 'T1')  # 形成环，检测到死锁
```

### 8.3 分布式事务

#### 两阶段提交（2PC）

```python
class TwoPhaseCommitCoordinator:
    """
    两阶段提交协调者
    """
    def __init__(self, participants):
        self.participants = participants
        self.state = 'INIT'
    
    def execute_transaction(self, transaction):
        """执行分布式事务"""
        print("阶段1：准备（Prepare）")
        
        # 1. 发送prepare请求
        votes = []
        for participant in self.participants:
            vote = participant.prepare(transaction)
            votes.append(vote)
            print(f"  {participant.name}: {vote}")
        
        # 2. 根据投票决定提交或中止
        if all(vote == 'YES' for vote in votes):
            print("\n阶段2：提交（Commit）")
            self.state = 'COMMIT'
            
            for participant in self.participants:
                participant.commit(transaction)
                print(f"  {participant.name}: 已提交")
            
            return True
        else:
            print("\n阶段2：中止（Abort）")
            self.state = 'ABORT'
            
            for participant in self.participants:
                participant.abort(transaction)
                print(f"  {participant.name}: 已回滚")
            
            return False

class Participant:
    """参与者"""
    def __init__(self, name):
        self.name = name
        self.prepared = False
    
    def prepare(self, transaction):
        """准备阶段"""
        # 检查资源是否可用
        self.prepared = True
        return 'YES'  # 或 'NO'
    
    def commit(self, transaction):
        """提交"""
        if self.prepared:
            # 实际提交操作
            pass
    
    def abort(self, transaction):
        """回滚"""
        self.prepared = False

# 示例
participants = [Participant('DB1'), Participant('DB2'), Participant('DB3')]
coordinator = TwoPhaseCommitCoordinator(participants)

transaction = {'amount': 100, 'from': 'A', 'to': 'B'}
coordinator.execute_transaction(transaction)
```

---

**本章完**
