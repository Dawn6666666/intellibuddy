# 线性代数 - (三)线性方程组

学习线性方程组的解法。

---

## 3. 线性方程组

### 3.1 高斯消元法

**步骤：**
1. 化为行阶梯形（前向消元）
2. 化为行最简形（后向消元）
3. 写出解

**示例：**

$$
\begin{cases}
x + 2y + z = 4 \\
2x + 5y + 4z = 11 \\
x + 3y + 6z = 11
\end{cases}
$$

增广矩阵：

$$
\left[\begin{array}{ccc|c}
1 & 2 & 1 & 4 \\
2 & 5 & 4 & 11 \\
1 & 3 & 6 & 11
\end{array}\right]
$$

行变换：

$$
\left[\begin{array}{ccc|c}
1 & 2 & 1 & 4 \\
0 & 1 & 2 & 3 \\
0 & 0 & 1 & 1
\end{array}\right]
$$

解：$z = 1, y = 1, x = 1$

**Python实现：**

```python
def gauss_elimination(A, b):
    """高斯消元法"""
    n = len(b)
    # 构造增广矩阵
    M = np.hstack([A.astype(float), b.reshape(-1, 1)])
    
    # 前向消元
    for i in range(n):
        # 选主元（避免除以0）
        max_row = i + np.argmax(abs(M[i:, i]))
        M[[i, max_row]] = M[[max_row, i]]
        
        # 消元
        for j in range(i + 1, n):
            M[j] -= M[j, i] / M[i, i] * M[i]
    
    # 回代
    x = np.zeros(n)
    for i in range(n - 1, -1, -1):
        x[i] = (M[i, -1] - np.dot(M[i, i+1:n], x[i+1:])) / M[i, i]
    
    return x

A = np.array([
    [1, 2, 1],
    [2, 5, 4],
    [1, 3, 6]
], dtype=float)
b = np.array([4, 11, 11], dtype=float)

x = gauss_elimination(A, b)
print(f"解: {x}")  # [1. 1. 1.]
```

### 3.2 解的结构

对于 $Ax = b$：

| 情况 | 条件 | 解的个数 |
|------|------|----------|
| 唯一解 | $\text{rank}(A) = \text{rank}(A|b) = n$ | 1 |
| 无穷解 | $\text{rank}(A) = \text{rank}(A|b) < n$ | $\infty$ |
| 无解 | $\text{rank}(A) < \text{rank}(A|b)$ | 0 |

**齐次方程组** $Ax = 0$：

- 必有零解
- 非零解存在 $\Leftrightarrow$ $\text{rank}(A) < n$

### 3.3 最小二乘法

当方程组无精确解时，求最小二乘解：

$$
\min_{x} \|Ax - b\|^2
$$

**正规方程：**

$$
A^T A x = A^T b
$$

$$
x = (A^T A)^{-1} A^T b
$$

**应用：线性回归**

```python
def least_squares(X, y):
    """最小二乘法"""
    return np.linalg.inv(X.T @ X) @ X.T @ y

# 示例：拟合直线 y = ax + b
X = np.array([[1, 1], [1, 2], [1, 3], [1, 4]])  # [1, x]
y = np.array([2.1, 3.9, 6.1, 7.9])

params = least_squares(X, y)
print(f"a = {params[1]:.2f}, b = {params[0]:.2f}")  # a ≈ 2, b ≈ 0
```

### 3.4 LU分解

**定义**：将矩阵分解为下三角矩阵和上三角矩阵的乘积

$$
A = LU
$$

**优势**：求解多个右端项的方程组效率高

**示例：**

$$
A = \begin{bmatrix}
2 & 1 & 1 \\
4 & 3 & 3 \\
8 & 7 & 9
\end{bmatrix}
=
\begin{bmatrix}
1 & 0 & 0 \\
2 & 1 & 0 \\
4 & 3 & 1
\end{bmatrix}
\begin{bmatrix}
2 & 1 & 1 \\
0 & 1 & 1 \\
0 & 0 & 2
\end{bmatrix}
= LU
$$

**求解步骤**：

1. 前向替换：$Ly = b$
2. 后向替换：$Ux = y$

**Python实现：**

```python
import scipy.linalg as la

def solve_with_lu(A, b):
    """使用LU分解求解"""
    # LU分解
    P, L, U = la.lu(A)
    
    # 求解 PLUx = Pb
    # 1. Ly = Pb
    y = la.solve_triangular(L, P @ b, lower=True)
    
    # 2. Ux = y
    x = la.solve_triangular(U, y, lower=False)
    
    return x

# 示例
A = np.array([
    [2, 1, 1],
    [4, 3, 3],
    [8, 7, 9]
], dtype=float)
b = np.array([4, 10, 24], dtype=float)

x = solve_with_lu(A, b)
print(f"解: {x}")  # [1. 1. 1.]

# NumPy直接分解
P, L, U = la.lu(A)
print("L =\n", L)
print("U =\n", U)
print("验证: LU =\n", L @ U)
```

**应用：多次求解**

```python
# 同一个系数矩阵，不同右端项
A = np.array([[4, 2], [1, 3]], dtype=float)
P, L, U = la.lu(A)

# 解多个方程组
for b in [np.array([10, 8]), np.array([6, 5]), np.array([2, 7])]:
    x = la.solve_triangular(U, la.solve_triangular(L, P @ b, lower=True))
    print(f"b={b} → x={x}")
```

### 3.5 迭代法

#### Jacobi迭代

**原理**：将 $A$ 分解为 $D + L + U$（对角、下三角、上三角）

$$
x^{(k+1)} = D^{-1}(b - (L + U)x^{(k)})
$$

**实现：**

```python
def jacobi(A, b, x0=None, max_iter=100, tol=1e-6):
    """Jacobi迭代法"""
    n = len(b)
    x = np.zeros(n) if x0 is None else x0.copy()
    
    # 分离对角元素
    D_inv = 1 / np.diag(A)
    R = A - np.diag(np.diag(A))
    
    for k in range(max_iter):
        x_new = D_inv * (b - R @ x)
        
        if np.linalg.norm(x_new - x) < tol:
            print(f"收敛于第{k+1}次迭代")
            return x_new
        
        x = x_new
    
    print("未收敛")
    return x

# 示例：对角占优矩阵（保证收敛）
A = np.array([
    [10, 1, 2],
    [1, 10, 1],
    [2, 1, 10]
], dtype=float)
b = np.array([13, 12, 13], dtype=float)

x = jacobi(A, b)
print(f"解: {x}")  # [1. 1. 1.]
```

#### Gauss-Seidel迭代

**改进**：使用最新计算的值

$$
x_i^{(k+1)} = \frac{1}{a_{ii}} \left( b_i - \sum_{j<i} a_{ij} x_j^{(k+1)} - \sum_{j>i} a_{ij} x_j^{(k)} \right)
$$

```python
def gauss_seidel(A, b, x0=None, max_iter=100, tol=1e-6):
    """Gauss-Seidel迭代法"""
    n = len(b)
    x = np.zeros(n) if x0 is None else x0.copy()
    
    for k in range(max_iter):
        x_old = x.copy()
        
        for i in range(n):
            sigma = sum(A[i, j] * x[j] for j in range(n) if j != i)
            x[i] = (b[i] - sigma) / A[i, i]
        
        if np.linalg.norm(x - x_old) < tol:
            print(f"收敛于第{k+1}次迭代")
            return x
    
    print("未收敛")
    return x

# 使用相同示例
x = gauss_seidel(A, b)
print(f"解: {x}")
```

**收敛条件**：

- 严格对角占优：$|a_{ii}| > \sum_{j \neq i} |a_{ij}|$
- 对称正定矩阵

**迭代法 vs 直接法**：

| 方法 | 时间复杂度 | 适用场景 |
|------|-----------|---------|
| 高斯消元 | $O(n^3)$ | 小规模密集矩阵 |
| LU分解 | $O(n^3)$ | 多次求解 |
| Jacobi | $O(kn^2)$ | 大规模稀疏矩阵 |
| Gauss-Seidel | $O(kn^2)$ | 对角占优矩阵 |

### 3.6 条件数与数值稳定性

**条件数定义**：

$$
\kappa(A) = \|A\| \cdot \|A^{-1}\|
$$

**意义**：衡量方程组对误差的敏感性

$$
\frac{\|\Delta x\|}{\|x\|} \leq \kappa(A) \frac{\|\Delta b\|}{\|b\|}
$$

**示例：**

```python
def condition_number_analysis():
    """条件数分析"""
    # 良条件矩阵
    A_good = np.array([[2, 1], [1, 2]], dtype=float)
    cond_good = np.linalg.cond(A_good)
    print(f"良条件矩阵条件数: {cond_good:.2f}")
    
    # 病态矩阵（Hilbert矩阵）
    def hilbert(n):
        return np.array([[1/(i+j+1) for j in range(n)] for i in range(n)])
    
    A_bad = hilbert(5)
    cond_bad = np.linalg.cond(A_bad)
    print(f"病态矩阵条件数: {cond_bad:.2e}")
    
    # 测试数值稳定性
    b = np.ones(5)
    x_true = np.linalg.solve(A_bad, b)
    
    # 加入小扰动
    b_perturbed = b + 1e-10 * np.random.randn(5)
    x_perturbed = np.linalg.solve(A_bad, b_perturbed)
    
    relative_error = np.linalg.norm(x_perturbed - x_true) / np.linalg.norm(x_true)
    print(f"相对误差: {relative_error:.2e}")

condition_number_analysis()
```

**避免病态矩阵的方法**：

1. 数据标准化
2. 正则化（Ridge回归）
3. 使用更稳定的算法（SVD）

---

**本章完**
