# 计算机组成原理 - (八)实验指导

计算机组成原理实验指导。

---


### 9.1 实验一：ALU设计（Logisim）

**实验目标：**
- 设计一个8位ALU
- 支持加法、减法、AND、OR、XOR操作

**实验步骤：**

1. **加法器设计**
   - 全加器：输入A、B、Cin，输出Sum、Cout
   - 8位行波进位加法器

2. **减法器设计**
   - 使用补码实现：A - B = A + (-B) = A + B̄ + 1

3. **逻辑运算单元**
   - AND、OR、XOR门电路

4. **多路选择器**
   - 根据操作码选择结果

**电路框图（文字描述）：**

```plain
输入A[7:0] ────┐
               ├──► [加法器] ────┐
输入B[7:0] ────┘                 │
                                 ├──► [4路选择器] ──► 输出[7:0]
输入A[7:0] ────┐                 │
               ├──► [AND运算] ───┤
输入B[7:0] ────┘                 │
                                 │
操作码[1:0] ────────────────────►┘
```

**真值表：**

| 操作码 | 操作 | 结果 |
|--------|------|------|
| 00 | ADD | A + B |
| 01 | SUB | A - B |
| 10 | AND | A & B |
| 11 | OR  | A \| B |

### 9.2 实验二：单周期CPU设计

**实验目标：**
- 实现支持R型、I型指令的单周期CPU
- 包含：寄存器堆、ALU、控制单元、存储器

**支持指令集：**

| 指令 | 格式 | 操作 |
|------|------|------|
| ADD | R型 | rd = rs + rt |
| SUB | R型 | rd = rs - rt |
| LW  | I型 | rt = M[rs + imm] |
| SW  | I型 | M[rs + imm] = rt |
| BEQ | I型 | if (rs == rt) PC += imm |

**数据通路设计：**

```plain
[PC] ──► [指令存储器] ──► [指令]
  │                          │
  │                          ├──► [控制单元]
  │                          │
  └─────► [PC+4]             ├──► [寄存器堆] ──► [ALU] ──► [数据存储器]
                             │                    │
                             └──► [立即数扩展] ───┘
```

**控制信号表：**

| 指令 | RegWrite | ALUSrc | MemRead | MemWrite | MemtoReg | Branch |
|------|----------|--------|---------|----------|----------|--------|
| ADD  | 1 | 0 | 0 | 0 | 0 | 0 |
| LW   | 1 | 1 | 1 | 0 | 1 | 0 |
| SW   | 0 | 1 | 0 | 1 | X | 0 |
| BEQ  | 0 | 0 | 0 | 0 | X | 1 |

### 9.3 实验三：流水线CPU设计

**实验目标：**
- 在单周期CPU基础上实现5级流水线
- 处理数据冲突和控制冲突

**流水线阶段：**

1. **IF（取指）**：从指令存储器读取指令
2. **ID（译码）**：解码指令，读寄存器
3. **EX（执行）**：ALU运算
4. **MEM（访存）**：读写数据存储器
5. **WB（写回）**：写回寄存器

**流水线寄存器：**

```plain
IF/ID: {指令, PC+4}
ID/EX: {控制信号, rs值, rt值, 立即数}
EX/MEM: {控制信号, ALU结果, rt值}
MEM/WB: {控制信号, 数据, 目标寄存器}
```

**数据冲突处理：**

```plain
示例：
    ADD $t0, $t1, $t2  # 写$t0
    SUB $t3, $t0, $t4  # 读$t0（数据冲突！）

解决方案：
1. 数据转发（Forwarding）：EX/MEM -> EX阶段
2. 流水线暂停（Stall）：插入气泡
```

**转发逻辑伪代码：**

```python
if (EX/MEM.RegWrite and EX/MEM.Rd == ID/EX.Rs):
    ForwardA = 10  # 从EX/MEM转发
elif (MEM/WB.RegWrite and MEM/WB.Rd == ID/EX.Rs):
    ForwardA = 01  # 从MEM/WB转发
else:
    ForwardA = 00  # 不转发
```

### 9.4 实验四：Cache性能分析

**实验目标：**
- 测量不同Cache配置的命中率
- 分析访问模式对性能的影响

**测试代码（C语言）：**

```c
#include <stdio.h>
#include <time.h>

#define SIZE 1024 * 1024  // 1MB数组

// 测试1：顺序访问（高命中率）
void sequential_access(int *arr, int size) {
    for (int i = 0; i < size; i++) {
        arr[i] = arr[i] + 1;
    }
}

// 测试2：跳跃访问（低命中率）
void stride_access(int *arr, int size, int stride) {
    for (int i = 0; i < size; i += stride) {
        arr[i] = arr[i] + 1;
    }
}

// 测试3：随机访问（极低命中率）
void random_access(int *arr, int size) {
    for (int i = 0; i < size; i++) {
        int idx = rand() % size;
        arr[idx] = arr[idx] + 1;
    }
}

int main() {
    int *array = malloc(SIZE * sizeof(int));
    
    // 初始化
    for (int i = 0; i < SIZE; i++) {
        array[i] = i;
    }
    
    // 测试顺序访问
    clock_t start = clock();
    sequential_access(array, SIZE);
    clock_t end = clock();
    printf("Sequential: %.3f ms\n", 
           (double)(end - start) * 1000 / CLOCKS_PER_SEC);
    
    // 测试跳跃访问
    start = clock();
    stride_access(array, SIZE, 16);
    end = clock();
    printf("Stride-16: %.3f ms\n", 
           (double)(end - start) * 1000 / CLOCKS_PER_SEC);
    
    // 测试随机访问
    start = clock();
    random_access(array, SIZE / 100);  // 减少次数避免太慢
    end = clock();
    printf("Random: %.3f ms\n", 
           (double)(end - start) * 1000 / CLOCKS_PER_SEC);
    
    free(array);
    return 0;
}
```

**性能分析工具：**

使用Linux `perf` 工具：

```bash
# 统计Cache未命中
perf stat -e cache-references,cache-misses ./program

# 详细性能分析
perf record ./program
perf report
```

---

**本章完**
