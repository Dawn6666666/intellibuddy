# 计算机组成原理 - (二)运算器设计

理解算术逻辑单元的设计原理。

---


### 2.1 ALU（算术逻辑单元）

**基本功能：**
- 算术运算：加、减、乘、除
- 逻辑运算：AND、OR、NOT、XOR
- 移位运算

**全加器（Full Adder）：**

$$
S = A \oplus B \oplus C_{in}
$$

$$
C_{out} = AB + AC_{in} + BC_{in}
$$

```python
def full_adder(a, b, c_in):
    """全加器"""
    s = a ^ b ^ c_in
    c_out = (a & b) | (a & c_in) | (b & c_in)
    return s, c_out

def ripple_carry_adder(a, b):
    """行波进位加法器（8位）"""
    result = []
    carry = 0
    
    for i in range(8):
        bit_a = (a >> i) & 1
        bit_b = (b >> i) & 1
        s, carry = full_adder(bit_a, bit_b, carry)
        result.append(s)
    
    return int(''.join(map(str, reversed(result))), 2)

print(ripple_carry_adder(0b00001101, 0b00000111))  # 13 + 7 = 20
```

### 2.2 乘法器

**算法：Booth算法**

```python
def booth_multiply(M, Q, bits=8):
    """Booth乘法算法"""
    # 扩展符号位
    M = M if M >= 0 else M + (1 << bits)
    Q = Q if Q >= 0 else Q + (1 << bits)
    
    A = 0
    Q_1 = 0
    
    for _ in range(bits):
        q0 = Q & 1
        if q0 == 1 and Q_1 == 0:
            A = A - M
        elif q0 == 0 and Q_1 == 1:
            A = A + M
        
        # 算术右移
        Q_1 = q0
        temp = (A << bits) | Q
        temp >>= 1
        if A & (1 << (bits - 1)):  # 保留符号位
            temp |= (1 << (2*bits - 1))
        
        A = (temp >> bits) & ((1 << bits) - 1)
        Q = temp & ((1 << bits) - 1)
    
    return (A << bits) | Q

# 验证
print(booth_multiply(6, 4))  # 24
```

---

**本章完**
