# 计算机组成原理 - (三)存储器层次结构

掌握Cache、主存、辅存的工作原理。

---


### 3.1 存储器金字塔

```plain
     CPU寄存器 (最快, 容量最小)
          ↓
       L1 Cache
          ↓
       L2 Cache
          ↓
       L3 Cache
          ↓
        主存(RAM)
          ↓
      硬盘/SSD (最慢, 容量最大)
```

| 存储器 | 容量 | 速度 | 价格 |
|--------|------|------|------|
| 寄存器 | ~KB | ~0.5ns | 极高 |
| L1 Cache | ~64KB | ~1ns | 高 |
| L2 Cache | ~512KB | ~5ns | 中 |
| L3 Cache | ~8MB | ~20ns | 低 |
| 主存 | ~16GB | ~100ns | 低 |
| SSD | ~1TB | ~100μs | 极低 |

### 3.2 Cache映射

**直接映射：**

$$
\text{Cache行号} = \text{主存块号} \mod \text{Cache行数}
$$

```python
class DirectMappedCache:
    def __init__(self, cache_lines=16, block_size=4):
        self.cache = [None] * cache_lines
        self.tags = [None] * cache_lines
        self.cache_lines = cache_lines
        self.block_size = block_size
        self.hits = 0
        self.misses = 0
    
    def access(self, address):
        """访问地址"""
        block_num = address // self.block_size
        line = block_num % self.cache_lines
        tag = block_num // self.cache_lines
        
        if self.tags[line] == tag:
            self.hits += 1
            return f"Hit! Data: {self.cache[line]}"
        else:
            self.misses += 1
            # 模拟从内存加载
            self.cache[line] = f"Block {block_num}"
            self.tags[line] = tag
            return f"Miss! Loaded Block {block_num}"
    
    def hit_rate(self):
        total = self.hits + self.misses
        return self.hits / total if total > 0 else 0

# 测试
cache = DirectMappedCache()
addresses = [0, 4, 8, 0, 4, 12, 0]  # 访问序列

for addr in addresses:
    print(f"Access {addr}: {cache.access(addr)}")

print(f"Hit Rate: {cache.hit_rate():.2%}")
```

**组相联映射：**

```python
class SetAssociativeCache:
    def __init__(self, num_sets=8, ways=2, block_size=4):
        self.num_sets = num_sets
        self.ways = ways
        self.cache = [[None] * ways for _ in range(num_sets)]
        self.tags = [[None] * ways for _ in range(num_sets)]
        self.lru = [[0] * ways for _ in range(num_sets)]  # LRU计数
        self.block_size = block_size
        self.hits = 0
        self.misses = 0
    
    def access(self, address):
        block_num = address // self.block_size
        set_index = block_num % self.num_sets
        tag = block_num // self.num_sets
        
        # 检查命中
        for way in range(self.ways):
            if self.tags[set_index][way] == tag:
                self.hits += 1
                self._update_lru(set_index, way)
                return f"Hit in Set {set_index}, Way {way}"
        
        # 未命中，替换
        self.misses += 1
        victim_way = self.lru[set_index].index(max(self.lru[set_index]))
        self.cache[set_index][victim_way] = f"Block {block_num}"
        self.tags[set_index][victim_way] = tag
        self._update_lru(set_index, victim_way)
        
        return f"Miss! Replaced Set {set_index}, Way {victim_way}"
    
    def _update_lru(self, set_index, accessed_way):
        """更新LRU"""
        for way in range(self.ways):
            if way != accessed_way:
                self.lru[set_index][way] += 1
        self.lru[set_index][accessed_way] = 0

cache = SetAssociativeCache(num_sets=4, ways=2)
for addr in [0, 4, 8, 0, 16, 4]:
    print(cache.access(addr))
```

---

**本章完**
