# è®¡ç®—æœºç»„æˆåŸç† - (ä¸€)æ•°åˆ¶ä¸ç¼–ç 

å­¦ä¹ è®¡ç®—æœºä¸­çš„æ•°åˆ¶è¡¨ç¤ºå’Œç¼–ç ã€‚

---

# è®¡ç®—æœºç»„æˆåŸç†

> ğŸ’¡ **è¯¾ç¨‹ä¿¡æ¯**
> - å­¦ä¹ æ—¶é•¿ï¼š150å°æ—¶
> - éš¾åº¦ç­‰çº§ï¼šâ­â­â­â­ (é«˜)
> - å‰ç½®è¯¾ç¨‹ï¼šæ•°å­—é€»è¾‘ã€Cè¯­è¨€
> - **ç†è§£è®¡ç®—æœºç¡¬ä»¶å·¥ä½œåŸç†**

---

## ğŸ“š è¯¾ç¨‹æ¦‚è¿°

### å†¯Â·è¯ºä¾æ›¼ä½“ç³»ç»“æ„

```plain
      è¾“å…¥è®¾å¤‡
          â†“
   [  è¿ç®—å™¨  ] â†â†’ [  æ§åˆ¶å™¨  ]
       â†•              â†•
   [ å­˜å‚¨å™¨ (å†…å­˜) ]
          â†“
      è¾“å‡ºè®¾å¤‡
```

**äº”å¤§éƒ¨ä»¶ï¼š**
1. **è¿ç®—å™¨ï¼ˆALUï¼‰**ï¼šç®—æœ¯é€»è¾‘è¿ç®—
2. **æ§åˆ¶å™¨ï¼ˆCUï¼‰**ï¼šæŒ‡ä»¤è§£ç ä¸æ§åˆ¶
3. **å­˜å‚¨å™¨ï¼ˆMemoryï¼‰**ï¼šæ•°æ®ä¸ç¨‹åºå­˜å‚¨
4. **è¾“å…¥è®¾å¤‡**ï¼šé”®ç›˜ã€é¼ æ ‡ç­‰
5. **è¾“å‡ºè®¾å¤‡**ï¼šæ˜¾ç¤ºå™¨ã€æ‰“å°æœºç­‰

---

## 1. æ•°åˆ¶ä¸ç¼–ç 

### 1.1 è¿›åˆ¶è½¬æ¢

**åè¿›åˆ¶ â†” äºŒè¿›åˆ¶ï¼š**

$$
(13)_{10} = (1101)_2 = 1 \times 2^3 + 1 \times 2^2 + 0 \times 2^1 + 1 \times 2^0
$$

**Pythonå®ç°ï¼š**

```python
def dec_to_bin(n):
    """åè¿›åˆ¶è½¬äºŒè¿›åˆ¶"""
    if n == 0:
        return "0"
    binary = ""
    while n > 0:
        binary = str(n % 2) + binary
        n //= 2
    return binary

def bin_to_dec(binary):
    """äºŒè¿›åˆ¶è½¬åè¿›åˆ¶"""
    decimal = 0
    for i, bit in enumerate(reversed(binary)):
        decimal += int(bit) * (2 ** i)
    return decimal

print(dec_to_bin(13))  # "1101"
print(bin_to_dec("1101"))  # 13
```

### 1.2 æœ‰ç¬¦å·æ•°è¡¨ç¤º

| è¡¨ç¤ºæ³• | +3 | -3 | è¯´æ˜ |
|--------|----|----|------|
| åŸç  | 0011 | 1011 | ç¬¦å·ä½ + æ•°å€¼ |
| åç  | 0011 | 1100 | è´Ÿæ•°ï¼šç¬¦å·ä½ä¸å˜ï¼Œå…¶ä½™å–å |
| è¡¥ç  | 0011 | 1101 | è´Ÿæ•°ï¼šåç +1 |

**è¡¥ç ä¼˜åŠ¿**ï¼šç»Ÿä¸€åŠ å‡è¿ç®—

$$
3 + (-3) = 0011 + 1101 = 10000 = 0 \quad (\text{æº¢å‡ºä½èˆå¼ƒ})
$$

```python
def to_twos_complement(num, bits=8):
    """è½¬æ¢ä¸ºè¡¥ç """
    if num >= 0:
        return bin(num)[2:].zfill(bits)
    else:
        # è´Ÿæ•°ï¼šå…ˆå–ç»å¯¹å€¼ï¼Œåç +1
        abs_val = abs(num)
        binary = bin(abs_val)[2:].zfill(bits)
        # å–å
        inverted = ''.join('1' if b == '0' else '0' for b in binary)
        # +1
        result = bin(int(inverted, 2) + 1)[2:].zfill(bits)
        return result

print(to_twos_complement(3))   # "00000011"
print(to_twos_complement(-3))  # "11111101"
```

### 1.3 æµ®ç‚¹æ•°è¡¨ç¤ºï¼ˆIEEE 754ï¼‰

**å•ç²¾åº¦ï¼ˆ32ä½ï¼‰ï¼š**

```plain
ç¬¦å·ä½(1) | æŒ‡æ•°ä½(8) | å°¾æ•°ä½(23)
   S     |     E      |      M
```

$$
\text{Value} = (-1)^S \times 1.M \times 2^{E-127}
$$

**ç¤ºä¾‹ï¼š**$5.75_{10}$ çš„è¡¨ç¤º

1. è½¬äºŒè¿›åˆ¶ï¼š$5.75 = 101.11_2 = 1.0111 \times 2^2$
2. $S = 0$ï¼ˆæ­£æ•°ï¼‰
3. $E = 2 + 127 = 129 = 10000001_2$
4. $M = 0111$ ï¼ˆè¡¥0è‡³23ä½ï¼‰

```python
import struct

def float_to_ieee754(num):
    """æµ®ç‚¹æ•°è½¬IEEE 754"""
    # Python structè‡ªåŠ¨è½¬æ¢
    binary = ''.join(f'{c:08b}' for c in struct.pack('>f', num))
    sign = binary[0]
    exponent = binary[1:9]
    mantissa = binary[9:]
    
    print(f"Sign: {sign}")
    print(f"Exponent: {exponent} ({int(exponent, 2)})")
    print(f"Mantissa: {mantissa}")
    
    return binary

float_to_ieee754(5.75)
```

**åŒç²¾åº¦ï¼ˆ64ä½ï¼‰ï¼š**

```plain
ç¬¦å·ä½(1) | æŒ‡æ•°ä½(11) | å°¾æ•°ä½(52)
```

$$
\text{Value} = (-1)^S \times 1.M \times 2^{E-1023}
$$

**ç‰¹æ®Šå€¼ï¼š**

| ç±»å‹ | æŒ‡æ•° | å°¾æ•° | è¡¨ç¤º |
|------|------|------|------|
| é›¶ | å…¨0 | å…¨0 | $\pm 0$ |
| æ— ç©·å¤§ | å…¨1 | å…¨0 | $\pm \infty$ |
| NaN | å…¨1 | é0 | Not a Number |
| éè§„æ ¼åŒ–æ•° | å…¨0 | é0 | $0.M \times 2^{-126}$ |

**å®Œæ•´å®ç°ï¼š**

```python
class IEEE754Converter:
    """IEEE 754æµ®ç‚¹æ•°è½¬æ¢å™¨"""
    
    @staticmethod
    def float_to_binary(num):
        """æµ®ç‚¹æ•°è½¬äºŒè¿›åˆ¶ï¼ˆæ‰‹åŠ¨å®ç°ï¼‰"""
        if num == 0:
            return '0', '0'
        
        # å¤„ç†è´Ÿæ•°
        sign = '1' if num < 0 else '0'
        num = abs(num)
        
        # æ•´æ•°éƒ¨åˆ†
        integer_part = int(num)
        int_binary = bin(integer_part)[2:]
        
        # å°æ•°éƒ¨åˆ†
        frac_part = num - integer_part
        frac_binary = ''
        max_bits = 23  # é™åˆ¶ç²¾åº¦
        
        while frac_part > 0 and len(frac_binary) < max_bits:
            frac_part *= 2
            if frac_part >= 1:
                frac_binary += '1'
                frac_part -= 1
            else:
                frac_binary += '0'
        
        return sign, int_binary + '.' + frac_binary
    
    @staticmethod
    def normalize(sign, binary_str):
        """è§„æ ¼åŒ–"""
        parts = binary_str.split('.')
        int_part = parts[0]
        frac_part = parts[1] if len(parts) > 1 else ''
        
        # æ‰¾åˆ°ç¬¬ä¸€ä¸ª1çš„ä½ç½®
        combined = int_part + frac_part
        first_one = combined.find('1')
        
        if first_one == -1:
            return 0, '0'
        
        # è®¡ç®—æŒ‡æ•°
        if '.' in binary_str:
            exponent = len(int_part) - 1
        else:
            exponent = first_one
        
        # æå–å°¾æ•°ï¼ˆç¬¬ä¸€ä¸ª1ä¹‹åçš„éƒ¨åˆ†ï¼‰
        mantissa = combined[first_one + 1:]
        
        return exponent, mantissa
    
    @staticmethod
    def encode_ieee754(num):
        """ç¼–ç ä¸ºIEEE 754"""
        sign, binary = IEEE754Converter.float_to_binary(num)
        exponent, mantissa = IEEE754Converter.normalize(sign, binary)
        
        # æŒ‡æ•°åç§»ï¼ˆå•ç²¾åº¦ï¼š127ï¼‰
        biased_exp = exponent + 127
        exp_bits = format(biased_exp, '08b')
        
        # å°¾æ•°è¡¥é½23ä½
        mantissa_bits = (mantissa + '0' * 23)[:23]
        
        # ç»„åˆ
        ieee754 = sign + exp_bits + mantissa_bits
        
        return ieee754
    
    @staticmethod
    def decode_ieee754(binary_str):
        """è§£ç IEEE 754"""
        sign = int(binary_str[0])
        exponent = int(binary_str[1:9], 2)
        mantissa = binary_str[9:]
        
        # æ£€æŸ¥ç‰¹æ®Šå€¼
        if exponent == 255:
            if int(mantissa, 2) == 0:
                return float('inf') if sign == 0 else float('-inf')
            else:
                return float('nan')
        
        if exponent == 0:
            if int(mantissa, 2) == 0:
                return 0.0
            # éè§„æ ¼åŒ–æ•°
            return (-1)**sign * float(int(mantissa, 2)) * 2**(-126) / (2**23)
        
        # è§„æ ¼åŒ–æ•°
        mantissa_value = 1.0 + int(mantissa, 2) / (2**23)
        value = (-1)**sign * mantissa_value * 2**(exponent - 127)
        
        return value

# æµ‹è¯•
converter = IEEE754Converter()
ieee = converter.encode_ieee754(5.75)
print(f"5.75 çš„IEEE 754è¡¨ç¤º: {ieee}")
print(f"è§£ç ç»“æœ: {converter.decode_ieee754(ieee)}")
```

### 1.4 BCDç ï¼ˆBinary-Coded Decimalï¼‰

**å®šä¹‰**ï¼šç”¨4ä½äºŒè¿›åˆ¶è¡¨ç¤º1ä½åè¿›åˆ¶æ•°ã€‚

**8421ç ï¼ˆæœ€å¸¸ç”¨ï¼‰ï¼š**

| åè¿›åˆ¶ | BCDç  | åè¿›åˆ¶ | BCDç  |
|--------|-------|--------|-------|
| 0 | 0000 | 5 | 0101 |
| 1 | 0001 | 6 | 0110 |
| 2 | 0010 | 7 | 0111 |
| 3 | 0011 | 8 | 1000 |
| 4 | 0100 | 9 | 1001 |

**ç¤ºä¾‹**ï¼š$95_{10} = 1001\ 0101_{BCD}$

**BCDåŠ æ³•ï¼š**

å¦‚æœç»“æœ > 9 æˆ–æœ‰è¿›ä½ï¼Œéœ€è¦åŠ 6ä¿®æ­£ã€‚

```python
class BCDArithmetic:
    """BCDç è¿ç®—å™¨"""
    
    @staticmethod
    def decimal_to_bcd(num):
        """åè¿›åˆ¶è½¬BCD"""
        bcd = ''
        for digit in str(num):
            bcd += format(int(digit), '04b')
        return bcd
    
    @staticmethod
    def bcd_to_decimal(bcd):
        """BCDè½¬åè¿›åˆ¶"""
        decimal = 0
        for i in range(0, len(bcd), 4):
            digit = int(bcd[i:i+4], 2)
            decimal = decimal * 10 + digit
        return decimal
    
    @staticmethod
    def bcd_add(a, b):
        """BCDåŠ æ³•"""
        # è½¬ä¸ºåè¿›åˆ¶è®¡ç®—ï¼ˆç®€åŒ–å®ç°ï¼‰
        dec_a = BCDArithmetic.bcd_to_decimal(a)
        dec_b = BCDArithmetic.bcd_to_decimal(b)
        result = dec_a + dec_b
        return BCDArithmetic.decimal_to_bcd(result)
    
    @staticmethod
    def bcd_add_hardware(a_bcd, b_bcd):
        """ç¡¬ä»¶BCDåŠ æ³•ï¼ˆæ¨¡æ‹Ÿä¿®æ­£è¿‡ç¨‹ï¼‰"""
        # æŒ‰4ä½åˆ†ç»„
        a_digits = [int(a_bcd[i:i+4], 2) for i in range(0, len(a_bcd), 4)]
        b_digits = [int(b_bcd[i:i+4], 2) for i in range(0, len(b_bcd), 4)]
        
        result = []
        carry = 0
        
        # ä»ä½ä½åˆ°é«˜ä½
        for i in range(len(a_digits) - 1, -1, -1):
            sum_val = a_digits[i] + b_digits[i] + carry
            
            # BCDä¿®æ­£ï¼šå¦‚æœç»“æœ>9ï¼ŒåŠ 6
            if sum_val > 9:
                sum_val += 6
                carry = 1
            else:
                carry = 0
            
            result.insert(0, format(sum_val % 16, '04b'))
        
        if carry:
            result.insert(0, '0001')
        
        return ''.join(result)

# æµ‹è¯•
bcd = BCDArithmetic()
a = bcd.decimal_to_bcd(25)  # 0010 0101
b = bcd.decimal_to_bcd(38)  # 0011 1000
result = bcd.bcd_add_hardware(a, b)
print(f"25 + 38 (BCD) = {bcd.bcd_to_decimal(result)}")  # 63
```

**ä½™3ç ï¼ˆExcess-3 Codeï¼‰**ï¼š

BCDç  + 3ï¼Œç”¨äºç®€åŒ–å‡æ³•è¿ç®—ã€‚

| åè¿›åˆ¶ | ä½™3ç  |
|--------|-------|
| 0 | 0011 |
| 1 | 0100 |
| 2 | 0101 |
| 5 | 1000 |
| 9 | 1100 |

### 1.5 æ ¼é›·ç ï¼ˆGray Codeï¼‰

**å®šä¹‰**ï¼šç›¸é‚»æ•°å€¼åªæœ‰1ä½ä¸åŒçš„ç¼–ç ã€‚

**äºŒè¿›åˆ¶è½¬æ ¼é›·ç ï¼š**

$$
G_i = B_i \oplus B_{i+1}
$$

**æ ¼é›·ç è½¬äºŒè¿›åˆ¶ï¼š**

$$
B_i = G_i \oplus B_{i+1}
$$

| åè¿›åˆ¶ | äºŒè¿›åˆ¶ | æ ¼é›·ç  |
|--------|--------|--------|
| 0 | 000 | 000 |
| 1 | 001 | 001 |
| 2 | 010 | 011 |
| 3 | 011 | 010 |
| 4 | 100 | 110 |
| 5 | 101 | 111 |
| 6 | 110 | 101 |
| 7 | 111 | 100 |

**åº”ç”¨**ï¼š
+ âœ… æ—‹è½¬ç¼–ç å™¨ï¼ˆé¿å…ä¸­é—´æ€é”™è¯¯ï¼‰
+ âœ… ADC/DACè½¬æ¢
+ âœ… é€šä¿¡ç³»ç»Ÿ

```python
class GrayCode:
    """æ ¼é›·ç è½¬æ¢å™¨"""
    
    @staticmethod
    def binary_to_gray(binary):
        """äºŒè¿›åˆ¶è½¬æ ¼é›·ç """
        gray = binary[0]  # æœ€é«˜ä½ä¿æŒä¸å˜
        for i in range(1, len(binary)):
            # XORè¿ç®—
            gray += str(int(binary[i-1]) ^ int(binary[i]))
        return gray
    
    @staticmethod
    def gray_to_binary(gray):
        """æ ¼é›·ç è½¬äºŒè¿›åˆ¶"""
        binary = gray[0]  # æœ€é«˜ä½ä¿æŒä¸å˜
        for i in range(1, len(gray)):
            # XORç´¯ç§¯
            binary += str(int(binary[i-1]) ^ int(gray[i]))
        return binary
    
    @staticmethod
    def decimal_to_gray(num, bits=8):
        """åè¿›åˆ¶è½¬æ ¼é›·ç """
        binary = format(num, f'0{bits}b')
        return GrayCode.binary_to_gray(binary)
    
    @staticmethod
    def gray_to_decimal(gray):
        """æ ¼é›·ç è½¬åè¿›åˆ¶"""
        binary = GrayCode.gray_to_binary(gray)
        return int(binary, 2)

# æµ‹è¯•
gc = GrayCode()
print("åè¿›åˆ¶ | äºŒè¿›åˆ¶   | æ ¼é›·ç ")
print("------|---------|--------")
for i in range(8):
    binary = format(i, '03b')
    gray = gc.binary_to_gray(binary)
    print(f"  {i}    | {binary}     | {gray}")

# éªŒè¯è½¬æ¢
assert gc.gray_to_decimal('110') == 4
print("\næ ¼é›·ç è½¬æ¢éªŒè¯æˆåŠŸï¼")
```

### 1.6 å·®é”™æ£€æµ‹ä¸çº æ­£ç 

#### å¥‡å¶æ ¡éªŒç ï¼ˆParity Checkï¼‰

**å¶æ ¡éªŒ**ï¼šä½¿1çš„ä¸ªæ•°ä¸ºå¶æ•°

$$
P = d_0 \oplus d_1 \oplus d_2 \oplus \cdots \oplus d_{n-1}
$$

```python
def add_parity(data, even=True):
    """æ·»åŠ å¥‡å¶æ ¡éªŒä½"""
    ones = data.count('1')
    if even:
        parity = '0' if ones % 2 == 0 else '1'
    else:
        parity = '1' if ones % 2 == 0 else '0'
    return data + parity

def check_parity(data_with_parity, even=True):
    """æ£€æŸ¥å¥‡å¶æ ¡éªŒ"""
    ones = data_with_parity.count('1')
    if even:
        return ones % 2 == 0
    else:
        return ones % 2 == 1

# æµ‹è¯•
data = "1011001"
encoded = add_parity(data, even=True)
print(f"åŸå§‹æ•°æ®: {data}")
print(f"ç¼–ç å: {encoded}")
print(f"æ ¡éªŒé€šè¿‡: {check_parity(encoded, even=True)}")
```

#### æµ·æ˜ç ï¼ˆHamming Codeï¼‰

**åŸç†**ï¼šèƒ½çº æ­£1ä½é”™è¯¯ï¼Œæ£€æµ‹2ä½é”™è¯¯ã€‚

**æ ¡éªŒä½ä½ç½®**ï¼š$2^0, 2^1, 2^2, \ldots$ï¼ˆ1, 2, 4, 8, ...ï¼‰

**ç¤ºä¾‹**ï¼šç¼–ç 4ä½æ•°æ® $d = 1011$

```plain
ä½ç½®:  1  2  3  4  5  6  7
     p1 p2 d1 p4 d2 d3 d4
     p1 p2  1 p4  0  1  1
```

**æ ¡éªŒä½è®¡ç®—ï¼š**
+ $p_1$: æ£€æŸ¥ä½ç½® 1, 3, 5, 7ï¼ˆäºŒè¿›åˆ¶æœ€ä½ä½ä¸º1ï¼‰
+ $p_2$: æ£€æŸ¥ä½ç½® 2, 3, 6, 7ï¼ˆäºŒè¿›åˆ¶æ¬¡ä½ä½ä¸º1ï¼‰
+ $p_4$: æ£€æŸ¥ä½ç½® 4, 5, 6, 7ï¼ˆäºŒè¿›åˆ¶ç¬¬3ä½ä¸º1ï¼‰

```python
class HammingCode:
    """æµ·æ˜ç ç¼–ç å™¨/è§£ç å™¨"""
    
    @staticmethod
    def encode(data):
        """æµ·æ˜ç ç¼–ç """
        n = len(data)
        # è®¡ç®—éœ€è¦çš„æ ¡éªŒä½æ•°é‡
        r = 0
        while 2**r < n + r + 1:
            r += 1
        
        # åˆ›å»ºç¼–ç æ•°ç»„ï¼ˆæ€»é•¿åº¦ = æ•°æ®ä½ + æ ¡éªŒä½ï¼‰
        total_len = n + r
        encoded = ['0'] * total_len
        
        # å¡«å……æ•°æ®ä½ï¼ˆè·³è¿‡æ ¡éªŒä½ä½ç½®ï¼‰
        data_idx = 0
        for i in range(1, total_len + 1):
            if (i & (i - 1)) != 0:  # ä¸æ˜¯2çš„å¹‚
                encoded[i - 1] = data[data_idx]
                data_idx += 1
        
        # è®¡ç®—æ ¡éªŒä½
        for i in range(r):
            parity_pos = 2**i
            parity = 0
            
            for j in range(1, total_len + 1):
                if j & parity_pos:
                    parity ^= int(encoded[j - 1])
            
            encoded[parity_pos - 1] = str(parity)
        
        return ''.join(encoded)
    
    @staticmethod
    def decode(encoded):
        """æµ·æ˜ç è§£ç å¹¶çº é”™"""
        n = len(encoded)
        r = 0
        while 2**r < n + 1:
            r += 1
        
        # è®¡ç®—æ ¡éªŒå­
        error_pos = 0
        for i in range(r):
            parity_pos = 2**i
            parity = 0
            
            for j in range(1, n + 1):
                if j & parity_pos:
                    parity ^= int(encoded[j - 1])
            
            if parity != 0:
                error_pos += parity_pos
        
        # çº é”™
        if error_pos > 0:
            print(f"æ£€æµ‹åˆ°é”™è¯¯ä½ç½®: {error_pos}")
            corrected = list(encoded)
            corrected[error_pos - 1] = '1' if corrected[error_pos - 1] == '0' else '0'
            encoded = ''.join(corrected)
        
        # æå–æ•°æ®ä½
        data = ''
        for i in range(1, n + 1):
            if (i & (i - 1)) != 0:  # ä¸æ˜¯2çš„å¹‚
                data += encoded[i - 1]
        
        return data, error_pos

# æµ‹è¯•
hamming = HammingCode()
data = "1011"
encoded = hamming.encode(data)
print(f"åŸå§‹æ•°æ®: {data}")
print(f"æµ·æ˜ç¼–ç : {encoded}")

# æ¨¡æ‹Ÿ1ä½é”™è¯¯
error_encoded = list(encoded)
error_encoded[4] = '1' if error_encoded[4] == '0' else '0'
error_encoded = ''.join(error_encoded)
print(f"å¼•å…¥é”™è¯¯: {error_encoded}")

decoded, error_pos = hamming.decode(error_encoded)
print(f"çº é”™åæ•°æ®: {decoded}")
print(f"çº é”™æˆåŠŸ: {decoded == data}")
```

#### CRCå¾ªç¯å†—ä½™æ ¡éªŒï¼ˆCyclic Redundancy Checkï¼‰

**åŸç†**ï¼šä½¿ç”¨å¤šé¡¹å¼é™¤æ³•ç”Ÿæˆæ ¡éªŒç ã€‚

**å¸¸ç”¨ç”Ÿæˆå¤šé¡¹å¼ï¼š**
+ CRC-8: $x^8 + x^2 + x + 1$
+ CRC-16: $x^{16} + x^{15} + x^2 + 1$
+ CRC-32: $x^{32} + x^{26} + x^{23} + \cdots + x + 1$

```python
class CRC:
    """CRCæ ¡éªŒå™¨"""
    
    def __init__(self, polynomial):
        """
        polynomial: ç”Ÿæˆå¤šé¡¹å¼ï¼ˆäºŒè¿›åˆ¶å­—ç¬¦ä¸²ï¼‰
        ä¾‹å¦‚ï¼š'1011' è¡¨ç¤º x^3 + x + 1
        """
        self.polynomial = polynomial
        self.poly_len = len(polynomial)
    
    def xor(self, a, b):
        """æ¨¡2é™¤æ³•çš„XORè¿ç®—"""
        result = ''
        for i in range(len(b)):
            result += '0' if a[i] == b[i] else '1'
        return result
    
    def mod2_division(self, dividend):
        """æ¨¡2é™¤æ³•"""
        dividend = list(dividend)
        
        for i in range(len(dividend) - self.poly_len + 1):
            if dividend[i] == '1':
                # XORæ“ä½œ
                for j in range(self.poly_len):
                    dividend[i + j] = '0' if dividend[i + j] == self.polynomial[j] else '1'
        
        # è¿”å›ä½™æ•°
        return ''.join(dividend[-(self.poly_len - 1):])
    
    def encode(self, data):
        """ç”ŸæˆCRCæ ¡éªŒç """
        # æ•°æ®åé™„åŠ  (n-1) ä¸ª0
        padded = data + '0' * (self.poly_len - 1)
        remainder = self.mod2_division(padded)
        return data + remainder
    
    def check(self, received):
        """æ ¡éªŒæ¥æ”¶æ•°æ®"""
        remainder = self.mod2_division(received)
        return int(remainder) == 0

# æµ‹è¯•CRC-4
crc = CRC('1011')  # x^3 + x + 1
data = '110101'
encoded = crc.encode(data)
print(f"åŸå§‹æ•°æ®: {data}")
print(f"CRCç¼–ç : {encoded}")
print(f"æ ¡éªŒé€šè¿‡: {crc.check(encoded)}")

# å¼•å…¥é”™è¯¯
error_data = list(encoded)
error_data[3] = '1' if error_data[3] == '0' else '0'
error_data = ''.join(error_data)
print(f"é”™è¯¯æ•°æ®: {error_data}")
print(f"æ ¡éªŒé€šè¿‡: {crc.check(error_data)}")
```

**CRC-32å®Œæ•´å®ç°ï¼š**

```python
def crc32(data):
    """CRC-32æ ¡éªŒï¼ˆä½¿ç”¨æ ‡å‡†ç®—æ³•ï¼‰"""
    crc = 0xFFFFFFFF
    polynomial = 0xEDB88320  # CRC-32å¤šé¡¹å¼
    
    for byte in data:
        crc ^= byte
        for _ in range(8):
            if crc & 1:
                crc = (crc >> 1) ^ polynomial
            else:
                crc >>= 1
    
    return crc ^ 0xFFFFFFFF

# æµ‹è¯•
data = b"Hello, World!"
checksum = crc32(data)
print(f"CRC-32æ ¡éªŒç : {checksum:08X}")

# éªŒè¯
import zlib
assert checksum == zlib.crc32(data)
print("CRC-32å®ç°æ­£ç¡®ï¼")
```

### 1.7 å­—ç¬¦ç¼–ç 

#### ASCIIç 

**æ ‡å‡†ASCIIï¼ˆ7ä½ï¼‰**ï¼š0-127

| èŒƒå›´ | ç±»å‹ | ç¤ºä¾‹ |
|------|------|------|
| 0-31 | æ§åˆ¶å­—ç¬¦ | `\n`, `\r`, `\t` |
| 32-47 | æ ‡ç‚¹ç¬¦å· | `!`, `"`, `#` |
| 48-57 | æ•°å­— | `0`-`9` |
| 65-90 | å¤§å†™å­—æ¯ | `A`-`Z` |
| 97-122 | å°å†™å­—æ¯ | `a`-`z` |

```python
# ASCIIç¼–ç ç¤ºä¾‹
text = "Hello"
ascii_codes = [ord(char) for char in text]
print(f"'{text}' çš„ASCIIç : {ascii_codes}")

# äºŒè¿›åˆ¶è¡¨ç¤º
for char in text:
    print(f"{char}: {ord(char):3d} = {ord(char):08b}")
```

#### Unicodeä¸UTF-8

**UTF-8å˜é•¿ç¼–ç ï¼š**

| UnicodeèŒƒå›´ | UTF-8ç¼–ç  | å­—èŠ‚æ•° |
|------------|----------|--------|
| U+0000 - U+007F | 0xxxxxxx | 1 |
| U+0080 - U+07FF | 110xxxxx 10xxxxxx | 2 |
| U+0800 - U+FFFF | 1110xxxx 10xxxxxx 10xxxxxx | 3 |
| U+10000 - U+10FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx | 4 |

```python
def char_to_utf8(char):
    """å­—ç¬¦è½¬UTF-8ç¼–ç """
    utf8_bytes = char.encode('utf-8')
    binary = ' '.join(format(byte, '08b') for byte in utf8_bytes)
    
    print(f"å­—ç¬¦: {char}")
    print(f"Unicode: U+{ord(char):04X}")
    print(f"UTF-8: {binary}")
    print(f"å­—èŠ‚æ•°: {len(utf8_bytes)}")

# æµ‹è¯•
char_to_utf8('A')      # 1å­—èŠ‚
char_to_utf8('ä¸­')     # 3å­—èŠ‚
char_to_utf8('ğŸ˜Š')     # 4å­—èŠ‚
```

---

**æœ¬ç« å®Œ**
