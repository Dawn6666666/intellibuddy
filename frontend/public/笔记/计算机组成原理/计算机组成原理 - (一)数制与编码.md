# 计算机组成原理 - (一)数制与编码

学习计算机中的数制表示和编码。

---

# 计算机组成原理

> 💡 **课程信息**
> - 学习时长：150小时
> - 难度等级：⭐⭐⭐⭐ (高)
> - 前置课程：数字逻辑、C语言
> - **理解计算机硬件工作原理**

---

## 📚 课程概述

### 冯·诺依曼体系结构

```plain
      输入设备
          ↓
   [  运算器  ] ←→ [  控制器  ]
       ↕              ↕
   [ 存储器 (内存) ]
          ↓
      输出设备
```

**五大部件：**
1. **运算器（ALU）**：算术逻辑运算
2. **控制器（CU）**：指令解码与控制
3. **存储器（Memory）**：数据与程序存储
4. **输入设备**：键盘、鼠标等
5. **输出设备**：显示器、打印机等

---

## 1. 数制与编码

### 1.1 进制转换

**十进制 ↔ 二进制：**

$$
(13)_{10} = (1101)_2 = 1 \times 2^3 + 1 \times 2^2 + 0 \times 2^1 + 1 \times 2^0
$$

**Python实现：**

```python
def dec_to_bin(n):
    """十进制转二进制"""
    if n == 0:
        return "0"
    binary = ""
    while n > 0:
        binary = str(n % 2) + binary
        n //= 2
    return binary

def bin_to_dec(binary):
    """二进制转十进制"""
    decimal = 0
    for i, bit in enumerate(reversed(binary)):
        decimal += int(bit) * (2 ** i)
    return decimal

print(dec_to_bin(13))  # "1101"
print(bin_to_dec("1101"))  # 13
```

### 1.2 有符号数表示

| 表示法 | +3 | -3 | 说明 |
|--------|----|----|------|
| 原码 | 0011 | 1011 | 符号位 + 数值 |
| 反码 | 0011 | 1100 | 负数：符号位不变，其余取反 |
| 补码 | 0011 | 1101 | 负数：反码+1 |

**补码优势**：统一加减运算

$$
3 + (-3) = 0011 + 1101 = 10000 = 0 \quad (\text{溢出位舍弃})
$$

```python
def to_twos_complement(num, bits=8):
    """转换为补码"""
    if num >= 0:
        return bin(num)[2:].zfill(bits)
    else:
        # 负数：先取绝对值，反码+1
        abs_val = abs(num)
        binary = bin(abs_val)[2:].zfill(bits)
        # 取反
        inverted = ''.join('1' if b == '0' else '0' for b in binary)
        # +1
        result = bin(int(inverted, 2) + 1)[2:].zfill(bits)
        return result

print(to_twos_complement(3))   # "00000011"
print(to_twos_complement(-3))  # "11111101"
```

### 1.3 浮点数表示（IEEE 754）

**单精度（32位）：**

```plain
符号位(1) | 指数位(8) | 尾数位(23)
   S     |     E      |      M
```

$$
\text{Value} = (-1)^S \times 1.M \times 2^{E-127}
$$

**示例：**$5.75_{10}$ 的表示

1. 转二进制：$5.75 = 101.11_2 = 1.0111 \times 2^2$
2. $S = 0$（正数）
3. $E = 2 + 127 = 129 = 10000001_2$
4. $M = 0111$ （补0至23位）

```python
import struct

def float_to_ieee754(num):
    """浮点数转IEEE 754"""
    # Python struct自动转换
    binary = ''.join(f'{c:08b}' for c in struct.pack('>f', num))
    sign = binary[0]
    exponent = binary[1:9]
    mantissa = binary[9:]
    
    print(f"Sign: {sign}")
    print(f"Exponent: {exponent} ({int(exponent, 2)})")
    print(f"Mantissa: {mantissa}")
    
    return binary

float_to_ieee754(5.75)
```

**双精度（64位）：**

```plain
符号位(1) | 指数位(11) | 尾数位(52)
```

$$
\text{Value} = (-1)^S \times 1.M \times 2^{E-1023}
$$

**特殊值：**

| 类型 | 指数 | 尾数 | 表示 |
|------|------|------|------|
| 零 | 全0 | 全0 | $\pm 0$ |
| 无穷大 | 全1 | 全0 | $\pm \infty$ |
| NaN | 全1 | 非0 | Not a Number |
| 非规格化数 | 全0 | 非0 | $0.M \times 2^{-126}$ |

**完整实现：**

```python
class IEEE754Converter:
    """IEEE 754浮点数转换器"""
    
    @staticmethod
    def float_to_binary(num):
        """浮点数转二进制（手动实现）"""
        if num == 0:
            return '0', '0'
        
        # 处理负数
        sign = '1' if num < 0 else '0'
        num = abs(num)
        
        # 整数部分
        integer_part = int(num)
        int_binary = bin(integer_part)[2:]
        
        # 小数部分
        frac_part = num - integer_part
        frac_binary = ''
        max_bits = 23  # 限制精度
        
        while frac_part > 0 and len(frac_binary) < max_bits:
            frac_part *= 2
            if frac_part >= 1:
                frac_binary += '1'
                frac_part -= 1
            else:
                frac_binary += '0'
        
        return sign, int_binary + '.' + frac_binary
    
    @staticmethod
    def normalize(sign, binary_str):
        """规格化"""
        parts = binary_str.split('.')
        int_part = parts[0]
        frac_part = parts[1] if len(parts) > 1 else ''
        
        # 找到第一个1的位置
        combined = int_part + frac_part
        first_one = combined.find('1')
        
        if first_one == -1:
            return 0, '0'
        
        # 计算指数
        if '.' in binary_str:
            exponent = len(int_part) - 1
        else:
            exponent = first_one
        
        # 提取尾数（第一个1之后的部分）
        mantissa = combined[first_one + 1:]
        
        return exponent, mantissa
    
    @staticmethod
    def encode_ieee754(num):
        """编码为IEEE 754"""
        sign, binary = IEEE754Converter.float_to_binary(num)
        exponent, mantissa = IEEE754Converter.normalize(sign, binary)
        
        # 指数偏移（单精度：127）
        biased_exp = exponent + 127
        exp_bits = format(biased_exp, '08b')
        
        # 尾数补齐23位
        mantissa_bits = (mantissa + '0' * 23)[:23]
        
        # 组合
        ieee754 = sign + exp_bits + mantissa_bits
        
        return ieee754
    
    @staticmethod
    def decode_ieee754(binary_str):
        """解码IEEE 754"""
        sign = int(binary_str[0])
        exponent = int(binary_str[1:9], 2)
        mantissa = binary_str[9:]
        
        # 检查特殊值
        if exponent == 255:
            if int(mantissa, 2) == 0:
                return float('inf') if sign == 0 else float('-inf')
            else:
                return float('nan')
        
        if exponent == 0:
            if int(mantissa, 2) == 0:
                return 0.0
            # 非规格化数
            return (-1)**sign * float(int(mantissa, 2)) * 2**(-126) / (2**23)
        
        # 规格化数
        mantissa_value = 1.0 + int(mantissa, 2) / (2**23)
        value = (-1)**sign * mantissa_value * 2**(exponent - 127)
        
        return value

# 测试
converter = IEEE754Converter()
ieee = converter.encode_ieee754(5.75)
print(f"5.75 的IEEE 754表示: {ieee}")
print(f"解码结果: {converter.decode_ieee754(ieee)}")
```

### 1.4 BCD码（Binary-Coded Decimal）

**定义**：用4位二进制表示1位十进制数。

**8421码（最常用）：**

| 十进制 | BCD码 | 十进制 | BCD码 |
|--------|-------|--------|-------|
| 0 | 0000 | 5 | 0101 |
| 1 | 0001 | 6 | 0110 |
| 2 | 0010 | 7 | 0111 |
| 3 | 0011 | 8 | 1000 |
| 4 | 0100 | 9 | 1001 |

**示例**：$95_{10} = 1001\ 0101_{BCD}$

**BCD加法：**

如果结果 > 9 或有进位，需要加6修正。

```python
class BCDArithmetic:
    """BCD码运算器"""
    
    @staticmethod
    def decimal_to_bcd(num):
        """十进制转BCD"""
        bcd = ''
        for digit in str(num):
            bcd += format(int(digit), '04b')
        return bcd
    
    @staticmethod
    def bcd_to_decimal(bcd):
        """BCD转十进制"""
        decimal = 0
        for i in range(0, len(bcd), 4):
            digit = int(bcd[i:i+4], 2)
            decimal = decimal * 10 + digit
        return decimal
    
    @staticmethod
    def bcd_add(a, b):
        """BCD加法"""
        # 转为十进制计算（简化实现）
        dec_a = BCDArithmetic.bcd_to_decimal(a)
        dec_b = BCDArithmetic.bcd_to_decimal(b)
        result = dec_a + dec_b
        return BCDArithmetic.decimal_to_bcd(result)
    
    @staticmethod
    def bcd_add_hardware(a_bcd, b_bcd):
        """硬件BCD加法（模拟修正过程）"""
        # 按4位分组
        a_digits = [int(a_bcd[i:i+4], 2) for i in range(0, len(a_bcd), 4)]
        b_digits = [int(b_bcd[i:i+4], 2) for i in range(0, len(b_bcd), 4)]
        
        result = []
        carry = 0
        
        # 从低位到高位
        for i in range(len(a_digits) - 1, -1, -1):
            sum_val = a_digits[i] + b_digits[i] + carry
            
            # BCD修正：如果结果>9，加6
            if sum_val > 9:
                sum_val += 6
                carry = 1
            else:
                carry = 0
            
            result.insert(0, format(sum_val % 16, '04b'))
        
        if carry:
            result.insert(0, '0001')
        
        return ''.join(result)

# 测试
bcd = BCDArithmetic()
a = bcd.decimal_to_bcd(25)  # 0010 0101
b = bcd.decimal_to_bcd(38)  # 0011 1000
result = bcd.bcd_add_hardware(a, b)
print(f"25 + 38 (BCD) = {bcd.bcd_to_decimal(result)}")  # 63
```

**余3码（Excess-3 Code）**：

BCD码 + 3，用于简化减法运算。

| 十进制 | 余3码 |
|--------|-------|
| 0 | 0011 |
| 1 | 0100 |
| 2 | 0101 |
| 5 | 1000 |
| 9 | 1100 |

### 1.5 格雷码（Gray Code）

**定义**：相邻数值只有1位不同的编码。

**二进制转格雷码：**

$$
G_i = B_i \oplus B_{i+1}
$$

**格雷码转二进制：**

$$
B_i = G_i \oplus B_{i+1}
$$

| 十进制 | 二进制 | 格雷码 |
|--------|--------|--------|
| 0 | 000 | 000 |
| 1 | 001 | 001 |
| 2 | 010 | 011 |
| 3 | 011 | 010 |
| 4 | 100 | 110 |
| 5 | 101 | 111 |
| 6 | 110 | 101 |
| 7 | 111 | 100 |

**应用**：
+ ✅ 旋转编码器（避免中间态错误）
+ ✅ ADC/DAC转换
+ ✅ 通信系统

```python
class GrayCode:
    """格雷码转换器"""
    
    @staticmethod
    def binary_to_gray(binary):
        """二进制转格雷码"""
        gray = binary[0]  # 最高位保持不变
        for i in range(1, len(binary)):
            # XOR运算
            gray += str(int(binary[i-1]) ^ int(binary[i]))
        return gray
    
    @staticmethod
    def gray_to_binary(gray):
        """格雷码转二进制"""
        binary = gray[0]  # 最高位保持不变
        for i in range(1, len(gray)):
            # XOR累积
            binary += str(int(binary[i-1]) ^ int(gray[i]))
        return binary
    
    @staticmethod
    def decimal_to_gray(num, bits=8):
        """十进制转格雷码"""
        binary = format(num, f'0{bits}b')
        return GrayCode.binary_to_gray(binary)
    
    @staticmethod
    def gray_to_decimal(gray):
        """格雷码转十进制"""
        binary = GrayCode.gray_to_binary(gray)
        return int(binary, 2)

# 测试
gc = GrayCode()
print("十进制 | 二进制   | 格雷码")
print("------|---------|--------")
for i in range(8):
    binary = format(i, '03b')
    gray = gc.binary_to_gray(binary)
    print(f"  {i}    | {binary}     | {gray}")

# 验证转换
assert gc.gray_to_decimal('110') == 4
print("\n格雷码转换验证成功！")
```

### 1.6 差错检测与纠正码

#### 奇偶校验码（Parity Check）

**偶校验**：使1的个数为偶数

$$
P = d_0 \oplus d_1 \oplus d_2 \oplus \cdots \oplus d_{n-1}
$$

```python
def add_parity(data, even=True):
    """添加奇偶校验位"""
    ones = data.count('1')
    if even:
        parity = '0' if ones % 2 == 0 else '1'
    else:
        parity = '1' if ones % 2 == 0 else '0'
    return data + parity

def check_parity(data_with_parity, even=True):
    """检查奇偶校验"""
    ones = data_with_parity.count('1')
    if even:
        return ones % 2 == 0
    else:
        return ones % 2 == 1

# 测试
data = "1011001"
encoded = add_parity(data, even=True)
print(f"原始数据: {data}")
print(f"编码后: {encoded}")
print(f"校验通过: {check_parity(encoded, even=True)}")
```

#### 海明码（Hamming Code）

**原理**：能纠正1位错误，检测2位错误。

**校验位位置**：$2^0, 2^1, 2^2, \ldots$（1, 2, 4, 8, ...）

**示例**：编码4位数据 $d = 1011$

```plain
位置:  1  2  3  4  5  6  7
     p1 p2 d1 p4 d2 d3 d4
     p1 p2  1 p4  0  1  1
```

**校验位计算：**
+ $p_1$: 检查位置 1, 3, 5, 7（二进制最低位为1）
+ $p_2$: 检查位置 2, 3, 6, 7（二进制次低位为1）
+ $p_4$: 检查位置 4, 5, 6, 7（二进制第3位为1）

```python
class HammingCode:
    """海明码编码器/解码器"""
    
    @staticmethod
    def encode(data):
        """海明码编码"""
        n = len(data)
        # 计算需要的校验位数量
        r = 0
        while 2**r < n + r + 1:
            r += 1
        
        # 创建编码数组（总长度 = 数据位 + 校验位）
        total_len = n + r
        encoded = ['0'] * total_len
        
        # 填充数据位（跳过校验位位置）
        data_idx = 0
        for i in range(1, total_len + 1):
            if (i & (i - 1)) != 0:  # 不是2的幂
                encoded[i - 1] = data[data_idx]
                data_idx += 1
        
        # 计算校验位
        for i in range(r):
            parity_pos = 2**i
            parity = 0
            
            for j in range(1, total_len + 1):
                if j & parity_pos:
                    parity ^= int(encoded[j - 1])
            
            encoded[parity_pos - 1] = str(parity)
        
        return ''.join(encoded)
    
    @staticmethod
    def decode(encoded):
        """海明码解码并纠错"""
        n = len(encoded)
        r = 0
        while 2**r < n + 1:
            r += 1
        
        # 计算校验子
        error_pos = 0
        for i in range(r):
            parity_pos = 2**i
            parity = 0
            
            for j in range(1, n + 1):
                if j & parity_pos:
                    parity ^= int(encoded[j - 1])
            
            if parity != 0:
                error_pos += parity_pos
        
        # 纠错
        if error_pos > 0:
            print(f"检测到错误位置: {error_pos}")
            corrected = list(encoded)
            corrected[error_pos - 1] = '1' if corrected[error_pos - 1] == '0' else '0'
            encoded = ''.join(corrected)
        
        # 提取数据位
        data = ''
        for i in range(1, n + 1):
            if (i & (i - 1)) != 0:  # 不是2的幂
                data += encoded[i - 1]
        
        return data, error_pos

# 测试
hamming = HammingCode()
data = "1011"
encoded = hamming.encode(data)
print(f"原始数据: {data}")
print(f"海明编码: {encoded}")

# 模拟1位错误
error_encoded = list(encoded)
error_encoded[4] = '1' if error_encoded[4] == '0' else '0'
error_encoded = ''.join(error_encoded)
print(f"引入错误: {error_encoded}")

decoded, error_pos = hamming.decode(error_encoded)
print(f"纠错后数据: {decoded}")
print(f"纠错成功: {decoded == data}")
```

#### CRC循环冗余校验（Cyclic Redundancy Check）

**原理**：使用多项式除法生成校验码。

**常用生成多项式：**
+ CRC-8: $x^8 + x^2 + x + 1$
+ CRC-16: $x^{16} + x^{15} + x^2 + 1$
+ CRC-32: $x^{32} + x^{26} + x^{23} + \cdots + x + 1$

```python
class CRC:
    """CRC校验器"""
    
    def __init__(self, polynomial):
        """
        polynomial: 生成多项式（二进制字符串）
        例如：'1011' 表示 x^3 + x + 1
        """
        self.polynomial = polynomial
        self.poly_len = len(polynomial)
    
    def xor(self, a, b):
        """模2除法的XOR运算"""
        result = ''
        for i in range(len(b)):
            result += '0' if a[i] == b[i] else '1'
        return result
    
    def mod2_division(self, dividend):
        """模2除法"""
        dividend = list(dividend)
        
        for i in range(len(dividend) - self.poly_len + 1):
            if dividend[i] == '1':
                # XOR操作
                for j in range(self.poly_len):
                    dividend[i + j] = '0' if dividend[i + j] == self.polynomial[j] else '1'
        
        # 返回余数
        return ''.join(dividend[-(self.poly_len - 1):])
    
    def encode(self, data):
        """生成CRC校验码"""
        # 数据后附加 (n-1) 个0
        padded = data + '0' * (self.poly_len - 1)
        remainder = self.mod2_division(padded)
        return data + remainder
    
    def check(self, received):
        """校验接收数据"""
        remainder = self.mod2_division(received)
        return int(remainder) == 0

# 测试CRC-4
crc = CRC('1011')  # x^3 + x + 1
data = '110101'
encoded = crc.encode(data)
print(f"原始数据: {data}")
print(f"CRC编码: {encoded}")
print(f"校验通过: {crc.check(encoded)}")

# 引入错误
error_data = list(encoded)
error_data[3] = '1' if error_data[3] == '0' else '0'
error_data = ''.join(error_data)
print(f"错误数据: {error_data}")
print(f"校验通过: {crc.check(error_data)}")
```

**CRC-32完整实现：**

```python
def crc32(data):
    """CRC-32校验（使用标准算法）"""
    crc = 0xFFFFFFFF
    polynomial = 0xEDB88320  # CRC-32多项式
    
    for byte in data:
        crc ^= byte
        for _ in range(8):
            if crc & 1:
                crc = (crc >> 1) ^ polynomial
            else:
                crc >>= 1
    
    return crc ^ 0xFFFFFFFF

# 测试
data = b"Hello, World!"
checksum = crc32(data)
print(f"CRC-32校验码: {checksum:08X}")

# 验证
import zlib
assert checksum == zlib.crc32(data)
print("CRC-32实现正确！")
```

### 1.7 字符编码

#### ASCII码

**标准ASCII（7位）**：0-127

| 范围 | 类型 | 示例 |
|------|------|------|
| 0-31 | 控制字符 | `\n`, `\r`, `\t` |
| 32-47 | 标点符号 | `!`, `"`, `#` |
| 48-57 | 数字 | `0`-`9` |
| 65-90 | 大写字母 | `A`-`Z` |
| 97-122 | 小写字母 | `a`-`z` |

```python
# ASCII编码示例
text = "Hello"
ascii_codes = [ord(char) for char in text]
print(f"'{text}' 的ASCII码: {ascii_codes}")

# 二进制表示
for char in text:
    print(f"{char}: {ord(char):3d} = {ord(char):08b}")
```

#### Unicode与UTF-8

**UTF-8变长编码：**

| Unicode范围 | UTF-8编码 | 字节数 |
|------------|----------|--------|
| U+0000 - U+007F | 0xxxxxxx | 1 |
| U+0080 - U+07FF | 110xxxxx 10xxxxxx | 2 |
| U+0800 - U+FFFF | 1110xxxx 10xxxxxx 10xxxxxx | 3 |
| U+10000 - U+10FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx | 4 |

```python
def char_to_utf8(char):
    """字符转UTF-8编码"""
    utf8_bytes = char.encode('utf-8')
    binary = ' '.join(format(byte, '08b') for byte in utf8_bytes)
    
    print(f"字符: {char}")
    print(f"Unicode: U+{ord(char):04X}")
    print(f"UTF-8: {binary}")
    print(f"字节数: {len(utf8_bytes)}")

# 测试
char_to_utf8('A')      # 1字节
char_to_utf8('中')     # 3字节
char_to_utf8('😊')     # 4字节
```

---

**本章完**
