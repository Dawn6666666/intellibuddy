# è®¡ç®—æœºç½‘ç»œ - (ä¸€)åº”ç”¨å±‚åè®®

å­¦ä¹ HTTPã€DNSç­‰åè®®ã€‚

---

# è®¡ç®—æœºç½‘ç»œ

> ğŸ’¡ **è¯¾ç¨‹ä¿¡æ¯**
> - å­¦ä¹ æ—¶é•¿ï¼š150å°æ—¶
> - éš¾åº¦ç­‰çº§ï¼šâ­â­â­â­ (é«˜)
> - **ç½‘ç»œé€šä¿¡çš„æ ¸å¿ƒåŸç†**

---

## ğŸ“š OSIä¸ƒå±‚æ¨¡å‹ vs TCP/IPå››å±‚æ¨¡å‹

| OSI | TCP/IP | åè®® | åŠŸèƒ½ |
|-----|--------|------|------|
| åº”ç”¨å±‚ | åº”ç”¨å±‚ | HTTP, FTP, SMTP, DNS | ç”¨æˆ·æ¥å£ |
| è¡¨ç¤ºå±‚ | â†‘ | SSL/TLS | æ•°æ®æ ¼å¼è½¬æ¢ |
| ä¼šè¯å±‚ | â†‘ | - | ä¼šè¯ç®¡ç† |
| ä¼ è¾“å±‚ | ä¼ è¾“å±‚ | TCP, UDP | ç«¯åˆ°ç«¯é€šä¿¡ |
| ç½‘ç»œå±‚ | ç½‘ç»œå±‚ | IP, ICMP, ARP | è·¯ç”±é€‰æ‹© |
| æ•°æ®é“¾è·¯å±‚ | é“¾è·¯å±‚ | Ethernet, WiFi | å¸§ä¼ è¾“ |
| ç‰©ç†å±‚ | â†‘ | - | æ¯”ç‰¹ä¼ è¾“ |

---

## 1. åº”ç”¨å±‚åè®®

### 1.1 HTTPåè®®è¯¦è§£

#### HTTPè¯·æ±‚æ–¹æ³•

| æ–¹æ³• | è¯´æ˜ | å¹‚ç­‰æ€§ | å®‰å…¨æ€§ |
|------|------|--------|--------|
| GET | è·å–èµ„æº | âœ… | âœ… |
| POST | æäº¤æ•°æ® | âŒ | âŒ |
| PUT | æ›´æ–°èµ„æº | âœ… | âŒ |
| DELETE | åˆ é™¤èµ„æº | âœ… | âŒ |
| HEAD | è·å–å¤´éƒ¨ | âœ… | âœ… |
| OPTIONS | è·å–æ”¯æŒçš„æ–¹æ³• | âœ… | âœ… |
| PATCH | éƒ¨åˆ†æ›´æ–° | âŒ | âŒ |

**HTTPè¯·æ±‚æ ¼å¼ï¼š**

```plain
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0
Accept: text/html
Connection: keep-alive

[è¯·æ±‚ä½“]
```

**HTTPå“åº”æ ¼å¼ï¼š**

```plain
HTTP/1.1 200 OK
Content-Type: text/html; charset=UTF-8
Content-Length: 1234
Server: Apache/2.4.41

<!DOCTYPE html>
<html>...
```

#### HTTPçŠ¶æ€ç 

| ç±»å‹ | èŒƒå›´ | å¸¸ç”¨çŠ¶æ€ç  | è¯´æ˜ |
|------|------|-----------|------|
| ä¿¡æ¯ | 1xx | 100 Continue | ç»§ç»­è¯·æ±‚ |
| æˆåŠŸ | 2xx | 200 OK, 201 Created, 204 No Content | è¯·æ±‚æˆåŠŸ |
| é‡å®šå‘ | 3xx | 301 Moved, 302 Found, 304 Not Modified | èµ„æºé‡å®šå‘ |
| å®¢æˆ·ç«¯é”™è¯¯ | 4xx | 400 Bad Request, 401 Unauthorized, 404 Not Found | å®¢æˆ·ç«¯é”™è¯¯ |
| æœåŠ¡å™¨é”™è¯¯ | 5xx | 500 Internal Error, 502 Bad Gateway, 503 Unavailable | æœåŠ¡å™¨é”™è¯¯ |

**å®Œæ•´HTTPå®¢æˆ·ç«¯å®ç°ï¼š**

```python
import socket
import urllib.parse

class HTTPClient:
    """å®Œæ•´HTTPå®¢æˆ·ç«¯"""
    
    def __init__(self):
        self.timeout = 10
    
    def request(self, url, method='GET', headers=None, body=None):
        """å‘é€HTTPè¯·æ±‚"""
        # è§£æURL
        parsed = urllib.parse.urlparse(url)
        host = parsed.hostname
        port = parsed.port or 80
        path = parsed.path or '/'
        
        # æ„å»ºè¯·æ±‚
        request_line = f"{method} {path} HTTP/1.1\r\n"
        
        # é»˜è®¤å¤´éƒ¨
        default_headers = {
            'Host': host,
            'User-Agent': 'PythonHTTPClient/1.0',
            'Accept': '*/*',
            'Connection': 'close'
        }
        
        if headers:
            default_headers.update(headers)
        
        # æ·»åŠ Content-Length
        if body:
            default_headers['Content-Length'] = str(len(body))
        
        # ç»„è£…å¤´éƒ¨
        header_lines = ''.join(f"{k}: {v}\r\n" for k, v in default_headers.items())
        
        # å®Œæ•´è¯·æ±‚
        request = request_line + header_lines + '\r\n'
        if body:
            request += body
        
        # å‘é€è¯·æ±‚
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(self.timeout)
        sock.connect((host, port))
        sock.send(request.encode())
    
    # æ¥æ”¶å“åº”
        response = b''
        while True:
            chunk = sock.recv(4096)
            if not chunk:
                break
            response += chunk
        
        sock.close()
        
        return self._parse_response(response.decode('utf-8', errors='ignore'))
    
    def _parse_response(self, response):
        """è§£æHTTPå“åº”"""
        lines = response.split('\r\n')
        
        # çŠ¶æ€è¡Œ
        status_line = lines[0]
        parts = status_line.split(' ', 2)
        http_version = parts[0]
        status_code = int(parts[1])
        reason = parts[2] if len(parts) > 2 else ''
        
        # å¤´éƒ¨
        headers = {}
        i = 1
        while i < len(lines) and lines[i]:
            if ':' in lines[i]:
                key, value = lines[i].split(':', 1)
                headers[key.strip()] = value.strip()
            i += 1
        
        # ä¸»ä½“
        body = '\r\n'.join(lines[i+1:])
        
        return {
            'status_code': status_code,
            'reason': reason,
            'headers': headers,
            'body': body
        }
    
    def get(self, url, headers=None):
        """GETè¯·æ±‚"""
        return self.request(url, 'GET', headers)
    
    def post(self, url, data, headers=None):
        """POSTè¯·æ±‚"""
        if headers is None:
            headers = {}
        headers['Content-Type'] = 'application/x-www-form-urlencoded'
        return self.request(url, 'POST', headers, data)

# ä½¿ç”¨ç¤ºä¾‹
client = HTTPClient()
response = client.get('http://www.example.com')
print(f"çŠ¶æ€ç : {response['status_code']}")
print(f"å†…å®¹é•¿åº¦: {len(response['body'])}")
```

#### HTTP/1.1 vs HTTP/2 vs HTTP/3

| ç‰¹æ€§ | HTTP/1.1 | HTTP/2 | HTTP/3 |
|------|----------|--------|--------|
| ä¼ è¾“åè®® | TCP | TCP | QUIC (UDP) |
| å¤šè·¯å¤ç”¨ | âŒ (éœ€å¤šä¸ªè¿æ¥) | âœ… | âœ… |
| å¤´éƒ¨å‹ç¼© | âŒ | âœ… (HPACK) | âœ… (QPACK) |
| æœåŠ¡å™¨æ¨é€ | âŒ | âœ… | âœ… |
| é˜Ÿå¤´é˜»å¡ | âœ… ä¸¥é‡ | ğŸ”¶ TCPå±‚ | âŒ æ—  |
| äºŒè¿›åˆ¶å¸§ | âŒ æ–‡æœ¬ | âœ… | âœ… |
| è¿æ¥å»ºç«‹ | 3æ¬¡æ¡æ‰‹ | 3æ¬¡æ¡æ‰‹ | 0-RTT |

**HTTP/2å¤šè·¯å¤ç”¨ç¤ºä¾‹ï¼š**

```python
class HTTP2Stream:
    """HTTP/2æµæ¨¡æ‹Ÿ"""
    
    def __init__(self, stream_id):
        self.stream_id = stream_id
        self.state = 'idle'
        self.headers = {}
        self.data = b''
    
    def send_headers(self, headers):
        """å‘é€å¤´éƒ¨å¸§"""
        self.headers = headers
        self.state = 'open'
        print(f"Stream {self.stream_id}: HEADERS sent")
    
    def send_data(self, data):
        """å‘é€æ•°æ®å¸§"""
        self.data += data
        print(f"Stream {self.stream_id}: DATA sent ({len(data)} bytes)")
    
    def close(self):
        """å…³é—­æµ"""
        self.state = 'closed'
        print(f"Stream {self.stream_id}: CLOSED")

class HTTP2Connection:
    """HTTP/2è¿æ¥ï¼ˆç®€åŒ–ï¼‰"""
    
    def __init__(self):
        self.streams = {}
        self.next_stream_id = 1
    
    def create_stream(self):
        """åˆ›å»ºæ–°æµ"""
        stream_id = self.next_stream_id
        self.next_stream_id += 2  # å¥‡æ•°ä¸ºå®¢æˆ·ç«¯æµ
        self.streams[stream_id] = HTTP2Stream(stream_id)
        return self.streams[stream_id]
    
    def multiplex_demo(self):
        """å¤šè·¯å¤ç”¨æ¼”ç¤º"""
        # åŒæ—¶è¯·æ±‚å¤šä¸ªèµ„æº
        stream1 = self.create_stream()
        stream1.send_headers({':method': 'GET', ':path': '/index.html'})
        
        stream2 = self.create_stream()
        stream2.send_headers({':method': 'GET', ':path': '/style.css'})
        
        stream3 = self.create_stream()
        stream3.send_headers({':method': 'GET', ':path': '/script.js'})
        
        # äº¤é”™å‘é€æ•°æ®
        stream1.send_data(b'HTML chunk 1')
        stream2.send_data(b'CSS chunk 1')
        stream1.send_data(b'HTML chunk 2')
        stream3.send_data(b'JS chunk 1')
        
        # å…³é—­æµ
        stream1.close()
        stream2.close()
        stream3.close()

# æ¼”ç¤º
conn = HTTP2Connection()
conn.multiplex_demo()
```

### 1.2 DNSåŸŸåç³»ç»Ÿ

#### DNSæŸ¥è¯¢ç±»å‹

| æŸ¥è¯¢ç±»å‹ | è¯´æ˜ |
|---------|------|
| Aè®°å½• | IPv4åœ°å€ |
| AAAAè®°å½• | IPv6åœ°å€ |
| CNAME | åˆ«åè®°å½• |
| MX | é‚®ä»¶æœåŠ¡å™¨ |
| NS | åŸŸåæœåŠ¡å™¨ |
| TXT | æ–‡æœ¬è®°å½• |
| PTR | åå‘æŸ¥è¯¢ |

**DNSé€’å½’æŸ¥è¯¢è¿‡ç¨‹ï¼š**

```plain
å®¢æˆ·ç«¯ â†’ æœ¬åœ°DNSæœåŠ¡å™¨ â†’ æ ¹DNSæœåŠ¡å™¨ â†’ é¡¶çº§åŸŸDNS â†’ æƒå¨DNS â†’ è¿”å›IP
```

**å®Œæ•´DNSè§£æå™¨ï¼š**

```python
import socket
import struct

class DNSResolver:
    """DNSè§£æå™¨ï¼ˆç®€åŒ–ç‰ˆï¼‰"""
    
    DNS_SERVERS = ['8.8.8.8', '8.8.4.4']  # Google DNS
    
    def __init__(self):
        self.cache = {}
    
    def query(self, domain, dns_server='8.8.8.8'):
    """DNSæŸ¥è¯¢"""
        # æ£€æŸ¥ç¼“å­˜
        if domain in self.cache:
            print(f"ç¼“å­˜å‘½ä¸­: {domain}")
            return self.cache[domain]
        
        # ä½¿ç”¨socketçš„é«˜çº§APIï¼ˆå®é™…DNSåŒ…æ„å»ºè¾ƒå¤æ‚ï¼‰
    try:
        ip = socket.gethostbyname(domain)
            self.cache[domain] = ip
            print(f"DNSæŸ¥è¯¢: {domain} â†’ {ip}")
        return ip
        except socket.gaierror as e:
            print(f"DNSæŸ¥è¯¢å¤±è´¥: {domain} - {e}")
            return None
    
    def reverse_lookup(self, ip):
        """åå‘DNSæŸ¥è¯¢"""
        try:
            hostname = socket.gethostbyaddr(ip)
            print(f"åå‘æŸ¥è¯¢: {ip} â†’ {hostname[0]}")
            return hostname[0]
        except socket.herror:
            print(f"åå‘æŸ¥è¯¢å¤±è´¥: {ip}")
            return None
    
    def build_dns_query(self, domain):
        """æ„å»ºDNSæŸ¥è¯¢åŒ…"""
        # DNSå¤´éƒ¨ï¼ˆ12å­—èŠ‚ï¼‰
        transaction_id = 0x1234
        flags = 0x0100  # æ ‡å‡†æŸ¥è¯¢
        questions = 1
        answer_rrs = 0
        authority_rrs = 0
        additional_rrs = 0
        
        header = struct.pack('!HHHHHH', 
            transaction_id, flags, questions, 
            answer_rrs, authority_rrs, additional_rrs
        )
        
        # é—®é¢˜éƒ¨åˆ†
        question = b''
        for part in domain.split('.'):
            question += struct.pack('!B', len(part)) + part.encode()
        question += b'\x00'  # ç»“æŸç¬¦
        
        # æŸ¥è¯¢ç±»å‹ï¼šAè®°å½•(1)ï¼Œç±»ï¼šIN(1)
        question += struct.pack('!HH', 1, 1)
        
        return header + question
    
    def parse_dns_response(self, response):
        """è§£æDNSå“åº”ï¼ˆç®€åŒ–ï¼‰"""
        # å®é™…è§£æéœ€è¦å¤„ç†å¤æ‚çš„å‹ç¼©æŒ‡é’ˆç­‰
        # è¿™é‡Œä»…æ¼”ç¤ºåŸºæœ¬ç»“æ„
        header = struct.unpack('!HHHHHH', response[:12])
        print(f"DNSå“åº”å¤´éƒ¨: {header}")
        return header

# ä½¿ç”¨ç¤ºä¾‹
resolver = DNSResolver()
resolver.query('www.google.com')
resolver.query('www.github.com')
resolver.reverse_lookup('8.8.8.8')
```

**DNSç¼“å­˜æ¨¡æ‹Ÿï¼š**

```python
import time

class DNSCache:
    """DNSç¼“å­˜ç³»ç»Ÿ"""
    
    def __init__(self, ttl=300):
        self.cache = {}
        self.default_ttl = ttl
    
    def set(self, domain, ip, ttl=None):
        """è®¾ç½®ç¼“å­˜"""
        if ttl is None:
            ttl = self.default_ttl
        expire_time = time.time() + ttl
        self.cache[domain] = {
            'ip': ip,
            'expire': expire_time
        }
        print(f"ç¼“å­˜è®¾ç½®: {domain} â†’ {ip} (TTL: {ttl}s)")
    
    def get(self, domain):
        """è·å–ç¼“å­˜"""
        if domain not in self.cache:
            return None
        
        entry = self.cache[domain]
        
        # æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
        if time.time() > entry['expire']:
            print(f"ç¼“å­˜è¿‡æœŸ: {domain}")
            del self.cache[domain]
        return None

        print(f"ç¼“å­˜å‘½ä¸­: {domain} â†’ {entry['ip']}")
        return entry['ip']
    
    def clear(self):
        """æ¸…ç©ºç¼“å­˜"""
        self.cache.clear()
        print("ç¼“å­˜å·²æ¸…ç©º")

# æµ‹è¯•
cache = DNSCache(ttl=5)
cache.set('www.example.com', '93.184.216.34')
cache.get('www.example.com')  # å‘½ä¸­
time.sleep(6)
cache.get('www.example.com')  # è¿‡æœŸ
```

### 1.3 SMTP/POP3/IMAPé‚®ä»¶åè®®

#### SMTPï¼ˆSimple Mail Transfer Protocolï¼‰

**SMTPå‘é€æµç¨‹ï¼š**

```plain
1. EHLO - å®¢æˆ·ç«¯æ ‡è¯†
2. AUTH - èº«ä»½è®¤è¯
3. MAIL FROM - å‘ä»¶äºº
4. RCPT TO - æ”¶ä»¶äºº
5. DATA - é‚®ä»¶å†…å®¹
6. QUIT - ç»“æŸè¿æ¥
```

**SMTPå®¢æˆ·ç«¯å®ç°ï¼š**

```python
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

class SMTPClient:
    """SMTPé‚®ä»¶å®¢æˆ·ç«¯"""
    
    def __init__(self, server, port=587):
        self.server = server
        self.port = port
        self.smtp = None
    
    def connect(self, username, password):
        """è¿æ¥SMTPæœåŠ¡å™¨"""
        self.smtp = smtplib.SMTP(self.server, self.port)
        self.smtp.starttls()  # å¯ç”¨TLSåŠ å¯†
        self.smtp.login(username, password)
        print(f"å·²è¿æ¥åˆ°SMTPæœåŠ¡å™¨: {self.server}")
    
    def send_email(self, from_addr, to_addr, subject, body, html=False):
        """å‘é€é‚®ä»¶"""
        msg = MIMEMultipart('alternative')
        msg['From'] = from_addr
        msg['To'] = to_addr
        msg['Subject'] = subject
        
        # æ·»åŠ é‚®ä»¶å†…å®¹
        if html:
            part = MIMEText(body, 'html')
        else:
            part = MIMEText(body, 'plain')
        
        msg.attach(part)
        
        # å‘é€
        self.smtp.send_message(msg)
        print(f"é‚®ä»¶å·²å‘é€: {from_addr} â†’ {to_addr}")
    
    def close(self):
        """å…³é—­è¿æ¥"""
        if self.smtp:
            self.smtp.quit()
            print("SMTPè¿æ¥å·²å…³é—­")

# ä½¿ç”¨ç¤ºä¾‹ï¼ˆéœ€è¦çœŸå®SMTPæœåŠ¡å™¨ï¼‰
# client = SMTPClient('smtp.gmail.com', 587)
# client.connect('your-email@gmail.com', 'your-password')
# client.send_email(
#     'sender@example.com',
#     'recipient@example.com',
#     'Test Email',
#     'This is a test email.'
# )
# client.close()
```

#### POP3åè®®

**POP3å‘½ä»¤ï¼š**

| å‘½ä»¤ | è¯´æ˜ |
|------|------|
| USER | ç”¨æˆ·å |
| PASS | å¯†ç  |
| STAT | é‚®ä»¶ç»Ÿè®¡ |
| LIST | é‚®ä»¶åˆ—è¡¨ |
| RETR | è·å–é‚®ä»¶ |
| DELE | åˆ é™¤é‚®ä»¶ |
| QUIT | é€€å‡º |

```python
import poplib

class POP3Client:
    """POP3é‚®ä»¶å®¢æˆ·ç«¯"""
    
    def __init__(self, server, port=995):
        self.server = server
        self.port = port
        self.pop = None
    
    def connect(self, username, password):
        """è¿æ¥POP3æœåŠ¡å™¨"""
        self.pop = poplib.POP3_SSL(self.server, self.port)
        self.pop.user(username)
        self.pop.pass_(password)
        print(f"å·²è¿æ¥åˆ°POP3æœåŠ¡å™¨: {self.server}")
    
    def get_mail_count(self):
        """è·å–é‚®ä»¶æ•°é‡"""
        stat = self.pop.stat()
        print(f"é‚®ä»¶æ•°é‡: {stat[0]}, æ€»å¤§å°: {stat[1]} bytes")
        return stat[0]
    
    def list_mails(self):
        """åˆ—å‡ºæ‰€æœ‰é‚®ä»¶"""
        response, mails, octets = self.pop.list()
        for mail in mails:
            print(f"é‚®ä»¶: {mail.decode()}")
    
    def retrieve_mail(self, index):
        """è·å–æŒ‡å®šé‚®ä»¶"""
        response, lines, octets = self.pop.retr(index)
        print(f"é‚®ä»¶ {index}:")
        for line in lines[:10]:  # åªæ˜¾ç¤ºå‰10è¡Œ
            print(line.decode())
    
    def close(self):
        """å…³é—­è¿æ¥"""
        if self.pop:
            self.pop.quit()
            print("POP3è¿æ¥å·²å…³é—­")

# ä½¿ç”¨ç¤ºä¾‹
# client = POP3Client('pop.gmail.com')
# client.connect('your-email@gmail.com', 'your-password')
# client.get_mail_count()
# client.list_mails()
# client.close()
```

### 1.4 FTPæ–‡ä»¶ä¼ è¾“åè®®

**FTPå·¥ä½œæ¨¡å¼ï¼š**

+ **ä¸»åŠ¨æ¨¡å¼ï¼ˆPORTï¼‰**ï¼šæœåŠ¡å™¨ä¸»åŠ¨è¿æ¥å®¢æˆ·ç«¯
+ **è¢«åŠ¨æ¨¡å¼ï¼ˆPASVï¼‰**ï¼šå®¢æˆ·ç«¯ä¸»åŠ¨è¿æ¥æœåŠ¡å™¨ï¼ˆé˜²ç«å¢™å‹å¥½ï¼‰

**FTPå‘½ä»¤ï¼š**

| å‘½ä»¤ | è¯´æ˜ |
|------|------|
| USER | ç”¨æˆ·å |
| PASS | å¯†ç  |
| PWD | æ˜¾ç¤ºå½“å‰ç›®å½• |
| CWD | åˆ‡æ¢ç›®å½• |
| LIST | åˆ—å‡ºæ–‡ä»¶ |
| RETR | ä¸‹è½½æ–‡ä»¶ |
| STOR | ä¸Šä¼ æ–‡ä»¶ |
| DELE | åˆ é™¤æ–‡ä»¶ |
| QUIT | é€€å‡º |

```python
from ftplib import FTP
import os

class FTPClient:
    """FTPå®¢æˆ·ç«¯"""
    
    def __init__(self, host, port=21):
        self.ftp = FTP()
        self.ftp.connect(host, port)
        print(f"å·²è¿æ¥åˆ°FTPæœåŠ¡å™¨: {host}")
    
    def login(self, username='anonymous', password=''):
        """ç™»å½•"""
        self.ftp.login(username, password)
        print(f"ç™»å½•æˆåŠŸ: {username}")
        print(f"æ¬¢è¿ä¿¡æ¯: {self.ftp.getwelcome()}")
    
    def list_files(self):
        """åˆ—å‡ºå½“å‰ç›®å½•æ–‡ä»¶"""
        files = []
        self.ftp.dir(files.append)
        print("æ–‡ä»¶åˆ—è¡¨:")
        for f in files:
            print(f)
        return files
    
    def download_file(self, remote_path, local_path):
        """ä¸‹è½½æ–‡ä»¶"""
        with open(local_path, 'wb') as f:
            self.ftp.retrbinary(f'RETR {remote_path}', f.write)
        print(f"æ–‡ä»¶å·²ä¸‹è½½: {remote_path} â†’ {local_path}")
    
    def upload_file(self, local_path, remote_path):
        """ä¸Šä¼ æ–‡ä»¶"""
        with open(local_path, 'rb') as f:
            self.ftp.storbinary(f'STOR {remote_path}', f)
        print(f"æ–‡ä»¶å·²ä¸Šä¼ : {local_path} â†’ {remote_path}")
    
    def delete_file(self, remote_path):
        """åˆ é™¤æ–‡ä»¶"""
        self.ftp.delete(remote_path)
        print(f"æ–‡ä»¶å·²åˆ é™¤: {remote_path}")
    
    def change_dir(self, path):
        """åˆ‡æ¢ç›®å½•"""
        self.ftp.cwd(path)
        print(f"å½“å‰ç›®å½•: {self.ftp.pwd()}")
    
    def close(self):
        """å…³é—­è¿æ¥"""
        self.ftp.quit()
        print("FTPè¿æ¥å·²å…³é—­")

# ä½¿ç”¨ç¤ºä¾‹
# ftp = FTPClient('ftp.example.com')
# ftp.login('username', 'password')
# ftp.list_files()
# ftp.download_file('remote.txt', 'local.txt')
# ftp.close()
```

### 1.5 WebSocketåè®®

**WebSocket vs HTTPï¼š**

| ç‰¹æ€§ | HTTP | WebSocket |
|------|------|-----------|
| é€šä¿¡æ–¹å¼ | è¯·æ±‚-å“åº” | å…¨åŒå·¥ |
| è¿æ¥ | çŸ­è¿æ¥ | é•¿è¿æ¥ |
| å¼€é”€ | æ¯æ¬¡è¯·æ±‚éƒ½æœ‰å¤´éƒ¨ | æ¡æ‰‹åä½å¼€é”€ |
| å®æ—¶æ€§ | ä½ï¼ˆéœ€è½®è¯¢ï¼‰ | é«˜ |
| åº”ç”¨åœºæ™¯ | æ™®é€šç½‘é¡µ | èŠå¤©ã€æ¸¸æˆã€å®æ—¶æ•°æ® |

**WebSocketæ¡æ‰‹ï¼š**

```plain
å®¢æˆ·ç«¯è¯·æ±‚ï¼š
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Version: 13

æœåŠ¡å™¨å“åº”ï¼š
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
```

```python
import asyncio
import websockets
import json

class WebSocketServer:
    """WebSocketæœåŠ¡å™¨"""
    
    def __init__(self, host='localhost', port=8765):
        self.host = host
        self.port = port
        self.clients = set()
    
    async def handler(self, websocket, path):
        """å¤„ç†WebSocketè¿æ¥"""
        # æ·»åŠ å®¢æˆ·ç«¯
        self.clients.add(websocket)
        print(f"æ–°è¿æ¥: {websocket.remote_address}")
        
        try:
            async for message in websocket:
                print(f"æ”¶åˆ°æ¶ˆæ¯: {message}")
                
                # å¹¿æ’­ç»™æ‰€æœ‰å®¢æˆ·ç«¯
                await self.broadcast(message)
        
        finally:
            # ç§»é™¤å®¢æˆ·ç«¯
            self.clients.remove(websocket)
            print(f"è¿æ¥å…³é—­: {websocket.remote_address}")
    
    async def broadcast(self, message):
        """å¹¿æ’­æ¶ˆæ¯"""
        if self.clients:
            await asyncio.gather(
                *[client.send(message) for client in self.clients]
            )
    
    def start(self):
        """å¯åŠ¨æœåŠ¡å™¨"""
        print(f"WebSocketæœåŠ¡å™¨å¯åŠ¨: ws://{self.host}:{self.port}")
        start_server = websockets.serve(self.handler, self.host, self.port)
        asyncio.get_event_loop().run_until_complete(start_server)
        asyncio.get_event_loop().run_forever()

class WebSocketClient:
    """WebSocketå®¢æˆ·ç«¯"""
    
    async def connect(self, uri):
        """è¿æ¥æœåŠ¡å™¨"""
        async with websockets.connect(uri) as websocket:
            print(f"å·²è¿æ¥åˆ°: {uri}")
            
            # å‘é€æ¶ˆæ¯
            await websocket.send(json.dumps({
                'type': 'message',
                'content': 'Hello, WebSocket!'
            }))
            
            # æ¥æ”¶æ¶ˆæ¯
            response = await websocket.recv()
            print(f"æ”¶åˆ°å“åº”: {response}")

# ä½¿ç”¨ç¤ºä¾‹
# æœåŠ¡å™¨ç«¯
# server = WebSocketServer()
# server.start()

# å®¢æˆ·ç«¯
# client = WebSocketClient()
# asyncio.get_event_loop().run_until_complete(
#     client.connect('ws://localhost:8765')
# )
```

---

**æœ¬ç« å®Œ**
