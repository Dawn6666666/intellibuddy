# 计算机网络 - (一)应用层协议

学习HTTP、DNS等协议。

---

# 计算机网络

> 💡 **课程信息**
> - 学习时长：150小时
> - 难度等级：⭐⭐⭐⭐ (高)
> - **网络通信的核心原理**

---

## 📚 OSI七层模型 vs TCP/IP四层模型

| OSI | TCP/IP | 协议 | 功能 |
|-----|--------|------|------|
| 应用层 | 应用层 | HTTP, FTP, SMTP, DNS | 用户接口 |
| 表示层 | ↑ | SSL/TLS | 数据格式转换 |
| 会话层 | ↑ | - | 会话管理 |
| 传输层 | 传输层 | TCP, UDP | 端到端通信 |
| 网络层 | 网络层 | IP, ICMP, ARP | 路由选择 |
| 数据链路层 | 链路层 | Ethernet, WiFi | 帧传输 |
| 物理层 | ↑ | - | 比特传输 |

---

## 1. 应用层协议

### 1.1 HTTP协议详解

#### HTTP请求方法

| 方法 | 说明 | 幂等性 | 安全性 |
|------|------|--------|--------|
| GET | 获取资源 | ✅ | ✅ |
| POST | 提交数据 | ❌ | ❌ |
| PUT | 更新资源 | ✅ | ❌ |
| DELETE | 删除资源 | ✅ | ❌ |
| HEAD | 获取头部 | ✅ | ✅ |
| OPTIONS | 获取支持的方法 | ✅ | ✅ |
| PATCH | 部分更新 | ❌ | ❌ |

**HTTP请求格式：**

```plain
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0
Accept: text/html
Connection: keep-alive

[请求体]
```

**HTTP响应格式：**

```plain
HTTP/1.1 200 OK
Content-Type: text/html; charset=UTF-8
Content-Length: 1234
Server: Apache/2.4.41

<!DOCTYPE html>
<html>...
```

#### HTTP状态码

| 类型 | 范围 | 常用状态码 | 说明 |
|------|------|-----------|------|
| 信息 | 1xx | 100 Continue | 继续请求 |
| 成功 | 2xx | 200 OK, 201 Created, 204 No Content | 请求成功 |
| 重定向 | 3xx | 301 Moved, 302 Found, 304 Not Modified | 资源重定向 |
| 客户端错误 | 4xx | 400 Bad Request, 401 Unauthorized, 404 Not Found | 客户端错误 |
| 服务器错误 | 5xx | 500 Internal Error, 502 Bad Gateway, 503 Unavailable | 服务器错误 |

**完整HTTP客户端实现：**

```python
import socket
import urllib.parse

class HTTPClient:
    """完整HTTP客户端"""
    
    def __init__(self):
        self.timeout = 10
    
    def request(self, url, method='GET', headers=None, body=None):
        """发送HTTP请求"""
        # 解析URL
        parsed = urllib.parse.urlparse(url)
        host = parsed.hostname
        port = parsed.port or 80
        path = parsed.path or '/'
        
        # 构建请求
        request_line = f"{method} {path} HTTP/1.1\r\n"
        
        # 默认头部
        default_headers = {
            'Host': host,
            'User-Agent': 'PythonHTTPClient/1.0',
            'Accept': '*/*',
            'Connection': 'close'
        }
        
        if headers:
            default_headers.update(headers)
        
        # 添加Content-Length
        if body:
            default_headers['Content-Length'] = str(len(body))
        
        # 组装头部
        header_lines = ''.join(f"{k}: {v}\r\n" for k, v in default_headers.items())
        
        # 完整请求
        request = request_line + header_lines + '\r\n'
        if body:
            request += body
        
        # 发送请求
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(self.timeout)
        sock.connect((host, port))
        sock.send(request.encode())
    
    # 接收响应
        response = b''
        while True:
            chunk = sock.recv(4096)
            if not chunk:
                break
            response += chunk
        
        sock.close()
        
        return self._parse_response(response.decode('utf-8', errors='ignore'))
    
    def _parse_response(self, response):
        """解析HTTP响应"""
        lines = response.split('\r\n')
        
        # 状态行
        status_line = lines[0]
        parts = status_line.split(' ', 2)
        http_version = parts[0]
        status_code = int(parts[1])
        reason = parts[2] if len(parts) > 2 else ''
        
        # 头部
        headers = {}
        i = 1
        while i < len(lines) and lines[i]:
            if ':' in lines[i]:
                key, value = lines[i].split(':', 1)
                headers[key.strip()] = value.strip()
            i += 1
        
        # 主体
        body = '\r\n'.join(lines[i+1:])
        
        return {
            'status_code': status_code,
            'reason': reason,
            'headers': headers,
            'body': body
        }
    
    def get(self, url, headers=None):
        """GET请求"""
        return self.request(url, 'GET', headers)
    
    def post(self, url, data, headers=None):
        """POST请求"""
        if headers is None:
            headers = {}
        headers['Content-Type'] = 'application/x-www-form-urlencoded'
        return self.request(url, 'POST', headers, data)

# 使用示例
client = HTTPClient()
response = client.get('http://www.example.com')
print(f"状态码: {response['status_code']}")
print(f"内容长度: {len(response['body'])}")
```

#### HTTP/1.1 vs HTTP/2 vs HTTP/3

| 特性 | HTTP/1.1 | HTTP/2 | HTTP/3 |
|------|----------|--------|--------|
| 传输协议 | TCP | TCP | QUIC (UDP) |
| 多路复用 | ❌ (需多个连接) | ✅ | ✅ |
| 头部压缩 | ❌ | ✅ (HPACK) | ✅ (QPACK) |
| 服务器推送 | ❌ | ✅ | ✅ |
| 队头阻塞 | ✅ 严重 | 🔶 TCP层 | ❌ 无 |
| 二进制帧 | ❌ 文本 | ✅ | ✅ |
| 连接建立 | 3次握手 | 3次握手 | 0-RTT |

**HTTP/2多路复用示例：**

```python
class HTTP2Stream:
    """HTTP/2流模拟"""
    
    def __init__(self, stream_id):
        self.stream_id = stream_id
        self.state = 'idle'
        self.headers = {}
        self.data = b''
    
    def send_headers(self, headers):
        """发送头部帧"""
        self.headers = headers
        self.state = 'open'
        print(f"Stream {self.stream_id}: HEADERS sent")
    
    def send_data(self, data):
        """发送数据帧"""
        self.data += data
        print(f"Stream {self.stream_id}: DATA sent ({len(data)} bytes)")
    
    def close(self):
        """关闭流"""
        self.state = 'closed'
        print(f"Stream {self.stream_id}: CLOSED")

class HTTP2Connection:
    """HTTP/2连接（简化）"""
    
    def __init__(self):
        self.streams = {}
        self.next_stream_id = 1
    
    def create_stream(self):
        """创建新流"""
        stream_id = self.next_stream_id
        self.next_stream_id += 2  # 奇数为客户端流
        self.streams[stream_id] = HTTP2Stream(stream_id)
        return self.streams[stream_id]
    
    def multiplex_demo(self):
        """多路复用演示"""
        # 同时请求多个资源
        stream1 = self.create_stream()
        stream1.send_headers({':method': 'GET', ':path': '/index.html'})
        
        stream2 = self.create_stream()
        stream2.send_headers({':method': 'GET', ':path': '/style.css'})
        
        stream3 = self.create_stream()
        stream3.send_headers({':method': 'GET', ':path': '/script.js'})
        
        # 交错发送数据
        stream1.send_data(b'HTML chunk 1')
        stream2.send_data(b'CSS chunk 1')
        stream1.send_data(b'HTML chunk 2')
        stream3.send_data(b'JS chunk 1')
        
        # 关闭流
        stream1.close()
        stream2.close()
        stream3.close()

# 演示
conn = HTTP2Connection()
conn.multiplex_demo()
```

### 1.2 DNS域名系统

#### DNS查询类型

| 查询类型 | 说明 |
|---------|------|
| A记录 | IPv4地址 |
| AAAA记录 | IPv6地址 |
| CNAME | 别名记录 |
| MX | 邮件服务器 |
| NS | 域名服务器 |
| TXT | 文本记录 |
| PTR | 反向查询 |

**DNS递归查询过程：**

```plain
客户端 → 本地DNS服务器 → 根DNS服务器 → 顶级域DNS → 权威DNS → 返回IP
```

**完整DNS解析器：**

```python
import socket
import struct

class DNSResolver:
    """DNS解析器（简化版）"""
    
    DNS_SERVERS = ['8.8.8.8', '8.8.4.4']  # Google DNS
    
    def __init__(self):
        self.cache = {}
    
    def query(self, domain, dns_server='8.8.8.8'):
    """DNS查询"""
        # 检查缓存
        if domain in self.cache:
            print(f"缓存命中: {domain}")
            return self.cache[domain]
        
        # 使用socket的高级API（实际DNS包构建较复杂）
    try:
        ip = socket.gethostbyname(domain)
            self.cache[domain] = ip
            print(f"DNS查询: {domain} → {ip}")
        return ip
        except socket.gaierror as e:
            print(f"DNS查询失败: {domain} - {e}")
            return None
    
    def reverse_lookup(self, ip):
        """反向DNS查询"""
        try:
            hostname = socket.gethostbyaddr(ip)
            print(f"反向查询: {ip} → {hostname[0]}")
            return hostname[0]
        except socket.herror:
            print(f"反向查询失败: {ip}")
            return None
    
    def build_dns_query(self, domain):
        """构建DNS查询包"""
        # DNS头部（12字节）
        transaction_id = 0x1234
        flags = 0x0100  # 标准查询
        questions = 1
        answer_rrs = 0
        authority_rrs = 0
        additional_rrs = 0
        
        header = struct.pack('!HHHHHH', 
            transaction_id, flags, questions, 
            answer_rrs, authority_rrs, additional_rrs
        )
        
        # 问题部分
        question = b''
        for part in domain.split('.'):
            question += struct.pack('!B', len(part)) + part.encode()
        question += b'\x00'  # 结束符
        
        # 查询类型：A记录(1)，类：IN(1)
        question += struct.pack('!HH', 1, 1)
        
        return header + question
    
    def parse_dns_response(self, response):
        """解析DNS响应（简化）"""
        # 实际解析需要处理复杂的压缩指针等
        # 这里仅演示基本结构
        header = struct.unpack('!HHHHHH', response[:12])
        print(f"DNS响应头部: {header}")
        return header

# 使用示例
resolver = DNSResolver()
resolver.query('www.google.com')
resolver.query('www.github.com')
resolver.reverse_lookup('8.8.8.8')
```

**DNS缓存模拟：**

```python
import time

class DNSCache:
    """DNS缓存系统"""
    
    def __init__(self, ttl=300):
        self.cache = {}
        self.default_ttl = ttl
    
    def set(self, domain, ip, ttl=None):
        """设置缓存"""
        if ttl is None:
            ttl = self.default_ttl
        expire_time = time.time() + ttl
        self.cache[domain] = {
            'ip': ip,
            'expire': expire_time
        }
        print(f"缓存设置: {domain} → {ip} (TTL: {ttl}s)")
    
    def get(self, domain):
        """获取缓存"""
        if domain not in self.cache:
            return None
        
        entry = self.cache[domain]
        
        # 检查是否过期
        if time.time() > entry['expire']:
            print(f"缓存过期: {domain}")
            del self.cache[domain]
        return None

        print(f"缓存命中: {domain} → {entry['ip']}")
        return entry['ip']
    
    def clear(self):
        """清空缓存"""
        self.cache.clear()
        print("缓存已清空")

# 测试
cache = DNSCache(ttl=5)
cache.set('www.example.com', '93.184.216.34')
cache.get('www.example.com')  # 命中
time.sleep(6)
cache.get('www.example.com')  # 过期
```

### 1.3 SMTP/POP3/IMAP邮件协议

#### SMTP（Simple Mail Transfer Protocol）

**SMTP发送流程：**

```plain
1. EHLO - 客户端标识
2. AUTH - 身份认证
3. MAIL FROM - 发件人
4. RCPT TO - 收件人
5. DATA - 邮件内容
6. QUIT - 结束连接
```

**SMTP客户端实现：**

```python
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

class SMTPClient:
    """SMTP邮件客户端"""
    
    def __init__(self, server, port=587):
        self.server = server
        self.port = port
        self.smtp = None
    
    def connect(self, username, password):
        """连接SMTP服务器"""
        self.smtp = smtplib.SMTP(self.server, self.port)
        self.smtp.starttls()  # 启用TLS加密
        self.smtp.login(username, password)
        print(f"已连接到SMTP服务器: {self.server}")
    
    def send_email(self, from_addr, to_addr, subject, body, html=False):
        """发送邮件"""
        msg = MIMEMultipart('alternative')
        msg['From'] = from_addr
        msg['To'] = to_addr
        msg['Subject'] = subject
        
        # 添加邮件内容
        if html:
            part = MIMEText(body, 'html')
        else:
            part = MIMEText(body, 'plain')
        
        msg.attach(part)
        
        # 发送
        self.smtp.send_message(msg)
        print(f"邮件已发送: {from_addr} → {to_addr}")
    
    def close(self):
        """关闭连接"""
        if self.smtp:
            self.smtp.quit()
            print("SMTP连接已关闭")

# 使用示例（需要真实SMTP服务器）
# client = SMTPClient('smtp.gmail.com', 587)
# client.connect('your-email@gmail.com', 'your-password')
# client.send_email(
#     'sender@example.com',
#     'recipient@example.com',
#     'Test Email',
#     'This is a test email.'
# )
# client.close()
```

#### POP3协议

**POP3命令：**

| 命令 | 说明 |
|------|------|
| USER | 用户名 |
| PASS | 密码 |
| STAT | 邮件统计 |
| LIST | 邮件列表 |
| RETR | 获取邮件 |
| DELE | 删除邮件 |
| QUIT | 退出 |

```python
import poplib

class POP3Client:
    """POP3邮件客户端"""
    
    def __init__(self, server, port=995):
        self.server = server
        self.port = port
        self.pop = None
    
    def connect(self, username, password):
        """连接POP3服务器"""
        self.pop = poplib.POP3_SSL(self.server, self.port)
        self.pop.user(username)
        self.pop.pass_(password)
        print(f"已连接到POP3服务器: {self.server}")
    
    def get_mail_count(self):
        """获取邮件数量"""
        stat = self.pop.stat()
        print(f"邮件数量: {stat[0]}, 总大小: {stat[1]} bytes")
        return stat[0]
    
    def list_mails(self):
        """列出所有邮件"""
        response, mails, octets = self.pop.list()
        for mail in mails:
            print(f"邮件: {mail.decode()}")
    
    def retrieve_mail(self, index):
        """获取指定邮件"""
        response, lines, octets = self.pop.retr(index)
        print(f"邮件 {index}:")
        for line in lines[:10]:  # 只显示前10行
            print(line.decode())
    
    def close(self):
        """关闭连接"""
        if self.pop:
            self.pop.quit()
            print("POP3连接已关闭")

# 使用示例
# client = POP3Client('pop.gmail.com')
# client.connect('your-email@gmail.com', 'your-password')
# client.get_mail_count()
# client.list_mails()
# client.close()
```

### 1.4 FTP文件传输协议

**FTP工作模式：**

+ **主动模式（PORT）**：服务器主动连接客户端
+ **被动模式（PASV）**：客户端主动连接服务器（防火墙友好）

**FTP命令：**

| 命令 | 说明 |
|------|------|
| USER | 用户名 |
| PASS | 密码 |
| PWD | 显示当前目录 |
| CWD | 切换目录 |
| LIST | 列出文件 |
| RETR | 下载文件 |
| STOR | 上传文件 |
| DELE | 删除文件 |
| QUIT | 退出 |

```python
from ftplib import FTP
import os

class FTPClient:
    """FTP客户端"""
    
    def __init__(self, host, port=21):
        self.ftp = FTP()
        self.ftp.connect(host, port)
        print(f"已连接到FTP服务器: {host}")
    
    def login(self, username='anonymous', password=''):
        """登录"""
        self.ftp.login(username, password)
        print(f"登录成功: {username}")
        print(f"欢迎信息: {self.ftp.getwelcome()}")
    
    def list_files(self):
        """列出当前目录文件"""
        files = []
        self.ftp.dir(files.append)
        print("文件列表:")
        for f in files:
            print(f)
        return files
    
    def download_file(self, remote_path, local_path):
        """下载文件"""
        with open(local_path, 'wb') as f:
            self.ftp.retrbinary(f'RETR {remote_path}', f.write)
        print(f"文件已下载: {remote_path} → {local_path}")
    
    def upload_file(self, local_path, remote_path):
        """上传文件"""
        with open(local_path, 'rb') as f:
            self.ftp.storbinary(f'STOR {remote_path}', f)
        print(f"文件已上传: {local_path} → {remote_path}")
    
    def delete_file(self, remote_path):
        """删除文件"""
        self.ftp.delete(remote_path)
        print(f"文件已删除: {remote_path}")
    
    def change_dir(self, path):
        """切换目录"""
        self.ftp.cwd(path)
        print(f"当前目录: {self.ftp.pwd()}")
    
    def close(self):
        """关闭连接"""
        self.ftp.quit()
        print("FTP连接已关闭")

# 使用示例
# ftp = FTPClient('ftp.example.com')
# ftp.login('username', 'password')
# ftp.list_files()
# ftp.download_file('remote.txt', 'local.txt')
# ftp.close()
```

### 1.5 WebSocket协议

**WebSocket vs HTTP：**

| 特性 | HTTP | WebSocket |
|------|------|-----------|
| 通信方式 | 请求-响应 | 全双工 |
| 连接 | 短连接 | 长连接 |
| 开销 | 每次请求都有头部 | 握手后低开销 |
| 实时性 | 低（需轮询） | 高 |
| 应用场景 | 普通网页 | 聊天、游戏、实时数据 |

**WebSocket握手：**

```plain
客户端请求：
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Version: 13

服务器响应：
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
```

```python
import asyncio
import websockets
import json

class WebSocketServer:
    """WebSocket服务器"""
    
    def __init__(self, host='localhost', port=8765):
        self.host = host
        self.port = port
        self.clients = set()
    
    async def handler(self, websocket, path):
        """处理WebSocket连接"""
        # 添加客户端
        self.clients.add(websocket)
        print(f"新连接: {websocket.remote_address}")
        
        try:
            async for message in websocket:
                print(f"收到消息: {message}")
                
                # 广播给所有客户端
                await self.broadcast(message)
        
        finally:
            # 移除客户端
            self.clients.remove(websocket)
            print(f"连接关闭: {websocket.remote_address}")
    
    async def broadcast(self, message):
        """广播消息"""
        if self.clients:
            await asyncio.gather(
                *[client.send(message) for client in self.clients]
            )
    
    def start(self):
        """启动服务器"""
        print(f"WebSocket服务器启动: ws://{self.host}:{self.port}")
        start_server = websockets.serve(self.handler, self.host, self.port)
        asyncio.get_event_loop().run_until_complete(start_server)
        asyncio.get_event_loop().run_forever()

class WebSocketClient:
    """WebSocket客户端"""
    
    async def connect(self, uri):
        """连接服务器"""
        async with websockets.connect(uri) as websocket:
            print(f"已连接到: {uri}")
            
            # 发送消息
            await websocket.send(json.dumps({
                'type': 'message',
                'content': 'Hello, WebSocket!'
            }))
            
            # 接收消息
            response = await websocket.recv()
            print(f"收到响应: {response}")

# 使用示例
# 服务器端
# server = WebSocketServer()
# server.start()

# 客户端
# client = WebSocketClient()
# asyncio.get_event_loop().run_until_complete(
#     client.connect('ws://localhost:8765')
# )
```

---

**本章完**
