# 计算机网络 - (二)传输层

理解TCP/UDP协议。

---


### 2.1 TCP协议详解

#### TCP头部格式

```plain
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          源端口(16位)          |        目的端口(16位)          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        序列号(32位)                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        确认号(32位)                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  数据  |       |U|A|P|R|S|F|                                   |
| 偏移   |  保留 |R|C|S|S|Y|I|            窗口大小(16位)          |
|  (4位) | (6位) |G|K|H|T|N|N|                                   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           校验和(16位)         |        紧急指针(16位)          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    选项(可变长度)                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

**标志位说明：**

| 标志 | 含义 | 说明 |
|------|------|------|
| URG | Urgent | 紧急指针有效 |
| ACK | Acknowledgment | 确认号有效 |
| PSH | Push | 立即推送给应用层 |
| RST | Reset | 重置连接 |
| SYN | Synchronize | 同步序列号（建立连接） |
| FIN | Finish | 发送方完成数据发送（关闭连接） |

#### TCP三次握手（Connection Establishment）

**详细过程：**

```plain
客户端                                      服务器
  |                                           |
  | SYN (seq=x)                              | LISTEN
  |----------------------------------------->| SYN_RCVD
  |                                           |
  | SYN-ACK (seq=y, ack=x+1)                 |
  |<-----------------------------------------|
  | ESTABLISHED                               |
  | ACK (ack=y+1)                            |
  |----------------------------------------->| ESTABLISHED
  |                                           |
```

**状态转换：**
+ 客户端：CLOSED → SYN_SENT → ESTABLISHED
+ 服务器：CLOSED → LISTEN → SYN_RCVD → ESTABLISHED

**为什么需要三次握手？**

1. ✅ **防止旧连接初始化**：避免已失效的连接请求突然到达服务器
2. ✅ **双方序列号确认**：确保双方都能收发数据
3. ✅ **资源分配时机**：服务器在第三次握手后才分配资源

```python
class TCPHandshake:
    """TCP三次握手模拟"""
    
    def __init__(self):
        self.client_seq = 1000
        self.server_seq = 2000
        self.client_state = 'CLOSED'
        self.server_state = 'LISTEN'
    
    def step1_client_syn(self):
        """第一步：客户端发送SYN"""
        print(f"客户端: {self.client_state} → SYN_SENT")
        print(f"发送: SYN, seq={self.client_seq}")
        self.client_state = 'SYN_SENT'
        return {'SYN': True, 'seq': self.client_seq}
    
    def step2_server_syn_ack(self, received):
        """第二步：服务器发送SYN-ACK"""
        print(f"\n服务器: {self.server_state} → SYN_RCVD")
        ack = received['seq'] + 1
        print(f"发送: SYN-ACK, seq={self.server_seq}, ack={ack}")
        self.server_state = 'SYN_RCVD'
        return {'SYN': True, 'ACK': True, 'seq': self.server_seq, 'ack': ack}
    
    def step3_client_ack(self, received):
        """第三步：客户端发送ACK"""
        print(f"\n客户端: {self.client_state} → ESTABLISHED")
        ack = received['seq'] + 1
        print(f"发送: ACK, ack={ack}")
        self.client_state = 'ESTABLISHED'
        return {'ACK': True, 'ack': ack}
    
    def step4_server_established(self, received):
        """第四步：服务器确认建立连接"""
        print(f"\n服务器: {self.server_state} → ESTABLISHED")
        self.server_state = 'ESTABLISHED'
        print("连接建立成功！\n")
    
    def simulate(self):
        """模拟完整三次握手"""
        print("=== TCP三次握手模拟 ===\n")
        packet1 = self.step1_client_syn()
        packet2 = self.step2_server_syn_ack(packet1)
        packet3 = self.step3_client_ack(packet2)
        self.step4_server_established(packet3)

# 演示
handshake = TCPHandshake()
handshake.simulate()
```

#### TCP四次挥手（Connection Termination）

**详细过程：**

```plain
客户端                                      服务器
  |                                           |
  | FIN (seq=u)                              | ESTABLISHED
  |----------------------------------------->| CLOSE_WAIT
  | FIN_WAIT_1                                |
  | ACK (ack=u+1)                            |
  |<-----------------------------------------|
  | FIN_WAIT_2                                |
  |                                           |
  | FIN (seq=v)                              |
  |<-----------------------------------------| LAST_ACK
  | TIME_WAIT                                 |
  | ACK (ack=v+1)                            |
  |----------------------------------------->| CLOSED
  | (等待2MSL)                                |
  | CLOSED                                    |
```

**为什么需要四次挥手？**

+ TCP是**全双工**通信，每个方向都需要独立关闭
+ 第一次FIN：客户端表示不再发送数据
+ 第二次ACK：服务器确认收到FIN
+ 第三次FIN：服务器表示不再发送数据
+ 第四次ACK：客户端确认收到FIN

**TIME_WAIT状态（2MSL）：**

+ **MSL**（Maximum Segment Lifetime）：报文最大生存时间，通常为2分钟
+ **2MSL**：等待4分钟，确保最后的ACK能被接收
+ **目的**：
  - 确保最后的ACK能到达服务器
  - 避免新连接收到旧连接的延迟数据

```python
class TCPClose:
    """TCP四次挥手模拟"""
    
    def __init__(self):
        self.client_seq = 3000
        self.server_seq = 4000
        self.client_state = 'ESTABLISHED'
        self.server_state = 'ESTABLISHED'
    
    def step1_client_fin(self):
        """第一次挥手：客户端FIN"""
        print(f"客户端: {self.client_state} → FIN_WAIT_1")
        print(f"发送: FIN, seq={self.client_seq}")
        self.client_state = 'FIN_WAIT_1'
        return {'FIN': True, 'seq': self.client_seq}
    
    def step2_server_ack(self, received):
        """第二次挥手：服务器ACK"""
        print(f"\n服务器: {self.server_state} → CLOSE_WAIT")
        ack = received['seq'] + 1
        print(f"发送: ACK, ack={ack}")
        self.server_state = 'CLOSE_WAIT'
        self.client_state = 'FIN_WAIT_2'
        print(f"客户端: FIN_WAIT_1 → FIN_WAIT_2")
        return {'ACK': True, 'ack': ack}
    
    def step3_server_fin(self):
        """第三次挥手：服务器FIN"""
        print(f"\n服务器: {self.server_state} → LAST_ACK")
        print(f"发送: FIN, seq={self.server_seq}")
        self.server_state = 'LAST_ACK'
        return {'FIN': True, 'seq': self.server_seq}
    
    def step4_client_ack(self, received):
        """第四次挥手：客户端ACK"""
        print(f"\n客户端: {self.client_state} → TIME_WAIT")
        ack = received['seq'] + 1
        print(f"发送: ACK, ack={ack}")
        self.client_state = 'TIME_WAIT'
        self.server_state = 'CLOSED'
        print(f"服务器: LAST_ACK → CLOSED")
        print(f"客户端: 等待2MSL后关闭...")
        return {'ACK': True, 'ack': ack}
    
    def simulate(self):
        """模拟完整四次挥手"""
        print("=== TCP四次挥手模拟 ===\n")
        packet1 = self.step1_client_fin()
        packet2 = self.step2_server_ack(packet1)
        packet3 = self.step3_server_fin()
        packet4 = self.step4_client_ack(packet3)
        print("\n连接关闭完成！\n")

# 演示
close = TCPClose()
close.simulate()
```

#### TCP滑动窗口（Sliding Window）

**目的**：流量控制和提高传输效率

**窗口大小计算：**

$$
\text{AdvertisedWindow} = \text{MaxRcvBuffer} - (\text{LastByteRcvd} - \text{LastByteRead})
$$

**发送窗口：**

```plain
已发送已确认 | 已发送未确认 | 可发送 | 不可发送
           ↑             ↑        ↑
    LastByteAcked  LastByteSent  LastByteAcked+AdvertisedWindow
           |<--- 发送窗口 --->|
```

```python
class SlidingWindow:
    """TCP滑动窗口模拟"""
    
    def __init__(self, window_size=8):
        self.window_size = window_size
        self.base = 0  # 窗口基址（最早未确认的序号）
        self.next_seq = 0  # 下一个要发送的序号
        self.buffer = {}  # 发送缓冲区
        self.acked = set()  # 已确认的序号
    
    def send(self, data):
        """发送数据"""
        if self.next_seq < self.base + self.window_size:
            self.buffer[self.next_seq] = data
            print(f"发送: seq={self.next_seq}, data='{data}'")
            self.next_seq += 1
            return True
        else:
            print(f"窗口已满，等待ACK...")
            return False
    
    def receive_ack(self, ack_num):
        """接收ACK"""
        print(f"收到ACK: {ack_num}")
        self.acked.add(ack_num)
        
        # 移动窗口基址
        while self.base in self.acked:
            print(f"  窗口滑动: {self.base} → {self.base + 1}")
            del self.buffer[self.base]
            self.base += 1
    
    def get_window_status(self):
        """获取窗口状态"""
        return {
            'base': self.base,
            'next_seq': self.next_seq,
            'window_size': self.window_size,
            'in_flight': self.next_seq - self.base,
            'available': self.window_size - (self.next_seq - self.base)
        }
    
    def demo(self):
        """演示滑动窗口"""
        print("=== 滑动窗口演示 ===\n")
        
        # 发送8个数据包（填满窗口）
        for i in range(8):
            self.send(f"DATA{i}")
        
        print(f"\n窗口状态: {self.get_window_status()}\n")
        
        # 尝试再发送（窗口已满）
        self.send("DATA8")
        
        # 收到ACK 0, 1, 2
        print("\n")
        self.receive_ack(0)
        self.receive_ack(1)
        self.receive_ack(2)
        
        print(f"\n窗口状态: {self.get_window_status()}\n")
        
        # 现在可以继续发送
        self.send("DATA8")
        self.send("DATA9")
        self.send("DATA10")

# 演示
window = SlidingWindow(window_size=8)
window.demo()
```

#### TCP快速重传（Fast Retransmit）

**原理**：收到3个重复ACK时，立即重传（不等超时）

```python
class FastRetransmit:
    """快速重传机制"""
    
    def __init__(self):
        self.next_seq = 0
        self.dup_ack_count = {}
        self.sent_packets = {}
    
    def send_packet(self, seq, data):
        """发送数据包"""
        self.sent_packets[seq] = data
        print(f"发送: seq={seq}, data='{data}'")
        self.next_seq = seq + 1
    
    def receive_ack(self, ack_num):
        """接收ACK"""
        # 统计重复ACK
        if ack_num not in self.dup_ack_count:
            self.dup_ack_count[ack_num] = 0
        
        self.dup_ack_count[ack_num] += 1
        dup_count = self.dup_ack_count[ack_num]
        
        print(f"收到ACK: {ack_num} (重复{dup_count}次)")
        
        # 快速重传：3个重复ACK
        if dup_count == 3:
            print(f"⚠️ 检测到3个重复ACK，快速重传 seq={ack_num}")
            self.retransmit(ack_num)
    
    def retransmit(self, seq):
        """重传数据包"""
        if seq in self.sent_packets:
            data = self.sent_packets[seq]
            print(f"🔄 重传: seq={seq}, data='{data}'")
    
    def demo(self):
        """演示快速重传"""
        print("=== 快速重传演示 ===\n")
        
        # 发送seq 0-5
        for i in range(6):
            self.send_packet(i, f"DATA{i}")
        
        print("\n假设seq=2丢失，接收方会持续发送ACK=2\n")
        
        # 收到ACK 0, 1
        self.receive_ack(0)
        self.receive_ack(1)
        
        # seq=2丢失，后续数据包触发重复ACK
        print("\nseq=3,4,5到达，触发重复ACK=2：\n")
        self.receive_ack(2)  # 第1次
        self.receive_ack(2)  # 第2次
        self.receive_ack(2)  # 第3次 → 触发快速重传

# 演示
fast_retx = FastRetransmit()
fast_retx.demo()
```

#### TCP完整服务器/客户端实现

```python
import socket
import threading

class TCPServer:
    """完整TCP服务器"""
    
    def __init__(self, host='0.0.0.0', port=8888):
        self.host = host
        self.port = port
        self.server_socket = None
    
    def start(self):
        """启动服务器"""
        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        
        # 设置socket选项
        self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        
        # 绑定地址
        self.server_socket.bind((self.host, self.port))
        
        # 监听连接（最大队列长度5）
        self.server_socket.listen(5)
        
        print(f"TCP服务器启动: {self.host}:{self.port}")
        
        try:
    while True:
                # 接受连接
                client_socket, client_addr = self.server_socket.accept()
                print(f"新连接: {client_addr}")
                
                # 创建线程处理客户端
                thread = threading.Thread(
                    target=self.handle_client,
                    args=(client_socket, client_addr)
                )
                thread.start()
        
        except KeyboardInterrupt:
            print("\n服务器关闭")
        finally:
            self.server_socket.close()
    
    def handle_client(self, client_socket, client_addr):
        """处理客户端连接"""
        try:
            while True:
                # 接收数据
                data = client_socket.recv(1024)
                
                if not data:
                    print(f"连接关闭: {client_addr}")
                    break
                
                print(f"收到数据 from {client_addr}: {data.decode()}")
                
                # 回显数据
                response = f"Echo: {data.decode()}"
                client_socket.send(response.encode())
        
        except Exception as e:
            print(f"错误 {client_addr}: {e}")
        finally:
            client_socket.close()

class TCPClient:
    """完整TCP客户端"""
    
    def __init__(self, server_host, server_port):
        self.server_host = server_host
        self.server_port = server_port
        self.socket = None
    
    def connect(self):
        """连接服务器"""
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.socket.connect((self.server_host, self.server_port))
        print(f"已连接到服务器: {self.server_host}:{self.server_port}")
    
    def send(self, message):
        """发送消息"""
        self.socket.send(message.encode())
        print(f"发送: {message}")
    
    def receive(self, buffer_size=1024):
        """接收响应"""
        data = self.socket.recv(buffer_size)
        response = data.decode()
        print(f"收到: {response}")
        return response
    
    def close(self):
        """关闭连接"""
        self.socket.close()
        print("连接已关闭")

# 使用示例
# 服务器端
# server = TCPServer()
# server.start()

# 客户端
# client = TCPClient('localhost', 8888)
# client.connect()
# client.send("Hello, Server!")
# client.receive()
# client.close()
```

### 2.2 UDP协议详解

#### UDP头部格式

```plain
 0      7 8     15 16    23 24    31
+--------+--------+--------+--------+
|    源端口号    |   目的端口号     |
+--------+--------+--------+--------+
|     长度       |      校验和      |
+--------+--------+--------+--------+
|                                   |
|            数据                   |
|                                   |
+-----------------------------------+
```

**UDP特点：**

| 特性 | UDP | TCP |
|------|-----|-----|
| 连接 | 无连接 | 面向连接 |
| 可靠性 | 不可靠 | 可靠 |
| 顺序 | 无序 | 有序 |
| 开销 | 8字节 | 20-60字节 |
| 速度 | 快 | 慢 |
| 应用场景 | 视频、游戏、DNS | HTTP、FTP、邮件 |

**UDP应用场景：**

1. ✅ **实时视频/音频**：丢包可容忍，延迟敏感
2. ✅ **在线游戏**：快速响应，偶尔丢包无影响
3. ✅ **DNS查询**：简单请求/响应，快速
4. ✅ **广播/多播**：一对多通信
5. ✅ **物联网**：设备资源受限

```python
import socket
import threading
import time

class UDPServer:
    """完整UDP服务器"""
    
    def __init__(self, host='0.0.0.0', port=9999):
        self.host = host
        self.port = port
        self.socket = None
    
    def start(self):
        """启动服务器"""
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind((self.host, self.port))
        
        print(f"UDP服务器启动: {self.host}:{self.port}")
        
        try:
    while True:
                # 接收数据
                data, client_addr = self.socket.recvfrom(1024)
                print(f"收到数据 from {client_addr}: {data.decode()}")
                
                # 回显数据
                response = f"Echo: {data.decode()}"
                self.socket.sendto(response.encode(), client_addr)
        
        except KeyboardInterrupt:
            print("\n服务器关闭")
        finally:
            self.socket.close()

class UDPClient:
    """完整UDP客户端"""
    
    def __init__(self, server_host, server_port):
        self.server_host = server_host
        self.server_port = server_port
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    
    def send(self, message):
        """发送消息"""
        self.socket.sendto(message.encode(), (self.server_host, self.server_port))
        print(f"发送: {message}")
    
    def receive(self, timeout=5):
        """接收响应"""
        self.socket.settimeout(timeout)
        try:
            data, server_addr = self.socket.recvfrom(1024)
            response = data.decode()
            print(f"收到: {response}")
            return response
        except socket.timeout:
            print("接收超时")
            return None
    
    def close(self):
        """关闭socket"""
        self.socket.close()
        print("Socket已关闭")

# 使用示例
# 服务器端
# server = UDPServer()
# server.start()

# 客户端
# client = UDPClient('localhost', 9999)
# client.send("Hello, UDP Server!")
# client.receive()
# client.close()
```

#### UDP可靠传输实现（模拟）

**自定义可靠UDP协议：**

```python
import struct
import hashlib

class ReliableUDP:
    """可靠UDP传输（添加序列号、ACK、重传）"""
    
    def __init__(self, socket, timeout=1.0):
        self.socket = socket
        self.timeout = timeout
        self.seq_num = 0
        self.expected_seq = 0
    
    def _create_packet(self, seq, data):
        """创建数据包（序列号 + 数据 + 校验和）"""
        # 包格式: [序列号(4字节)][数据长度(4字节)][数据][校验和(16字节)]
        data_bytes = data.encode() if isinstance(data, str) else data
        header = struct.pack('!II', seq, len(data_bytes))
        checksum = hashlib.md5(header + data_bytes).digest()
        return header + data_bytes + checksum
    
    def _parse_packet(self, packet):
        """解析数据包"""
        if len(packet) < 24:  # 最小包长度
            return None, None, False
        
        seq, data_len = struct.unpack('!II', packet[:8])
        data = packet[8:8+data_len]
        checksum = packet[8+data_len:]
        
        # 验证校验和
        expected_checksum = hashlib.md5(packet[:8+data_len]).digest()
        valid = checksum == expected_checksum
        
        return seq, data, valid
    
    def send_reliable(self, data, dest_addr):
        """可靠发送"""
        packet = self._create_packet(self.seq_num, data)
        max_retries = 3
        retries = 0
        
        while retries < max_retries:
            # 发送数据包
            self.socket.sendto(packet, dest_addr)
            print(f"发送: seq={self.seq_num}, 尝试{retries+1}/{max_retries}")
            
            try:
                # 等待ACK
                self.socket.settimeout(self.timeout)
                ack_packet, _ = self.socket.recvfrom(1024)
                ack_seq, _, valid = self._parse_packet(ack_packet)
                
                if valid and ack_seq == self.seq_num:
                    print(f"收到ACK: seq={ack_seq}")
                    self.seq_num += 1
                    return True
            
            except socket.timeout:
                print(f"超时，重传...")
                retries += 1
        
        print(f"发送失败: 超过最大重试次数")
        return False
    
    def receive_reliable(self):
        """可靠接收"""
    while True:
            packet, sender_addr = self.socket.recvfrom(1024)
            seq, data, valid = self._parse_packet(packet)
            
            if not valid:
                print("数据包校验失败，丢弃")
                continue
            
            print(f"收到数据包: seq={seq}")
            
            # 发送ACK
            ack_packet = self._create_packet(seq, b'ACK')
            self.socket.sendto(ack_packet, sender_addr)
            print(f"发送ACK: seq={seq}")
            
            # 检查序列号
            if seq == self.expected_seq:
                self.expected_seq += 1
                return data, sender_addr
            else:
                print(f"序列号错误，期望{self.expected_seq}，收到{seq}")

# 使用示例
# 发送端
# sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
# reliable = ReliableUDP(sock)
# reliable.send_reliable("Hello", ("localhost", 9999))
```

### 2.3 TCP拥塞控制

#### 拥塞控制算法

**四个阶段：**

1. **慢启动（Slow Start）**：指数增长
2. **拥塞避免（Congestion Avoidance）**：线性增长
3. **快速重传（Fast Retransmit）**：3个重复ACK
4. **快速恢复（Fast Recovery）**：减半后线性增长

**拥塞窗口变化：**

```plain
cwnd
  |
64|                  /\
  |                 /  \
32|                /    \___/\___
  |               /              \___
16|              /                   \___
  |             /
 8|           /
  |         /
 4|       /
  |     /
 2|   /
  | /
 1|/____________________________________> RTT
   慢启动  拥塞避免    快速恢复
```

**完整拥塞控制实现：**

```python
class TCPCongestionControl:
    """TCP拥塞控制（Reno算法）"""
    
    def __init__(self, initial_ssthresh=64):
        self.cwnd = 1  # 拥塞窗口
        self.ssthresh = initial_ssthresh  # 慢启动阈值
        self.state = 'slow_start'
        self.dup_ack_count = 0
        self.history = []
    
    def on_ack(self, is_duplicate=False):
        """收到ACK"""
        if is_duplicate:
            self.dup_ack_count += 1
            
            # 快速重传：3个重复ACK
            if self.dup_ack_count == 3:
                print(f"⚠️ 快速重传触发")
                self.fast_retransmit()
        else:
            # 正常ACK，重置重复计数
            self.dup_ack_count = 0
            
        if self.state == 'slow_start':
                # 慢启动：指数增长
                self.cwnd *= 2
                print(f"慢启动: cwnd={self.cwnd}")
                
            if self.cwnd >= self.ssthresh:
                self.state = 'congestion_avoidance'
                    print(f"进入拥塞避免阶段")
            
            elif self.state == 'congestion_avoidance':
                # 拥塞避免：线性增长（每个RTT增加1）
                self.cwnd += 1
                print(f"拥塞避免: cwnd={self.cwnd}")
            
            elif self.state == 'fast_recovery':
                # 快速恢复
                self.cwnd = self.ssthresh
                self.state = 'congestion_avoidance'
                print(f"快速恢复完成，进入拥塞避免")
        
        self.history.append({
            'cwnd': self.cwnd,
            'ssthresh': self.ssthresh,
            'state': self.state
        })
    
    def on_timeout(self):
        """超时（严重拥塞）"""
        print(f"⚠️ 超时发生！")
        self.ssthresh = max(self.cwnd // 2, 2)
        self.cwnd = 1
        self.state = 'slow_start'
        self.dup_ack_count = 0
        print(f"重置: cwnd=1, ssthresh={self.ssthresh}")
        
        self.history.append({
            'cwnd': self.cwnd,
            'ssthresh': self.ssthresh,
            'state': self.state
        })
    
    def fast_retransmit(self):
        """快速重传"""
        print(f"进入快速恢复")
        self.ssthresh = max(self.cwnd // 2, 2)
        self.cwnd = self.ssthresh + 3  # 额外的3个重复ACK
        self.state = 'fast_recovery'
        print(f"快速恢复: cwnd={self.cwnd}, ssthresh={self.ssthresh}")
    
    def plot_history(self):
        """打印历史记录"""
        print("\nRTT | cwnd | ssthresh | state")
        print("----+------+----------+-------------------")
        for i, h in enumerate(self.history):
            print(f"{i:3} | {h['cwnd']:4} | {h['ssthresh']:8} | {h['state']}")

# 演示完整拥塞控制
print("=== TCP拥塞控制演示 ===\n")
tcp = TCPCongestionControl(initial_ssthresh=16)

# 慢启动阶段
for i in range(5):
    tcp.on_ack()

print(f"\n当前状态: cwnd={tcp.cwnd}, state={tcp.state}\n")

# 拥塞避免阶段
for i in range(10):
    tcp.on_ack()

print(f"\n当前状态: cwnd={tcp.cwnd}, state={tcp.state}\n")

# 模拟丢包（快速重传）
print("\n模拟丢包：收到3个重复ACK\n")
tcp.on_ack(is_duplicate=True)
tcp.on_ack(is_duplicate=True)
tcp.on_ack(is_duplicate=True)

# 快速恢复
for i in range(5):
    tcp.on_ack()

# 模拟超时
print("\n模拟超时：\n")
tcp.on_timeout()

# 重新慢启动
for i in range(10):
    tcp.on_ack()

# 显示历史
tcp.plot_history()
```

#### 流量控制 vs 拥塞控制

| 特性 | 流量控制 | 拥塞控制 |
|------|---------|---------|
| 目的 | 保护接收方 | 保护网络 |
| 控制变量 | 接收窗口（rwnd） | 拥塞窗口（cwnd） |
| 触发条件 | 接收缓冲区满 | 网络拥塞 |
| 控制机制 | 滑动窗口 | 慢启动、拥塞避免 |
| 实际发送窗口 | $\min(\text{rwnd}, \text{cwnd})$ | |

**RTT（Round-Trip Time）测量：**

```python
import time

class RTTEstimator:
    """RTT估计器（用于超时重传）"""
    
    def __init__(self):
        self.srtt = None  # 平滑RTT
        self.rttvar = None  # RTT变化
        self.rto = 1.0  # 重传超时时间
        
        # RFC 6298推荐参数
        self.alpha = 0.125
        self.beta = 0.25
        self.k = 4
    
    def update(self, measured_rtt):
        """更新RTT估计"""
        if self.srtt is None:
            # 首次测量
            self.srtt = measured_rtt
            self.rttvar = measured_rtt / 2
        else:
            # 更新RTTVAR
            self.rttvar = (1 - self.beta) * self.rttvar + \
                          self.beta * abs(self.srtt - measured_rtt)
            
            # 更新SRTT
            self.srtt = (1 - self.alpha) * self.srtt + \
                        self.alpha * measured_rtt
        
        # 计算RTO
        self.rto = self.srtt + self.k * self.rttvar
        
        print(f"RTT测量: {measured_rtt:.3f}s")
        print(f"  SRTT: {self.srtt:.3f}s")
        print(f"  RTTVAR: {self.rttvar:.3f}s")
        print(f"  RTO: {self.rto:.3f}s\n")
        
        return self.rto

# 演示
estimator = RTTEstimator()
rtts = [0.1, 0.12, 0.11, 0.15, 0.09, 0.13]

for rtt in rtts:
    estimator.update(rtt)
```

### 2.4 TCP vs UDP对比总结

```python
class ProtocolComparison:
    """协议对比演示"""
    
    @staticmethod
    def tcp_characteristics():
        """TCP特征"""
        return {
            '连接': '面向连接（三次握手/四次挥手）',
            '可靠性': '可靠（确认、重传、流量控制）',
            '顺序': '保证顺序（序列号）',
            '速度': '较慢（开销大）',
            '头部大小': '20-60字节',
            '拥塞控制': '有',
            '应用': 'HTTP, FTP, SMTP, SSH'
        }
    
    @staticmethod
    def udp_characteristics():
        """UDP特征"""
        return {
            '连接': '无连接',
            '可靠性': '不可靠（尽力而为）',
            '顺序': '不保证顺序',
            '速度': '快（开销小）',
            '头部大小': '8字节',
            '拥塞控制': '无',
            '应用': 'DNS, DHCP, 视频流, 游戏'
        }
    
    @staticmethod
    def print_comparison():
        """打印对比"""
        tcp = ProtocolComparison.tcp_characteristics()
        udp = ProtocolComparison.udp_characteristics()
        
        print("TCP vs UDP 对比")
        print("=" * 60)
        print(f"{'特性':<10} | {'TCP':<25} | {'UDP':<25}")
        print("-" * 60)
        
        for key in tcp.keys():
            print(f"{key:<10} | {tcp[key]:<25} | {udp[key]:<25}")

# 演示
ProtocolComparison.print_comparison()
```

---

**本章完**
