# è®¡ç®—æœºç½‘ç»œ - (äºŒ)ä¼ è¾“å±‚

ç†è§£TCP/UDPåè®®ã€‚

---


### 2.1 TCPåè®®è¯¦è§£

#### TCPå¤´éƒ¨æ ¼å¼

```plain
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          æºç«¯å£(16ä½)          |        ç›®çš„ç«¯å£(16ä½)          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        åºåˆ—å·(32ä½)                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        ç¡®è®¤å·(32ä½)                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  æ•°æ®  |       |U|A|P|R|S|F|                                   |
| åç§»   |  ä¿ç•™ |R|C|S|S|Y|I|            çª—å£å¤§å°(16ä½)          |
|  (4ä½) | (6ä½) |G|K|H|T|N|N|                                   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           æ ¡éªŒå’Œ(16ä½)         |        ç´§æ€¥æŒ‡é’ˆ(16ä½)          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    é€‰é¡¹(å¯å˜é•¿åº¦)                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

**æ ‡å¿—ä½è¯´æ˜ï¼š**

| æ ‡å¿— | å«ä¹‰ | è¯´æ˜ |
|------|------|------|
| URG | Urgent | ç´§æ€¥æŒ‡é’ˆæœ‰æ•ˆ |
| ACK | Acknowledgment | ç¡®è®¤å·æœ‰æ•ˆ |
| PSH | Push | ç«‹å³æ¨é€ç»™åº”ç”¨å±‚ |
| RST | Reset | é‡ç½®è¿æ¥ |
| SYN | Synchronize | åŒæ­¥åºåˆ—å·ï¼ˆå»ºç«‹è¿æ¥ï¼‰ |
| FIN | Finish | å‘é€æ–¹å®Œæˆæ•°æ®å‘é€ï¼ˆå…³é—­è¿æ¥ï¼‰ |

#### TCPä¸‰æ¬¡æ¡æ‰‹ï¼ˆConnection Establishmentï¼‰

**è¯¦ç»†è¿‡ç¨‹ï¼š**

```plain
å®¢æˆ·ç«¯                                      æœåŠ¡å™¨
  |                                           |
  | SYN (seq=x)                              | LISTEN
  |----------------------------------------->| SYN_RCVD
  |                                           |
  | SYN-ACK (seq=y, ack=x+1)                 |
  |<-----------------------------------------|
  | ESTABLISHED                               |
  | ACK (ack=y+1)                            |
  |----------------------------------------->| ESTABLISHED
  |                                           |
```

**çŠ¶æ€è½¬æ¢ï¼š**
+ å®¢æˆ·ç«¯ï¼šCLOSED â†’ SYN_SENT â†’ ESTABLISHED
+ æœåŠ¡å™¨ï¼šCLOSED â†’ LISTEN â†’ SYN_RCVD â†’ ESTABLISHED

**ä¸ºä»€ä¹ˆéœ€è¦ä¸‰æ¬¡æ¡æ‰‹ï¼Ÿ**

1. âœ… **é˜²æ­¢æ—§è¿æ¥åˆå§‹åŒ–**ï¼šé¿å…å·²å¤±æ•ˆçš„è¿æ¥è¯·æ±‚çªç„¶åˆ°è¾¾æœåŠ¡å™¨
2. âœ… **åŒæ–¹åºåˆ—å·ç¡®è®¤**ï¼šç¡®ä¿åŒæ–¹éƒ½èƒ½æ”¶å‘æ•°æ®
3. âœ… **èµ„æºåˆ†é…æ—¶æœº**ï¼šæœåŠ¡å™¨åœ¨ç¬¬ä¸‰æ¬¡æ¡æ‰‹åæ‰åˆ†é…èµ„æº

```python
class TCPHandshake:
    """TCPä¸‰æ¬¡æ¡æ‰‹æ¨¡æ‹Ÿ"""
    
    def __init__(self):
        self.client_seq = 1000
        self.server_seq = 2000
        self.client_state = 'CLOSED'
        self.server_state = 'LISTEN'
    
    def step1_client_syn(self):
        """ç¬¬ä¸€æ­¥ï¼šå®¢æˆ·ç«¯å‘é€SYN"""
        print(f"å®¢æˆ·ç«¯: {self.client_state} â†’ SYN_SENT")
        print(f"å‘é€: SYN, seq={self.client_seq}")
        self.client_state = 'SYN_SENT'
        return {'SYN': True, 'seq': self.client_seq}
    
    def step2_server_syn_ack(self, received):
        """ç¬¬äºŒæ­¥ï¼šæœåŠ¡å™¨å‘é€SYN-ACK"""
        print(f"\næœåŠ¡å™¨: {self.server_state} â†’ SYN_RCVD")
        ack = received['seq'] + 1
        print(f"å‘é€: SYN-ACK, seq={self.server_seq}, ack={ack}")
        self.server_state = 'SYN_RCVD'
        return {'SYN': True, 'ACK': True, 'seq': self.server_seq, 'ack': ack}
    
    def step3_client_ack(self, received):
        """ç¬¬ä¸‰æ­¥ï¼šå®¢æˆ·ç«¯å‘é€ACK"""
        print(f"\nå®¢æˆ·ç«¯: {self.client_state} â†’ ESTABLISHED")
        ack = received['seq'] + 1
        print(f"å‘é€: ACK, ack={ack}")
        self.client_state = 'ESTABLISHED'
        return {'ACK': True, 'ack': ack}
    
    def step4_server_established(self, received):
        """ç¬¬å››æ­¥ï¼šæœåŠ¡å™¨ç¡®è®¤å»ºç«‹è¿æ¥"""
        print(f"\næœåŠ¡å™¨: {self.server_state} â†’ ESTABLISHED")
        self.server_state = 'ESTABLISHED'
        print("è¿æ¥å»ºç«‹æˆåŠŸï¼\n")
    
    def simulate(self):
        """æ¨¡æ‹Ÿå®Œæ•´ä¸‰æ¬¡æ¡æ‰‹"""
        print("=== TCPä¸‰æ¬¡æ¡æ‰‹æ¨¡æ‹Ÿ ===\n")
        packet1 = self.step1_client_syn()
        packet2 = self.step2_server_syn_ack(packet1)
        packet3 = self.step3_client_ack(packet2)
        self.step4_server_established(packet3)

# æ¼”ç¤º
handshake = TCPHandshake()
handshake.simulate()
```

#### TCPå››æ¬¡æŒ¥æ‰‹ï¼ˆConnection Terminationï¼‰

**è¯¦ç»†è¿‡ç¨‹ï¼š**

```plain
å®¢æˆ·ç«¯                                      æœåŠ¡å™¨
  |                                           |
  | FIN (seq=u)                              | ESTABLISHED
  |----------------------------------------->| CLOSE_WAIT
  | FIN_WAIT_1                                |
  | ACK (ack=u+1)                            |
  |<-----------------------------------------|
  | FIN_WAIT_2                                |
  |                                           |
  | FIN (seq=v)                              |
  |<-----------------------------------------| LAST_ACK
  | TIME_WAIT                                 |
  | ACK (ack=v+1)                            |
  |----------------------------------------->| CLOSED
  | (ç­‰å¾…2MSL)                                |
  | CLOSED                                    |
```

**ä¸ºä»€ä¹ˆéœ€è¦å››æ¬¡æŒ¥æ‰‹ï¼Ÿ**

+ TCPæ˜¯**å…¨åŒå·¥**é€šä¿¡ï¼Œæ¯ä¸ªæ–¹å‘éƒ½éœ€è¦ç‹¬ç«‹å…³é—­
+ ç¬¬ä¸€æ¬¡FINï¼šå®¢æˆ·ç«¯è¡¨ç¤ºä¸å†å‘é€æ•°æ®
+ ç¬¬äºŒæ¬¡ACKï¼šæœåŠ¡å™¨ç¡®è®¤æ”¶åˆ°FIN
+ ç¬¬ä¸‰æ¬¡FINï¼šæœåŠ¡å™¨è¡¨ç¤ºä¸å†å‘é€æ•°æ®
+ ç¬¬å››æ¬¡ACKï¼šå®¢æˆ·ç«¯ç¡®è®¤æ”¶åˆ°FIN

**TIME_WAITçŠ¶æ€ï¼ˆ2MSLï¼‰ï¼š**

+ **MSL**ï¼ˆMaximum Segment Lifetimeï¼‰ï¼šæŠ¥æ–‡æœ€å¤§ç”Ÿå­˜æ—¶é—´ï¼Œé€šå¸¸ä¸º2åˆ†é’Ÿ
+ **2MSL**ï¼šç­‰å¾…4åˆ†é’Ÿï¼Œç¡®ä¿æœ€åçš„ACKèƒ½è¢«æ¥æ”¶
+ **ç›®çš„**ï¼š
  - ç¡®ä¿æœ€åçš„ACKèƒ½åˆ°è¾¾æœåŠ¡å™¨
  - é¿å…æ–°è¿æ¥æ”¶åˆ°æ—§è¿æ¥çš„å»¶è¿Ÿæ•°æ®

```python
class TCPClose:
    """TCPå››æ¬¡æŒ¥æ‰‹æ¨¡æ‹Ÿ"""
    
    def __init__(self):
        self.client_seq = 3000
        self.server_seq = 4000
        self.client_state = 'ESTABLISHED'
        self.server_state = 'ESTABLISHED'
    
    def step1_client_fin(self):
        """ç¬¬ä¸€æ¬¡æŒ¥æ‰‹ï¼šå®¢æˆ·ç«¯FIN"""
        print(f"å®¢æˆ·ç«¯: {self.client_state} â†’ FIN_WAIT_1")
        print(f"å‘é€: FIN, seq={self.client_seq}")
        self.client_state = 'FIN_WAIT_1'
        return {'FIN': True, 'seq': self.client_seq}
    
    def step2_server_ack(self, received):
        """ç¬¬äºŒæ¬¡æŒ¥æ‰‹ï¼šæœåŠ¡å™¨ACK"""
        print(f"\næœåŠ¡å™¨: {self.server_state} â†’ CLOSE_WAIT")
        ack = received['seq'] + 1
        print(f"å‘é€: ACK, ack={ack}")
        self.server_state = 'CLOSE_WAIT'
        self.client_state = 'FIN_WAIT_2'
        print(f"å®¢æˆ·ç«¯: FIN_WAIT_1 â†’ FIN_WAIT_2")
        return {'ACK': True, 'ack': ack}
    
    def step3_server_fin(self):
        """ç¬¬ä¸‰æ¬¡æŒ¥æ‰‹ï¼šæœåŠ¡å™¨FIN"""
        print(f"\næœåŠ¡å™¨: {self.server_state} â†’ LAST_ACK")
        print(f"å‘é€: FIN, seq={self.server_seq}")
        self.server_state = 'LAST_ACK'
        return {'FIN': True, 'seq': self.server_seq}
    
    def step4_client_ack(self, received):
        """ç¬¬å››æ¬¡æŒ¥æ‰‹ï¼šå®¢æˆ·ç«¯ACK"""
        print(f"\nå®¢æˆ·ç«¯: {self.client_state} â†’ TIME_WAIT")
        ack = received['seq'] + 1
        print(f"å‘é€: ACK, ack={ack}")
        self.client_state = 'TIME_WAIT'
        self.server_state = 'CLOSED'
        print(f"æœåŠ¡å™¨: LAST_ACK â†’ CLOSED")
        print(f"å®¢æˆ·ç«¯: ç­‰å¾…2MSLåå…³é—­...")
        return {'ACK': True, 'ack': ack}
    
    def simulate(self):
        """æ¨¡æ‹Ÿå®Œæ•´å››æ¬¡æŒ¥æ‰‹"""
        print("=== TCPå››æ¬¡æŒ¥æ‰‹æ¨¡æ‹Ÿ ===\n")
        packet1 = self.step1_client_fin()
        packet2 = self.step2_server_ack(packet1)
        packet3 = self.step3_server_fin()
        packet4 = self.step4_client_ack(packet3)
        print("\nè¿æ¥å…³é—­å®Œæˆï¼\n")

# æ¼”ç¤º
close = TCPClose()
close.simulate()
```

#### TCPæ»‘åŠ¨çª—å£ï¼ˆSliding Windowï¼‰

**ç›®çš„**ï¼šæµé‡æ§åˆ¶å’Œæé«˜ä¼ è¾“æ•ˆç‡

**çª—å£å¤§å°è®¡ç®—ï¼š**

$$
\text{AdvertisedWindow} = \text{MaxRcvBuffer} - (\text{LastByteRcvd} - \text{LastByteRead})
$$

**å‘é€çª—å£ï¼š**

```plain
å·²å‘é€å·²ç¡®è®¤ | å·²å‘é€æœªç¡®è®¤ | å¯å‘é€ | ä¸å¯å‘é€
           â†‘             â†‘        â†‘
    LastByteAcked  LastByteSent  LastByteAcked+AdvertisedWindow
           |<--- å‘é€çª—å£ --->|
```

```python
class SlidingWindow:
    """TCPæ»‘åŠ¨çª—å£æ¨¡æ‹Ÿ"""
    
    def __init__(self, window_size=8):
        self.window_size = window_size
        self.base = 0  # çª—å£åŸºå€ï¼ˆæœ€æ—©æœªç¡®è®¤çš„åºå·ï¼‰
        self.next_seq = 0  # ä¸‹ä¸€ä¸ªè¦å‘é€çš„åºå·
        self.buffer = {}  # å‘é€ç¼“å†²åŒº
        self.acked = set()  # å·²ç¡®è®¤çš„åºå·
    
    def send(self, data):
        """å‘é€æ•°æ®"""
        if self.next_seq < self.base + self.window_size:
            self.buffer[self.next_seq] = data
            print(f"å‘é€: seq={self.next_seq}, data='{data}'")
            self.next_seq += 1
            return True
        else:
            print(f"çª—å£å·²æ»¡ï¼Œç­‰å¾…ACK...")
            return False
    
    def receive_ack(self, ack_num):
        """æ¥æ”¶ACK"""
        print(f"æ”¶åˆ°ACK: {ack_num}")
        self.acked.add(ack_num)
        
        # ç§»åŠ¨çª—å£åŸºå€
        while self.base in self.acked:
            print(f"  çª—å£æ»‘åŠ¨: {self.base} â†’ {self.base + 1}")
            del self.buffer[self.base]
            self.base += 1
    
    def get_window_status(self):
        """è·å–çª—å£çŠ¶æ€"""
        return {
            'base': self.base,
            'next_seq': self.next_seq,
            'window_size': self.window_size,
            'in_flight': self.next_seq - self.base,
            'available': self.window_size - (self.next_seq - self.base)
        }
    
    def demo(self):
        """æ¼”ç¤ºæ»‘åŠ¨çª—å£"""
        print("=== æ»‘åŠ¨çª—å£æ¼”ç¤º ===\n")
        
        # å‘é€8ä¸ªæ•°æ®åŒ…ï¼ˆå¡«æ»¡çª—å£ï¼‰
        for i in range(8):
            self.send(f"DATA{i}")
        
        print(f"\nçª—å£çŠ¶æ€: {self.get_window_status()}\n")
        
        # å°è¯•å†å‘é€ï¼ˆçª—å£å·²æ»¡ï¼‰
        self.send("DATA8")
        
        # æ”¶åˆ°ACK 0, 1, 2
        print("\n")
        self.receive_ack(0)
        self.receive_ack(1)
        self.receive_ack(2)
        
        print(f"\nçª—å£çŠ¶æ€: {self.get_window_status()}\n")
        
        # ç°åœ¨å¯ä»¥ç»§ç»­å‘é€
        self.send("DATA8")
        self.send("DATA9")
        self.send("DATA10")

# æ¼”ç¤º
window = SlidingWindow(window_size=8)
window.demo()
```

#### TCPå¿«é€Ÿé‡ä¼ ï¼ˆFast Retransmitï¼‰

**åŸç†**ï¼šæ”¶åˆ°3ä¸ªé‡å¤ACKæ—¶ï¼Œç«‹å³é‡ä¼ ï¼ˆä¸ç­‰è¶…æ—¶ï¼‰

```python
class FastRetransmit:
    """å¿«é€Ÿé‡ä¼ æœºåˆ¶"""
    
    def __init__(self):
        self.next_seq = 0
        self.dup_ack_count = {}
        self.sent_packets = {}
    
    def send_packet(self, seq, data):
        """å‘é€æ•°æ®åŒ…"""
        self.sent_packets[seq] = data
        print(f"å‘é€: seq={seq}, data='{data}'")
        self.next_seq = seq + 1
    
    def receive_ack(self, ack_num):
        """æ¥æ”¶ACK"""
        # ç»Ÿè®¡é‡å¤ACK
        if ack_num not in self.dup_ack_count:
            self.dup_ack_count[ack_num] = 0
        
        self.dup_ack_count[ack_num] += 1
        dup_count = self.dup_ack_count[ack_num]
        
        print(f"æ”¶åˆ°ACK: {ack_num} (é‡å¤{dup_count}æ¬¡)")
        
        # å¿«é€Ÿé‡ä¼ ï¼š3ä¸ªé‡å¤ACK
        if dup_count == 3:
            print(f"âš ï¸ æ£€æµ‹åˆ°3ä¸ªé‡å¤ACKï¼Œå¿«é€Ÿé‡ä¼  seq={ack_num}")
            self.retransmit(ack_num)
    
    def retransmit(self, seq):
        """é‡ä¼ æ•°æ®åŒ…"""
        if seq in self.sent_packets:
            data = self.sent_packets[seq]
            print(f"ğŸ”„ é‡ä¼ : seq={seq}, data='{data}'")
    
    def demo(self):
        """æ¼”ç¤ºå¿«é€Ÿé‡ä¼ """
        print("=== å¿«é€Ÿé‡ä¼ æ¼”ç¤º ===\n")
        
        # å‘é€seq 0-5
        for i in range(6):
            self.send_packet(i, f"DATA{i}")
        
        print("\nå‡è®¾seq=2ä¸¢å¤±ï¼Œæ¥æ”¶æ–¹ä¼šæŒç»­å‘é€ACK=2\n")
        
        # æ”¶åˆ°ACK 0, 1
        self.receive_ack(0)
        self.receive_ack(1)
        
        # seq=2ä¸¢å¤±ï¼Œåç»­æ•°æ®åŒ…è§¦å‘é‡å¤ACK
        print("\nseq=3,4,5åˆ°è¾¾ï¼Œè§¦å‘é‡å¤ACK=2ï¼š\n")
        self.receive_ack(2)  # ç¬¬1æ¬¡
        self.receive_ack(2)  # ç¬¬2æ¬¡
        self.receive_ack(2)  # ç¬¬3æ¬¡ â†’ è§¦å‘å¿«é€Ÿé‡ä¼ 

# æ¼”ç¤º
fast_retx = FastRetransmit()
fast_retx.demo()
```

#### TCPå®Œæ•´æœåŠ¡å™¨/å®¢æˆ·ç«¯å®ç°

```python
import socket
import threading

class TCPServer:
    """å®Œæ•´TCPæœåŠ¡å™¨"""
    
    def __init__(self, host='0.0.0.0', port=8888):
        self.host = host
        self.port = port
        self.server_socket = None
    
    def start(self):
        """å¯åŠ¨æœåŠ¡å™¨"""
        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        
        # è®¾ç½®socketé€‰é¡¹
        self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        
        # ç»‘å®šåœ°å€
        self.server_socket.bind((self.host, self.port))
        
        # ç›‘å¬è¿æ¥ï¼ˆæœ€å¤§é˜Ÿåˆ—é•¿åº¦5ï¼‰
        self.server_socket.listen(5)
        
        print(f"TCPæœåŠ¡å™¨å¯åŠ¨: {self.host}:{self.port}")
        
        try:
    while True:
                # æ¥å—è¿æ¥
                client_socket, client_addr = self.server_socket.accept()
                print(f"æ–°è¿æ¥: {client_addr}")
                
                # åˆ›å»ºçº¿ç¨‹å¤„ç†å®¢æˆ·ç«¯
                thread = threading.Thread(
                    target=self.handle_client,
                    args=(client_socket, client_addr)
                )
                thread.start()
        
        except KeyboardInterrupt:
            print("\næœåŠ¡å™¨å…³é—­")
        finally:
            self.server_socket.close()
    
    def handle_client(self, client_socket, client_addr):
        """å¤„ç†å®¢æˆ·ç«¯è¿æ¥"""
        try:
            while True:
                # æ¥æ”¶æ•°æ®
                data = client_socket.recv(1024)
                
                if not data:
                    print(f"è¿æ¥å…³é—­: {client_addr}")
                    break
                
                print(f"æ”¶åˆ°æ•°æ® from {client_addr}: {data.decode()}")
                
                # å›æ˜¾æ•°æ®
                response = f"Echo: {data.decode()}"
                client_socket.send(response.encode())
        
        except Exception as e:
            print(f"é”™è¯¯ {client_addr}: {e}")
        finally:
            client_socket.close()

class TCPClient:
    """å®Œæ•´TCPå®¢æˆ·ç«¯"""
    
    def __init__(self, server_host, server_port):
        self.server_host = server_host
        self.server_port = server_port
        self.socket = None
    
    def connect(self):
        """è¿æ¥æœåŠ¡å™¨"""
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.socket.connect((self.server_host, self.server_port))
        print(f"å·²è¿æ¥åˆ°æœåŠ¡å™¨: {self.server_host}:{self.server_port}")
    
    def send(self, message):
        """å‘é€æ¶ˆæ¯"""
        self.socket.send(message.encode())
        print(f"å‘é€: {message}")
    
    def receive(self, buffer_size=1024):
        """æ¥æ”¶å“åº”"""
        data = self.socket.recv(buffer_size)
        response = data.decode()
        print(f"æ”¶åˆ°: {response}")
        return response
    
    def close(self):
        """å…³é—­è¿æ¥"""
        self.socket.close()
        print("è¿æ¥å·²å…³é—­")

# ä½¿ç”¨ç¤ºä¾‹
# æœåŠ¡å™¨ç«¯
# server = TCPServer()
# server.start()

# å®¢æˆ·ç«¯
# client = TCPClient('localhost', 8888)
# client.connect()
# client.send("Hello, Server!")
# client.receive()
# client.close()
```

### 2.2 UDPåè®®è¯¦è§£

#### UDPå¤´éƒ¨æ ¼å¼

```plain
 0      7 8     15 16    23 24    31
+--------+--------+--------+--------+
|    æºç«¯å£å·    |   ç›®çš„ç«¯å£å·     |
+--------+--------+--------+--------+
|     é•¿åº¦       |      æ ¡éªŒå’Œ      |
+--------+--------+--------+--------+
|                                   |
|            æ•°æ®                   |
|                                   |
+-----------------------------------+
```

**UDPç‰¹ç‚¹ï¼š**

| ç‰¹æ€§ | UDP | TCP |
|------|-----|-----|
| è¿æ¥ | æ— è¿æ¥ | é¢å‘è¿æ¥ |
| å¯é æ€§ | ä¸å¯é  | å¯é  |
| é¡ºåº | æ— åº | æœ‰åº |
| å¼€é”€ | 8å­—èŠ‚ | 20-60å­—èŠ‚ |
| é€Ÿåº¦ | å¿« | æ…¢ |
| åº”ç”¨åœºæ™¯ | è§†é¢‘ã€æ¸¸æˆã€DNS | HTTPã€FTPã€é‚®ä»¶ |

**UDPåº”ç”¨åœºæ™¯ï¼š**

1. âœ… **å®æ—¶è§†é¢‘/éŸ³é¢‘**ï¼šä¸¢åŒ…å¯å®¹å¿ï¼Œå»¶è¿Ÿæ•æ„Ÿ
2. âœ… **åœ¨çº¿æ¸¸æˆ**ï¼šå¿«é€Ÿå“åº”ï¼Œå¶å°”ä¸¢åŒ…æ— å½±å“
3. âœ… **DNSæŸ¥è¯¢**ï¼šç®€å•è¯·æ±‚/å“åº”ï¼Œå¿«é€Ÿ
4. âœ… **å¹¿æ’­/å¤šæ’­**ï¼šä¸€å¯¹å¤šé€šä¿¡
5. âœ… **ç‰©è”ç½‘**ï¼šè®¾å¤‡èµ„æºå—é™

```python
import socket
import threading
import time

class UDPServer:
    """å®Œæ•´UDPæœåŠ¡å™¨"""
    
    def __init__(self, host='0.0.0.0', port=9999):
        self.host = host
        self.port = port
        self.socket = None
    
    def start(self):
        """å¯åŠ¨æœåŠ¡å™¨"""
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind((self.host, self.port))
        
        print(f"UDPæœåŠ¡å™¨å¯åŠ¨: {self.host}:{self.port}")
        
        try:
    while True:
                # æ¥æ”¶æ•°æ®
                data, client_addr = self.socket.recvfrom(1024)
                print(f"æ”¶åˆ°æ•°æ® from {client_addr}: {data.decode()}")
                
                # å›æ˜¾æ•°æ®
                response = f"Echo: {data.decode()}"
                self.socket.sendto(response.encode(), client_addr)
        
        except KeyboardInterrupt:
            print("\næœåŠ¡å™¨å…³é—­")
        finally:
            self.socket.close()

class UDPClient:
    """å®Œæ•´UDPå®¢æˆ·ç«¯"""
    
    def __init__(self, server_host, server_port):
        self.server_host = server_host
        self.server_port = server_port
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    
    def send(self, message):
        """å‘é€æ¶ˆæ¯"""
        self.socket.sendto(message.encode(), (self.server_host, self.server_port))
        print(f"å‘é€: {message}")
    
    def receive(self, timeout=5):
        """æ¥æ”¶å“åº”"""
        self.socket.settimeout(timeout)
        try:
            data, server_addr = self.socket.recvfrom(1024)
            response = data.decode()
            print(f"æ”¶åˆ°: {response}")
            return response
        except socket.timeout:
            print("æ¥æ”¶è¶…æ—¶")
            return None
    
    def close(self):
        """å…³é—­socket"""
        self.socket.close()
        print("Socketå·²å…³é—­")

# ä½¿ç”¨ç¤ºä¾‹
# æœåŠ¡å™¨ç«¯
# server = UDPServer()
# server.start()

# å®¢æˆ·ç«¯
# client = UDPClient('localhost', 9999)
# client.send("Hello, UDP Server!")
# client.receive()
# client.close()
```

#### UDPå¯é ä¼ è¾“å®ç°ï¼ˆæ¨¡æ‹Ÿï¼‰

**è‡ªå®šä¹‰å¯é UDPåè®®ï¼š**

```python
import struct
import hashlib

class ReliableUDP:
    """å¯é UDPä¼ è¾“ï¼ˆæ·»åŠ åºåˆ—å·ã€ACKã€é‡ä¼ ï¼‰"""
    
    def __init__(self, socket, timeout=1.0):
        self.socket = socket
        self.timeout = timeout
        self.seq_num = 0
        self.expected_seq = 0
    
    def _create_packet(self, seq, data):
        """åˆ›å»ºæ•°æ®åŒ…ï¼ˆåºåˆ—å· + æ•°æ® + æ ¡éªŒå’Œï¼‰"""
        # åŒ…æ ¼å¼: [åºåˆ—å·(4å­—èŠ‚)][æ•°æ®é•¿åº¦(4å­—èŠ‚)][æ•°æ®][æ ¡éªŒå’Œ(16å­—èŠ‚)]
        data_bytes = data.encode() if isinstance(data, str) else data
        header = struct.pack('!II', seq, len(data_bytes))
        checksum = hashlib.md5(header + data_bytes).digest()
        return header + data_bytes + checksum
    
    def _parse_packet(self, packet):
        """è§£ææ•°æ®åŒ…"""
        if len(packet) < 24:  # æœ€å°åŒ…é•¿åº¦
            return None, None, False
        
        seq, data_len = struct.unpack('!II', packet[:8])
        data = packet[8:8+data_len]
        checksum = packet[8+data_len:]
        
        # éªŒè¯æ ¡éªŒå’Œ
        expected_checksum = hashlib.md5(packet[:8+data_len]).digest()
        valid = checksum == expected_checksum
        
        return seq, data, valid
    
    def send_reliable(self, data, dest_addr):
        """å¯é å‘é€"""
        packet = self._create_packet(self.seq_num, data)
        max_retries = 3
        retries = 0
        
        while retries < max_retries:
            # å‘é€æ•°æ®åŒ…
            self.socket.sendto(packet, dest_addr)
            print(f"å‘é€: seq={self.seq_num}, å°è¯•{retries+1}/{max_retries}")
            
            try:
                # ç­‰å¾…ACK
                self.socket.settimeout(self.timeout)
                ack_packet, _ = self.socket.recvfrom(1024)
                ack_seq, _, valid = self._parse_packet(ack_packet)
                
                if valid and ack_seq == self.seq_num:
                    print(f"æ”¶åˆ°ACK: seq={ack_seq}")
                    self.seq_num += 1
                    return True
            
            except socket.timeout:
                print(f"è¶…æ—¶ï¼Œé‡ä¼ ...")
                retries += 1
        
        print(f"å‘é€å¤±è´¥: è¶…è¿‡æœ€å¤§é‡è¯•æ¬¡æ•°")
        return False
    
    def receive_reliable(self):
        """å¯é æ¥æ”¶"""
    while True:
            packet, sender_addr = self.socket.recvfrom(1024)
            seq, data, valid = self._parse_packet(packet)
            
            if not valid:
                print("æ•°æ®åŒ…æ ¡éªŒå¤±è´¥ï¼Œä¸¢å¼ƒ")
                continue
            
            print(f"æ”¶åˆ°æ•°æ®åŒ…: seq={seq}")
            
            # å‘é€ACK
            ack_packet = self._create_packet(seq, b'ACK')
            self.socket.sendto(ack_packet, sender_addr)
            print(f"å‘é€ACK: seq={seq}")
            
            # æ£€æŸ¥åºåˆ—å·
            if seq == self.expected_seq:
                self.expected_seq += 1
                return data, sender_addr
            else:
                print(f"åºåˆ—å·é”™è¯¯ï¼ŒæœŸæœ›{self.expected_seq}ï¼Œæ”¶åˆ°{seq}")

# ä½¿ç”¨ç¤ºä¾‹
# å‘é€ç«¯
# sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
# reliable = ReliableUDP(sock)
# reliable.send_reliable("Hello", ("localhost", 9999))
```

### 2.3 TCPæ‹¥å¡æ§åˆ¶

#### æ‹¥å¡æ§åˆ¶ç®—æ³•

**å››ä¸ªé˜¶æ®µï¼š**

1. **æ…¢å¯åŠ¨ï¼ˆSlow Startï¼‰**ï¼šæŒ‡æ•°å¢é•¿
2. **æ‹¥å¡é¿å…ï¼ˆCongestion Avoidanceï¼‰**ï¼šçº¿æ€§å¢é•¿
3. **å¿«é€Ÿé‡ä¼ ï¼ˆFast Retransmitï¼‰**ï¼š3ä¸ªé‡å¤ACK
4. **å¿«é€Ÿæ¢å¤ï¼ˆFast Recoveryï¼‰**ï¼šå‡åŠåçº¿æ€§å¢é•¿

**æ‹¥å¡çª—å£å˜åŒ–ï¼š**

```plain
cwnd
  |
64|                  /\
  |                 /  \
32|                /    \___/\___
  |               /              \___
16|              /                   \___
  |             /
 8|           /
  |         /
 4|       /
  |     /
 2|   /
  | /
 1|/____________________________________> RTT
   æ…¢å¯åŠ¨  æ‹¥å¡é¿å…    å¿«é€Ÿæ¢å¤
```

**å®Œæ•´æ‹¥å¡æ§åˆ¶å®ç°ï¼š**

```python
class TCPCongestionControl:
    """TCPæ‹¥å¡æ§åˆ¶ï¼ˆRenoç®—æ³•ï¼‰"""
    
    def __init__(self, initial_ssthresh=64):
        self.cwnd = 1  # æ‹¥å¡çª—å£
        self.ssthresh = initial_ssthresh  # æ…¢å¯åŠ¨é˜ˆå€¼
        self.state = 'slow_start'
        self.dup_ack_count = 0
        self.history = []
    
    def on_ack(self, is_duplicate=False):
        """æ”¶åˆ°ACK"""
        if is_duplicate:
            self.dup_ack_count += 1
            
            # å¿«é€Ÿé‡ä¼ ï¼š3ä¸ªé‡å¤ACK
            if self.dup_ack_count == 3:
                print(f"âš ï¸ å¿«é€Ÿé‡ä¼ è§¦å‘")
                self.fast_retransmit()
        else:
            # æ­£å¸¸ACKï¼Œé‡ç½®é‡å¤è®¡æ•°
            self.dup_ack_count = 0
            
        if self.state == 'slow_start':
                # æ…¢å¯åŠ¨ï¼šæŒ‡æ•°å¢é•¿
                self.cwnd *= 2
                print(f"æ…¢å¯åŠ¨: cwnd={self.cwnd}")
                
            if self.cwnd >= self.ssthresh:
                self.state = 'congestion_avoidance'
                    print(f"è¿›å…¥æ‹¥å¡é¿å…é˜¶æ®µ")
            
            elif self.state == 'congestion_avoidance':
                # æ‹¥å¡é¿å…ï¼šçº¿æ€§å¢é•¿ï¼ˆæ¯ä¸ªRTTå¢åŠ 1ï¼‰
                self.cwnd += 1
                print(f"æ‹¥å¡é¿å…: cwnd={self.cwnd}")
            
            elif self.state == 'fast_recovery':
                # å¿«é€Ÿæ¢å¤
                self.cwnd = self.ssthresh
                self.state = 'congestion_avoidance'
                print(f"å¿«é€Ÿæ¢å¤å®Œæˆï¼Œè¿›å…¥æ‹¥å¡é¿å…")
        
        self.history.append({
            'cwnd': self.cwnd,
            'ssthresh': self.ssthresh,
            'state': self.state
        })
    
    def on_timeout(self):
        """è¶…æ—¶ï¼ˆä¸¥é‡æ‹¥å¡ï¼‰"""
        print(f"âš ï¸ è¶…æ—¶å‘ç”Ÿï¼")
        self.ssthresh = max(self.cwnd // 2, 2)
        self.cwnd = 1
        self.state = 'slow_start'
        self.dup_ack_count = 0
        print(f"é‡ç½®: cwnd=1, ssthresh={self.ssthresh}")
        
        self.history.append({
            'cwnd': self.cwnd,
            'ssthresh': self.ssthresh,
            'state': self.state
        })
    
    def fast_retransmit(self):
        """å¿«é€Ÿé‡ä¼ """
        print(f"è¿›å…¥å¿«é€Ÿæ¢å¤")
        self.ssthresh = max(self.cwnd // 2, 2)
        self.cwnd = self.ssthresh + 3  # é¢å¤–çš„3ä¸ªé‡å¤ACK
        self.state = 'fast_recovery'
        print(f"å¿«é€Ÿæ¢å¤: cwnd={self.cwnd}, ssthresh={self.ssthresh}")
    
    def plot_history(self):
        """æ‰“å°å†å²è®°å½•"""
        print("\nRTT | cwnd | ssthresh | state")
        print("----+------+----------+-------------------")
        for i, h in enumerate(self.history):
            print(f"{i:3} | {h['cwnd']:4} | {h['ssthresh']:8} | {h['state']}")

# æ¼”ç¤ºå®Œæ•´æ‹¥å¡æ§åˆ¶
print("=== TCPæ‹¥å¡æ§åˆ¶æ¼”ç¤º ===\n")
tcp = TCPCongestionControl(initial_ssthresh=16)

# æ…¢å¯åŠ¨é˜¶æ®µ
for i in range(5):
    tcp.on_ack()

print(f"\nå½“å‰çŠ¶æ€: cwnd={tcp.cwnd}, state={tcp.state}\n")

# æ‹¥å¡é¿å…é˜¶æ®µ
for i in range(10):
    tcp.on_ack()

print(f"\nå½“å‰çŠ¶æ€: cwnd={tcp.cwnd}, state={tcp.state}\n")

# æ¨¡æ‹Ÿä¸¢åŒ…ï¼ˆå¿«é€Ÿé‡ä¼ ï¼‰
print("\næ¨¡æ‹Ÿä¸¢åŒ…ï¼šæ”¶åˆ°3ä¸ªé‡å¤ACK\n")
tcp.on_ack(is_duplicate=True)
tcp.on_ack(is_duplicate=True)
tcp.on_ack(is_duplicate=True)

# å¿«é€Ÿæ¢å¤
for i in range(5):
    tcp.on_ack()

# æ¨¡æ‹Ÿè¶…æ—¶
print("\næ¨¡æ‹Ÿè¶…æ—¶ï¼š\n")
tcp.on_timeout()

# é‡æ–°æ…¢å¯åŠ¨
for i in range(10):
    tcp.on_ack()

# æ˜¾ç¤ºå†å²
tcp.plot_history()
```

#### æµé‡æ§åˆ¶ vs æ‹¥å¡æ§åˆ¶

| ç‰¹æ€§ | æµé‡æ§åˆ¶ | æ‹¥å¡æ§åˆ¶ |
|------|---------|---------|
| ç›®çš„ | ä¿æŠ¤æ¥æ”¶æ–¹ | ä¿æŠ¤ç½‘ç»œ |
| æ§åˆ¶å˜é‡ | æ¥æ”¶çª—å£ï¼ˆrwndï¼‰ | æ‹¥å¡çª—å£ï¼ˆcwndï¼‰ |
| è§¦å‘æ¡ä»¶ | æ¥æ”¶ç¼“å†²åŒºæ»¡ | ç½‘ç»œæ‹¥å¡ |
| æ§åˆ¶æœºåˆ¶ | æ»‘åŠ¨çª—å£ | æ…¢å¯åŠ¨ã€æ‹¥å¡é¿å… |
| å®é™…å‘é€çª—å£ | $\min(\text{rwnd}, \text{cwnd})$ | |

**RTTï¼ˆRound-Trip Timeï¼‰æµ‹é‡ï¼š**

```python
import time

class RTTEstimator:
    """RTTä¼°è®¡å™¨ï¼ˆç”¨äºè¶…æ—¶é‡ä¼ ï¼‰"""
    
    def __init__(self):
        self.srtt = None  # å¹³æ»‘RTT
        self.rttvar = None  # RTTå˜åŒ–
        self.rto = 1.0  # é‡ä¼ è¶…æ—¶æ—¶é—´
        
        # RFC 6298æ¨èå‚æ•°
        self.alpha = 0.125
        self.beta = 0.25
        self.k = 4
    
    def update(self, measured_rtt):
        """æ›´æ–°RTTä¼°è®¡"""
        if self.srtt is None:
            # é¦–æ¬¡æµ‹é‡
            self.srtt = measured_rtt
            self.rttvar = measured_rtt / 2
        else:
            # æ›´æ–°RTTVAR
            self.rttvar = (1 - self.beta) * self.rttvar + \
                          self.beta * abs(self.srtt - measured_rtt)
            
            # æ›´æ–°SRTT
            self.srtt = (1 - self.alpha) * self.srtt + \
                        self.alpha * measured_rtt
        
        # è®¡ç®—RTO
        self.rto = self.srtt + self.k * self.rttvar
        
        print(f"RTTæµ‹é‡: {measured_rtt:.3f}s")
        print(f"  SRTT: {self.srtt:.3f}s")
        print(f"  RTTVAR: {self.rttvar:.3f}s")
        print(f"  RTO: {self.rto:.3f}s\n")
        
        return self.rto

# æ¼”ç¤º
estimator = RTTEstimator()
rtts = [0.1, 0.12, 0.11, 0.15, 0.09, 0.13]

for rtt in rtts:
    estimator.update(rtt)
```

### 2.4 TCP vs UDPå¯¹æ¯”æ€»ç»“

```python
class ProtocolComparison:
    """åè®®å¯¹æ¯”æ¼”ç¤º"""
    
    @staticmethod
    def tcp_characteristics():
        """TCPç‰¹å¾"""
        return {
            'è¿æ¥': 'é¢å‘è¿æ¥ï¼ˆä¸‰æ¬¡æ¡æ‰‹/å››æ¬¡æŒ¥æ‰‹ï¼‰',
            'å¯é æ€§': 'å¯é ï¼ˆç¡®è®¤ã€é‡ä¼ ã€æµé‡æ§åˆ¶ï¼‰',
            'é¡ºåº': 'ä¿è¯é¡ºåºï¼ˆåºåˆ—å·ï¼‰',
            'é€Ÿåº¦': 'è¾ƒæ…¢ï¼ˆå¼€é”€å¤§ï¼‰',
            'å¤´éƒ¨å¤§å°': '20-60å­—èŠ‚',
            'æ‹¥å¡æ§åˆ¶': 'æœ‰',
            'åº”ç”¨': 'HTTP, FTP, SMTP, SSH'
        }
    
    @staticmethod
    def udp_characteristics():
        """UDPç‰¹å¾"""
        return {
            'è¿æ¥': 'æ— è¿æ¥',
            'å¯é æ€§': 'ä¸å¯é ï¼ˆå°½åŠ›è€Œä¸ºï¼‰',
            'é¡ºåº': 'ä¸ä¿è¯é¡ºåº',
            'é€Ÿåº¦': 'å¿«ï¼ˆå¼€é”€å°ï¼‰',
            'å¤´éƒ¨å¤§å°': '8å­—èŠ‚',
            'æ‹¥å¡æ§åˆ¶': 'æ— ',
            'åº”ç”¨': 'DNS, DHCP, è§†é¢‘æµ, æ¸¸æˆ'
        }
    
    @staticmethod
    def print_comparison():
        """æ‰“å°å¯¹æ¯”"""
        tcp = ProtocolComparison.tcp_characteristics()
        udp = ProtocolComparison.udp_characteristics()
        
        print("TCP vs UDP å¯¹æ¯”")
        print("=" * 60)
        print(f"{'ç‰¹æ€§':<10} | {'TCP':<25} | {'UDP':<25}")
        print("-" * 60)
        
        for key in tcp.keys():
            print(f"{key:<10} | {tcp[key]:<25} | {udp[key]:<25}")

# æ¼”ç¤º
ProtocolComparison.print_comparison()
```

---

**æœ¬ç« å®Œ**
