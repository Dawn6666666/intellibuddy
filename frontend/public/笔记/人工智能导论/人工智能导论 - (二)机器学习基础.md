# 人工智能导论 - (二)机器学习基础

掌握机器学习基础。

---

## 2. 机器学习基础

### 2.1 线性回归

```python
import numpy as np
import matplotlib.pyplot as plt

class LinearRegression:
    def __init__(self, learning_rate=0.01, epochs=1000):
        self.lr = learning_rate
        self.epochs = epochs
        self.weights = None
        self.bias = None
    
    def fit(self, X, y):
        """训练模型"""
        n_samples, n_features = X.shape
        self.weights = np.zeros(n_features)
        self.bias = 0
        
        for i in range(self.epochs):
            # 前向传播
            y_pred = np.dot(X, self.weights) + self.bias
            
            # 计算损失
            cost = (1 / (2 * n_samples)) * np.sum((y_pred - y) ** 2)
            
            # 反向传播
            dw = (1 / n_samples) * np.dot(X.T, (y_pred - y))
            db = (1 / n_samples) * np.sum(y_pred - y)
            
            # 更新参数
            self.weights -= self.lr * dw
            self.bias -= self.lr * db
    
    def predict(self, X):
        """预测"""
        return np.dot(X, self.weights) + self.bias

# 示例
np.random.seed(42)
X = np.random.randn(100, 1)
y = 2 * X.squeeze() + 1 + np.random.randn(100) * 0.1

model = LinearRegression()
model.fit(X, y)

predictions = model.predict(X)
print(f"权重: {model.weights[0]:.2f}, 偏置: {model.bias:.2f}")
```

### 2.2 K-均值聚类

```python
import numpy as np
import matplotlib.pyplot as plt

class KMeans:
    def __init__(self, k=3, max_iters=100):
        self.k = k
        self.max_iters = max_iters
    
    def fit(self, X):
        """训练聚类模型"""
        n_samples, n_features = X.shape
        
        # 随机初始化聚类中心
        self.centroids = np.random.randn(self.k, n_features)
        
        for _ in range(self.max_iters):
            # 分配样本到最近的聚类中心
            distances = np.sqrt(((X - self.centroids[:, np.newaxis])**2).sum(axis=2))
            self.labels = np.argmin(distances, axis=0)
            
            # 更新聚类中心
            new_centroids = np.array([X[self.labels == i].mean(axis=0) for i in range(self.k)])
            
            # 检查收敛
            if np.allclose(self.centroids, new_centroids):
                break
            
            self.centroids = new_centroids
        
        return self.labels
    
    def predict(self, X):
        """预测新样本的聚类"""
        distances = np.sqrt(((X - self.centroids[:, np.newaxis])**2).sum(axis=2))
        return np.argmin(distances, axis=0)

# 示例
np.random.seed(42)
X = np.vstack([
    np.random.randn(30, 2) + [2, 2],
    np.random.randn(30, 2) + [-2, -2],
    np.random.randn(30, 2) + [2, -2]
])

kmeans = KMeans(k=3)
labels = kmeans.fit(X)
print(f"聚类中心: {kmeans.centroids}")
```

---

**本章完**
