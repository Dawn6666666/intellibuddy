# 人工智能导论 - (八)实战项目

AI实战应用项目。

---

## 8. 实战项目

### 8.1 手写数字识别（MNIST）

```python
import numpy as np
from sklearn.datasets import load_digits
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler

# 加载数据
digits = load_digits()
X, y = digits.data, digits.target

# 划分数据集
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# 标准化
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

# One-hot编码
def one_hot_encode(y, n_classes):
    one_hot = np.zeros((len(y), n_classes))
    one_hot[np.arange(len(y)), y] = 1
    return one_hot

y_train_encoded = one_hot_encode(y_train, 10)
y_test_encoded = one_hot_encode(y_test, 10)

# 训练MLP
mlp = MLP([64, 32, 10], learning_rate=0.01)
mlp.train(X_train, y_train_encoded, epochs=1000)

# 评估
predictions = mlp.forward(X_test)
pred_labels = np.argmax(predictions, axis=1)
accuracy = np.mean(pred_labels == y_test)
print(f"测试集准确率: {accuracy * 100:.2f}%")
```

### 8.2 情感分析

```python
class SentimentAnalyzer:
    """简单情感分析器"""
    def __init__(self):
        self.positive_words = set([
            '好', '棒', '喜欢', '优秀', '完美', '赞', '厉害', '开心'
        ])
        self.negative_words = set([
            '差', '糟糕', '讨厌', '垃圾', '失望', '烂', '恶劣', '难过'
        ])
    
    def analyze(self, text):
        """分析情感"""
        words = list(text)
        
        positive_score = sum(1 for word in words if word in self.positive_words)
        negative_score = sum(1 for word in words if word in self.negative_words)
        
        if positive_score > negative_score:
            return 'positive', positive_score - negative_score
        elif negative_score > positive_score:
            return 'negative', negative_score - positive_score
        else:
            return 'neutral', 0

# 使用
analyzer = SentimentAnalyzer()
texts = [
    "这个产品真好用，我很喜欢！",
    "太差了，完全不能用。",
    "还可以吧。"
]

for text in texts:
    sentiment, score = analyzer.analyze(text)
    print(f"{text} → {sentiment} (分数: {score})")
```

### 8.3 推荐系统

```python
class CollaborativeFiltering:
    """协同过滤推荐"""
    def __init__(self, n_factors=10, learning_rate=0.01, n_epochs=20):
        self.n_factors = n_factors
        self.lr = learning_rate
        self.n_epochs = n_epochs
    
    def fit(self, ratings):
        """训练模型
        ratings: 用户-物品评分矩阵
        """
        n_users, n_items = ratings.shape
        
        # 初始化用户和物品隐向量
        self.user_factors = np.random.randn(n_users, self.n_factors) * 0.1
        self.item_factors = np.random.randn(n_items, self.n_factors) * 0.1
        
        # 找到有评分的位置
        rated_positions = np.where(ratings > 0)
        
        for epoch in range(self.n_epochs):
            for i, j in zip(*rated_positions):
                # 预测评分
                pred = np.dot(self.user_factors[i], self.item_factors[j])
                error = ratings[i, j] - pred
                
                # 更新隐向量
                self.user_factors[i] += self.lr * error * self.item_factors[j]
                self.item_factors[j] += self.lr * error * self.user_factors[i]
            
            if epoch % 5 == 0:
                mse = np.mean([(ratings[i, j] - np.dot(self.user_factors[i], self.item_factors[j]))**2 
                               for i, j in zip(*rated_positions)])
                print(f"Epoch {epoch}, MSE: {mse:.4f}")
    
    def predict(self, user_id, item_id):
        """预测评分"""
        return np.dot(self.user_factors[user_id], self.item_factors[item_id])
    
    def recommend(self, user_id, n=5):
        """推荐Top-N物品"""
        scores = np.dot(self.user_factors[user_id], self.item_factors.T)
        top_items = np.argsort(scores)[::-1][:n]
        return top_items, scores[top_items]

# 示例
ratings = np.array([
    [5, 3, 0, 1],
    [4, 0, 0, 1],
    [1, 1, 0, 5],
    [1, 0, 0, 4],
    [0, 1, 5, 4],
])

cf = CollaborativeFiltering(n_factors=2)
cf.fit(ratings)

user_id = 0
items, scores = cf.recommend(user_id, n=3)
print(f"为用户{user_id}推荐的物品: {items}")
print(f"预测评分: {scores}")
```

---

## 📚 学习建议

### 实践项目

1. **聊天机器人**
   - 规则引擎实现
   - 意图识别（NLU）
   - 对话管理
   - 接入LLM API

2. **推荐系统**
   - 协同过滤
   - 基于内容推荐
   - 混合推荐
   - 实时推荐

3. **图像分类**
   - CNN实现
   - 迁移学习（ResNet, VGG）
   - 目标检测（YOLO）
   - 图像分割

4. **自然语言处理**
   - 文本分类
   - 命名实体识别
   - 机器翻译
   - 文本生成

### 推荐资源

📖 **经典教材：**
- 《人工智能：一种现代方法》（AIMA）- Stuart Russell
- 《机器学习》（西瓜书）- 周志华
- 《深度学习》（花书）- Ian Goodfellow
- 《统计学习方法》- 李航
- 《强化学习导论》- Sutton & Barto

💻 **在线课程：**
- **Andrew Ng《机器学习》**（Coursera）
- **Stanford CS229**（Machine Learning）
- **MIT 6.S191**（Deep Learning）
- **Berkeley CS188**（AI）

🎥 **视频资源：**
- 李宏毅《机器学习》
- 李沐《动手学深度学习》
- 吴恩达《深度学习专项课程》

### 学习路线

**第1阶段：数学基础（2周）**
- ✅ 线性代数（矩阵运算）
- ✅ 概率论（贝叶斯）
- ✅ 微积分（梯度下降）

**第2阶段：机器学习（4周）**
- ✅ 监督学习（回归、分类）
- ✅ 无监督学习（聚类、降维）
- ✅ 特征工程
- ✅ 模型评估

**第3阶段：深度学习（6周）**
- ✅ 神经网络基础
- ✅ CNN（图像）
- ✅ RNN/LSTM（序列）
- ✅ Transformer（注意力）

**第4阶段：强化学习（3周）**
- ✅ Q-Learning
- ✅ Policy Gradient
- ✅ Actor-Critic
- ✅ DQN

**第5阶段：应用实践（持续）**
- ✅ 实战项目
- ✅ Kaggle竞赛
- ✅ 论文阅读
- ✅ 开源贡献

### 常用框架

**深度学习框架**
- **PyTorch** - 灵活易用，科研首选
- **TensorFlow/Keras** - 工业部署
- **JAX** - 高性能计算
- **MXNet** - 分布式训练

**机器学习库**
- **scikit-learn** - 经典ML算法
- **XGBoost/LightGBM** - 梯度提升
- **Pandas** - 数据处理
- **NumPy** - 数值计算

**NLP工具**
- **HuggingFace Transformers** - 预训练模型
- **spaCy** - NLP流水线
- **NLTK** - 自然语言工具包
- **Jieba** - 中文分词

**计算机视觉**
- **OpenCV** - 图像处理
- **PIL/Pillow** - 图像操作
- **Detectron2** - 目标检测
- **MMDetection** - 检测工具箱

### 面试高频题

**机器学习基础**
1. 监督学习和无监督学习的区别？
2. 过拟合和欠拟合如何解决？
3. 偏差-方差权衡是什么？
4. 交叉验证的作用？

**深度学习**
1. 反向传播算法的原理？
2. 为什么需要激活函数？
3. 梯度消失和梯度爆炸如何解决？
4. Batch Normalization的作用？

**优化算法**
1. SGD、Adam、RMSProp的区别？
2. 学习率衰减策略？
3. 正则化方法有哪些？

**模型架构**
1. CNN适用于什么任务？
2. RNN的长期依赖问题？
3. Transformer的优势是什么？
4. 注意力机制的原理？

### 常见错误

❌ **错误1**：忽视数据预处理

- ✅ 数据清洗很重要
- ✅ 特征缩放和归一化
- ✅ 处理缺失值和异常值

❌ **错误2**：盲目调参

- ✅ 理解超参数含义
- ✅ 网格搜索或贝叶斯优化
- ✅ 记录实验结果

❌ **错误3**：不做数据划分

- ✅ 训练集/验证集/测试集
- ✅ 避免数据泄漏
- ✅ K折交叉验证

❌ **错误4**：过度追求复杂模型

- ✅ 简单模型优先
- ✅ 复杂度与性能权衡
- ✅ Occam's Razor

### 最佳实践

**数据处理**
- 数据可视化探索（EDA）
- 数据增强（图像/文本）
- 不平衡数据处理
- 特征选择和降维

**模型训练**
- 从小数据集开始
- 监控训练/验证损失
- Early Stopping防过拟合
- 保存最佳模型

**代码规范**
- 模块化代码组织
- 使用配置文件
- 实验版本控制（Git）
- 日志记录（TensorBoard）

**部署上线**
- 模型压缩和量化
- 推理优化（ONNX）
- API服务（Flask/FastAPI）
- 监控和A/B测试

---

> **记住**：AI是未来科技的核心驱动力！从基础算法到最新模型，持续学习是关键！🤖
> 
> **学习心得**：
> - 数学基础扎实很重要
> - 动手实践才能深入理解
> - 阅读经典论文开拓视野
> - 参与开源项目提升能力
> - 关注最新进展保持学习

---

**本章完**
