# 人工智能导论 - (一)搜索算法

学习AI搜索策略和路径规划。

---

## 1. 搜索算法

### 1.1 广度优先搜索（BFS）

广度优先搜索是一种无信息搜索算法，按层级顺序探索状态空间。

```python
from collections import deque

def bfs(graph, start, goal):
    """广度优先搜索"""
    queue = deque([(start, [start])])
    visited = {start}
    
    while queue:
        node, path = queue.popleft()
        
        if node == goal:
            return path
        
        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append((neighbor, path + [neighbor]))
    
    return None

# 示例
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}

path = bfs(graph, 'A', 'F')
print(f"路径: {path}")
```

**时间复杂度**: $O(|V| + |E|)$，其中 $V$ 是顶点数，$E$ 是边数

**空间复杂度**: $O(|V|)$

**特点**:
+ 保证找到最短路径（无权图）
+ 适合搜索深度较浅的问题
+ 需要大量内存存储队列

### 1.2 深度优先搜索（DFS）

深度优先搜索沿着单一路径深入探索，直到无路可走再回溯。

```python
def dfs(graph, start, goal, path=None, visited=None):
    """深度优先搜索（递归版本）"""
    if path is None:
        path = [start]
    if visited is None:
        visited = set()
    
    visited.add(start)
    
    if start == goal:
        return path
    
    for neighbor in graph.get(start, []):
        if neighbor not in visited:
            result = dfs(graph, neighbor, goal, path + [neighbor], visited)
            if result:
                return result
    
    return None

def dfs_iterative(graph, start, goal):
    """深度优先搜索（迭代版本）"""
    stack = [(start, [start])]
    visited = set()
    
    while stack:
        node, path = stack.pop()
        
        if node in visited:
            continue
        
        visited.add(node)
        
        if node == goal:
            return path
        
        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                stack.append((neighbor, path + [neighbor]))
    
    return None

# 示例
path_recursive = dfs(graph, 'A', 'F')
path_iterative = dfs_iterative(graph, 'A', 'F')

print(f"递归DFS路径: {path_recursive}")
print(f"迭代DFS路径: {path_iterative}")
```

**对比BFS vs DFS**:

| 特性 | BFS | DFS |
|-----|-----|-----|
| 数据结构 | 队列（FIFO） | 栈（LIFO） |
| 最短路径 | 保证找到 | 不保证 |
| 空间复杂度 | $O(b^d)$ | $O(bd)$ |
| 适用场景 | 最短路径、层级遍历 | 拓扑排序、环检测 |

其中 $b$ 是分支因子，$d$ 是深度。

### 1.3 A*搜索算法

A*是一种启发式搜索算法，结合了实际代价和启发式估计。

```python
import heapq

def a_star(graph, start, goal, heuristic):
    """A*搜索算法
    
    f(n) = g(n) + h(n)
    g(n): 从起点到n的实际代价
    h(n): 从n到目标的启发式估计
    """
    open_set = [(0, start, [start])]
    closed_set = set()
    g_score = {start: 0}
    
    while open_set:
        f_score, current, path = heapq.heappop(open_set)
        
        if current == goal:
            return path, g_score[current]
        
        if current in closed_set:
            continue
        
        closed_set.add(current)
        
        for neighbor, cost in graph.get(current, []):
            tentative_g = g_score[current] + cost
            
            if neighbor not in g_score or tentative_g < g_score[neighbor]:
                g_score[neighbor] = tentative_g
                h_score = heuristic(neighbor, goal)
                f_score = tentative_g + h_score
                heapq.heappush(open_set, (f_score, neighbor, path + [neighbor]))
    
    return None, float('inf')

# 启发式函数
def manhattan_distance(a, b):
    """曼哈顿距离（L1距离）"""
    return abs(a[0] - b[0]) + abs(a[1] - b[1])

def euclidean_distance(a, b):
    """欧几里得距离（L2距离）"""
    return ((a[0] - b[0])**2 + (a[1] - b[1])**2)**0.5

def chebyshev_distance(a, b):
    """切比雪夫距离（L∞距离）"""
    return max(abs(a[0] - b[0]), abs(a[1] - b[1]))

# 示例：网格地图寻路
class GridMap:
    """网格地图A*寻路"""
    
    def __init__(self, width, height, obstacles=None):
        self.width = width
        self.height = height
        self.obstacles = obstacles or set()
    
    def neighbors(self, pos):
        """获取相邻节点"""
        x, y = pos
        neighbors = []
        
        # 四方向移动
        for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
            nx, ny = x + dx, y + dy
            if (0 <= nx < self.width and 
                0 <= ny < self.height and 
                (nx, ny) not in self.obstacles):
                neighbors.append(((nx, ny), 1))  # 代价为1
        
        return neighbors
    
    def a_star_search(self, start, goal):
        """执行A*搜索"""
        open_set = [(0, start, [start])]
        closed_set = set()
        g_score = {start: 0}
        
        while open_set:
            f_score, current, path = heapq.heappop(open_set)
            
            if current == goal:
                return path, g_score[current]
            
            if current in closed_set:
                continue
            
            closed_set.add(current)
            
            for neighbor, cost in self.neighbors(current):
                tentative_g = g_score[current] + cost
                
                if neighbor not in g_score or tentative_g < g_score[neighbor]:
                    g_score[neighbor] = tentative_g
                    h_score = manhattan_distance(neighbor, goal)
                    f_score = tentative_g + h_score
                    heapq.heappush(open_set, (f_score, neighbor, path + [neighbor]))
        
        return None, float('inf')

# 使用示例
grid = GridMap(10, 10, obstacles={(3, 3), (3, 4), (3, 5), (4, 5)})
path, cost = grid.a_star_search((0, 0), (9, 9))

if path:
    print(f"找到路径，长度: {len(path)}, 代价: {cost}")
    print(f"路径: {path[:5]}...{path[-3:]}")
else:
    print("未找到路径")
```

**A*算法的关键性质**:

1. **可采纳性（Admissible）**: 如果 $h(n)$ 不会高估实际代价，A*保证找到最优解
2. **一致性（Consistent）**: 如果 $h(n) \leq c(n, n') + h(n')$，A*更高效

### 1.4 启发式搜索对比

```python
class HeuristicComparison:
    """启发式函数对比"""
    
    @staticmethod
    def compare_heuristics():
        """对比不同启发式函数的性能"""
        
        heuristics = {
            '曼哈顿距离': lambda a, b: abs(a[0] - b[0]) + abs(a[1] - b[1]),
            '欧几里得距离': lambda a, b: ((a[0] - b[0])**2 + (a[1] - b[1])**2)**0.5,
            '切比雪夫距离': lambda a, b: max(abs(a[0] - b[0]), abs(a[1] - b[1])),
            '零启发式': lambda a, b: 0  # 退化为Dijkstra算法
        }
        
        print("启发式函数对比")
        print("="*70)
        print(f"{'启发式':<15} {'可采纳性':<12} {'适用场景':<30}")
        print("-"*70)
        
        scenarios = [
            ('曼哈顿距离', '可采纳', '网格地图（四方向移动）'),
            ('欧几里得距离', '可采纳', '连续空间、任意方向移动'),
            ('切比雪夫距离', '可采纳', '网格地图（八方向移动）'),
            ('零启发式', '可采纳', '退化为Dijkstra，保证最优解')
        ]
        
        for h_name, admissible, scenario in scenarios:
            print(f"{h_name:<15} {admissible:<12} {scenario:<30}")
        
        print("\n" + "="*70)
        print("性能分析")
        print("="*70)
        
        performance = [
            ('曼哈顿距离', '快', '中', '最优（四方向）'),
            ('欧几里得距离', '较快', '高', '最优（连续空间）'),
            ('切比雪夫距离', '快', '中', '最优（八方向）'),
            ('零启发式', '慢', '低', '最优（任意图）')
        ]
        
        print(f"{'启发式':<15} {'速度':<8} {'内存占用':<12} {'解质量':<20}")
        print("-"*70)
        
        for h_name, speed, memory, quality in performance:
            print(f"{h_name:<15} {speed:<8} {memory:<12} {quality:<20}")

HeuristicComparison.compare_heuristics()
```

### 1.5 对抗搜索（博弈树）

对抗搜索用于双人零和博弈，如井字棋、国际象棋。

#### 1.5.1 Minimax算法

```python
class TicTacToe:
    """井字棋游戏"""
    
    def __init__(self):
        self.board = [[' ' for _ in range(3)] for _ in range(3)]
    
    def available_moves(self):
        """获取可用位置"""
        moves = []
        for i in range(3):
            for j in range(3):
                if self.board[i][j] == ' ':
                    moves.append((i, j))
        return moves
    
    def make_move(self, move, player):
        """执行移动"""
        i, j = move
        self.board[i][j] = player
    
    def undo_move(self, move):
        """撤销移动"""
        i, j = move
        self.board[i][j] = ' '
    
    def check_winner(self):
        """检查胜者"""
        # 检查行
        for row in self.board:
            if row[0] == row[1] == row[2] != ' ':
                return row[0]
        
        # 检查列
        for j in range(3):
            if self.board[0][j] == self.board[1][j] == self.board[2][j] != ' ':
                return self.board[0][j]
        
        # 检查对角线
        if self.board[0][0] == self.board[1][1] == self.board[2][2] != ' ':
            return self.board[0][0]
        if self.board[0][2] == self.board[1][1] == self.board[2][0] != ' ':
            return self.board[0][2]
        
        # 平局
        if not self.available_moves():
            return 'Draw'
        
        return None
    
    def minimax(self, is_maximizing, alpha=float('-inf'), beta=float('inf')):
        """Minimax算法（含Alpha-Beta剪枝）
        
        is_maximizing: True表示最大化玩家（X），False表示最小化玩家（O）
        """
        winner = self.check_winner()
        
        # 终止条件
        if winner == 'X':
            return 1
        elif winner == 'O':
            return -1
        elif winner == 'Draw':
            return 0
        
        if is_maximizing:
            max_eval = float('-inf')
            for move in self.available_moves():
                self.make_move(move, 'X')
                eval = self.minimax(False, alpha, beta)
                self.undo_move(move)
                max_eval = max(max_eval, eval)
                alpha = max(alpha, eval)
                if beta <= alpha:
                    break  # Beta剪枝
            return max_eval
        else:
            min_eval = float('inf')
            for move in self.available_moves():
                self.make_move(move, 'O')
                eval = self.minimax(True, alpha, beta)
                self.undo_move(move)
                min_eval = min(min_eval, eval)
                beta = min(beta, eval)
                if beta <= alpha:
                    break  # Alpha剪枝
            return min_eval
    
    def best_move(self):
        """找到最佳移动"""
        best_score = float('-inf')
        best_move = None
        
        for move in self.available_moves():
            self.make_move(move, 'X')
            score = self.minimax(False)
            self.undo_move(move)
            
            if score > best_score:
                best_score = score
                best_move = move
        
        return best_move
    
    def print_board(self):
        """打印棋盘"""
        for i, row in enumerate(self.board):
            print(' | '.join(row))
            if i < 2:
                print('-' * 9)

# 演示
game = TicTacToe()
game.board = [
    ['X', 'O', 'X'],
    [' ', 'X', ' '],
    ['O', ' ', ' ']
]

print("当前棋盘:")
game.print_board()

best = game.best_move()
print(f"\n最佳移动: {best}")
print(f"评估分数: {game.minimax(True)}")
```

#### 1.5.2 Alpha-Beta剪枝优化

```python
class AlphaBetaPruning:
    """Alpha-Beta剪枝演示"""
    
    @staticmethod
    def explain_pruning():
        """解释Alpha-Beta剪枝原理"""
        
        print("Alpha-Beta剪枝原理")
        print("="*70)
        
        print("\nMinimax树搜索示例:")
        print("""
                  MAX
                /  |  \\
               3   ?   2
              / \\  |  / \\
             3  5  ?  2  9
        """)
        
        print("\n第1步: 搜索左子树，得到值3")
        print("第2步: 搜索中间子树")
        print("  - 发现第一个子节点值为1")
        print("  - Alpha=3, Beta=1")
        print("  - 因为Beta(1) <= Alpha(3)，剪枝！")
        print("  - 无需搜索中间子树的其余节点\n")
        
        print("剪枝效果:")
        print("  - Minimax: 访问O(b^d)个节点")
        print("  - Alpha-Beta: 访问O(b^(d/2))个节点（理想情况）")
        print("  - 其中b是分支因子，d是深度\n")
        
        print("剪枝条件:")
        print("  - Alpha剪枝: 当前节点的值 >= Beta，剪枝")
        print("  - Beta剪枝: 当前节点的值 <= Alpha，剪枝")

AlphaBetaPruning.explain_pruning()
```

### 1.6 搜索算法总结

```python
def search_algorithms_comparison():
    """搜索算法全面对比"""
    
    print("搜索算法对比表")
    print("="*100)
    
    algorithms = [
        {
            'name': 'BFS',
            'completeness': '完备',
            'optimality': '最优（无权图）',
            'time': 'O(b^d)',
            'space': 'O(b^d)',
            'use_case': '最短路径、层级遍历'
        },
        {
            'name': 'DFS',
            'completeness': '不完备（无限深度）',
            'optimality': '不最优',
            'time': 'O(b^m)',
            'space': 'O(bm)',
            'use_case': '拓扑排序、环检测'
        },
        {
            'name': 'Dijkstra',
            'completeness': '完备',
            'optimality': '最优',
            'time': 'O((V+E)logV)',
            'space': 'O(V)',
            'use_case': '单源最短路径'
        },
        {
            'name': 'A*',
            'completeness': '完备',
            'optimality': '最优（可采纳启发式）',
            'time': 'O(b^d)',
            'space': 'O(b^d)',
            'use_case': '路径规划、游戏AI'
        },
        {
            'name': 'Minimax',
            'completeness': '完备',
            'optimality': '最优（双方理性）',
            'time': 'O(b^m)',
            'space': 'O(bm)',
            'use_case': '双人博弈'
        },
        {
            'name': 'Alpha-Beta',
            'completeness': '完备',
            'optimality': '最优',
            'time': 'O(b^(m/2))',
            'space': 'O(bm)',
            'use_case': '高效博弈树搜索'
        }
    ]
    
    print(f"{'算法':<12} {'完备性':<18} {'最优性':<25} {'时间复杂度':<18} {'空间复杂度':<12}")
    print("-"*100)
    
    for algo in algorithms:
        print(f"{algo['name']:<12} {algo['completeness']:<18} {algo['optimality']:<25} "
              f"{algo['time']:<18} {algo['space']:<12}")
    
    print("\n" + "="*100)
    print("应用场景")
    print("="*100)
    
    for algo in algorithms:
        print(f"\n【{algo['name']}】")
        print(f"  适用: {algo['use_case']}")

search_algorithms_comparison()
```

**运行结果示例**:

```plain
搜索算法对比表
====================================================================================================
算法          完备性              最优性                      时间复杂度          空间复杂度    
----------------------------------------------------------------------------------------------------
BFS          完备                最优（无权图）                O(b^d)            O(b^d)      
DFS          不完备（无限深度）     不最优                      O(b^m)            O(bm)       
Dijkstra     完备                最优                        O((V+E)logV)      O(V)        
A*           完备                最优（可采纳启发式）           O(b^d)            O(b^d)      
Minimax      完备                最优（双方理性）              O(b^m)            O(bm)       
Alpha-Beta   完备                最优                        O(b^(m/2))        O(bm)       

====================================================================================================
应用场景
====================================================================================================

【BFS】
  适用: 最短路径、层级遍历

【DFS】
  适用: 拓扑排序、环检测

【Dijkstra】
  适用: 单源最短路径

【A*】
  适用: 路径规划、游戏AI

【Minimax】
  适用: 双人博弈

【Alpha-Beta】
  适用: 高效博弈树搜索
```

### 1.7 实战：迷宫求解

```python
class MazeSolver:
    """迷宫求解器"""
    
    def __init__(self, maze):
        """
        maze: 二维数组，0表示通路，1表示墙壁
        """
        self.maze = maze
        self.rows = len(maze)
        self.cols = len(maze[0])
    
    def is_valid(self, x, y):
        """检查位置是否有效"""
        return (0 <= x < self.rows and 
                0 <= y < self.cols and 
                self.maze[x][y] == 0)
    
    def solve_bfs(self, start, end):
        """BFS求解迷宫"""
        from collections import deque
        
        queue = deque([(start, [start])])
        visited = {start}
        
        while queue:
            (x, y), path = queue.popleft()
            
            if (x, y) == end:
                return path
            
            for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
                nx, ny = x + dx, y + dy
                
                if self.is_valid(nx, ny) and (nx, ny) not in visited:
                    visited.add((nx, ny))
                    queue.append(((nx, ny), path + [(nx, ny)]))
        
        return None
    
    def solve_a_star(self, start, end):
        """A*求解迷宫"""
        import heapq
        
        def heuristic(pos):
            return abs(pos[0] - end[0]) + abs(pos[1] - end[1])
        
        open_set = [(0, start, [start])]
        closed_set = set()
        g_score = {start: 0}
        
        while open_set:
            _, current, path = heapq.heappop(open_set)
            
            if current == end:
                return path
            
            if current in closed_set:
                continue
            
            closed_set.add(current)
            x, y = current
            
            for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
                nx, ny = x + dx, y + dy
                neighbor = (nx, ny)
                
                if not self.is_valid(nx, ny):
                    continue
                
                tentative_g = g_score[current] + 1
                
                if neighbor not in g_score or tentative_g < g_score[neighbor]:
                    g_score[neighbor] = tentative_g
                    f_score = tentative_g + heuristic(neighbor)
                heapq.heappush(open_set, (f_score, neighbor, path + [neighbor]))
    
    return None

    def visualize_path(self, path):
        """可视化路径"""
        result = [row[:] for row in self.maze]
        
        for x, y in path:
            if result[x][y] == 0:
                result[x][y] = '*'
        
        for row in result:
            print(' '.join('█' if cell == 1 else ('*' if cell == '*' else ' ') for cell in row))

# 测试迷宫
maze = [
    [0, 1, 0, 0, 0],
    [0, 1, 0, 1, 0],
    [0, 0, 0, 1, 0],
    [1, 1, 0, 0, 0],
    [0, 0, 0, 1, 0]
]

solver = MazeSolver(maze)
start = (0, 0)
end = (4, 4)

print("BFS求解:")
path_bfs = solver.solve_bfs(start, end)
if path_bfs:
    print(f"路径长度: {len(path_bfs)}")
    solver.visualize_path(path_bfs)

print("\nA*求解:")
path_astar = solver.solve_a_star(start, end)
if path_astar:
    print(f"路径长度: {len(path_astar)}")
    solver.visualize_path(path_astar)
```

---

**本章完**
