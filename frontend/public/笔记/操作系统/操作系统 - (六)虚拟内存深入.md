# 操作系统 - (六)虚拟内存深入

掌握虚拟内存机制。

---

## 6. 虚拟内存深入

### 6.1 多级页表

```python
class MultiLevelPageTable:
    """
    二级页表实现
    减少页表占用空间
    """
    def __init__(self, page_size=4096, pte_per_page=1024):
        self.page_size = page_size
        self.pte_per_page = pte_per_page  # 每页页表项数
        self.page_directory = {}  # 页目录
    
    def translate(self, virtual_addr):
        """虚拟地址转物理地址"""
        # 拆分虚拟地址
        offset = virtual_addr % self.page_size
        page_num = virtual_addr // self.page_size
        
        pd_index = page_num // self.pte_per_page  # 页目录索引
        pt_index = page_num % self.pte_per_page   # 页表索引
        
        # 查找页目录
        if pd_index not in self.page_directory:
            raise Exception(f"页目录缺失: {pd_index}")
        
        page_table = self.page_directory[pd_index]
        
        # 查找页表
        if pt_index not in page_table:
            raise Exception(f"页表项缺失: {pt_index}")
        
        frame_num = page_table[pt_index]
        physical_addr = frame_num * self.page_size + offset
        
        return {
            '页目录索引': pd_index,
            '页表索引': pt_index,
            '偏移': offset,
            '帧号': frame_num,
            '物理地址': physical_addr
        }
    
    def map_page(self, page_num, frame_num):
        """建立映射"""
        pd_index = page_num // self.pte_per_page
        pt_index = page_num % self.pte_per_page
        
        if pd_index not in self.page_directory:
            self.page_directory[pd_index] = {}
        
        self.page_directory[pd_index][pt_index] = frame_num

# 示例
mlpt = MultiLevelPageTable()
mlpt.map_page(0, 10)
mlpt.map_page(1024, 20)

print(mlpt.translate(0))
print(mlpt.translate(1024 * 4096))
```

### 6.2 工作集模型

```python
class WorkingSetModel:
    """
    工作集页面置换
    """
    def __init__(self, window_size=5):
        self.window_size = window_size
        self.memory = set()
        self.access_history = []
        self.page_faults = 0
    
    def access(self, page, time):
        """访问页面"""
        self.access_history.append((page, time))
        
        # 计算工作集（窗口内访问的页面）
        working_set = set()
        for p, t in reversed(self.access_history):
            if time - t > self.window_size:
                break
            working_set.add(p)
        
        if page not in self.memory:
            self.page_faults += 1
            
            # 淘汰不在工作集的页面
            to_remove = self.memory - working_set
            if to_remove:
                victim = to_remove.pop()
                self.memory.remove(victim)
                print(f"时间{time}: 缺页{page}, 淘汰{victim}")
            else:
                print(f"时间{time}: 缺页{page}, 无需淘汰")
            
            self.memory.add(page)
        else:
            print(f"时间{time}: 命中{page}")
        
        print(f"  工作集: {working_set}, 内存: {self.memory}\n")

# 示例
ws = WorkingSetModel(window_size=3)
pages = [1, 2, 3, 4, 1, 2, 5, 1, 2]

for t, page in enumerate(pages):
    ws.access(page, t)
```

### 6.3 缺页异常处理

```python
class PageFaultHandler:
    """
    缺页异常处理流程
    """
    def __init__(self, memory_frames=4):
        self.memory = [None] * memory_frames
        self.page_table = {}
        self.disk = {}  # 模拟磁盘
        self.free_frames = list(range(memory_frames))
    
    def handle_page_fault(self, page_num):
        """处理缺页"""
        print(f"\n缺页中断: 页{page_num}")
        
        # 1. 查找页面位置
        if page_num not in self.disk:
            print("  错误：页面不存在")
            return False
        
        # 2. 选择空闲帧或替换页面
        if self.free_frames:
            frame = self.free_frames.pop(0)
            print(f"  分配空闲帧: {frame}")
        else:
            # LRU替换（简化：替换第一个）
            victim_page = None
            for p, f in self.page_table.items():
                if f is not None:
                    victim_page = p
                    frame = f
                    break
            
            print(f"  替换页面: {victim_page} (帧{frame})")
            
            # 如果脏页，写回磁盘
            if self.memory[frame] and self.memory[frame].get('dirty'):
                print(f"  写回脏页{victim_page}到磁盘")
            
            self.page_table[victim_page] = None
        
        # 3. 从磁盘加载页面到内存
        print(f"  从磁盘加载页{page_num}到帧{frame}")
        self.memory[frame] = {
            'page': page_num,
            'data': self.disk[page_num],
            'dirty': False
        }
        
        # 4. 更新页表
        self.page_table[page_num] = frame
        print(f"  更新页表: 页{page_num} → 帧{frame}")
        
        return True
    
    def access_page(self, page_num, write=False):
        """访问页面"""
        if page_num in self.page_table and self.page_table[page_num] is not None:
            frame = self.page_table[page_num]
            print(f"访问页{page_num}: 命中 (帧{frame})")
            if write:
                self.memory[frame]['dirty'] = True
        else:
            self.handle_page_fault(page_num)

# 示例
handler = PageFaultHandler(memory_frames=3)

# 初始化磁盘
for i in range(10):
    handler.disk[i] = f"Page{i}Data"

# 访问序列
handler.access_page(0)
handler.access_page(1)
handler.access_page(2, write=True)
handler.access_page(3)  # 触发替换
handler.access_page(0)  # 再次缺页
```

---

**本章完**
