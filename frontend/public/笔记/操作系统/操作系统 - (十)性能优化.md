# 操作系统 - (十)性能优化

掌握系统性能优化。

---

## 10. 性能优化

### 10.1 缓存策略

```python
class BufferCache:
    """
    缓冲区缓存（块设备）
    """
    def __init__(self, cache_size=10):
        self.cache = {}  # 块号 → 数据
        self.cache_size = cache_size
        self.lru_list = []
        self.stats = {'hits': 0, 'misses': 0}
    
    def read_block(self, block_num, disk):
        """读块"""
        if block_num in self.cache:
            # 缓存命中
            self.stats['hits'] += 1
            self._update_lru(block_num)
            print(f"缓存命中: 块{block_num}")
            return self.cache[block_num]
        else:
            # 缓存未命中
            self.stats['misses'] += 1
            print(f"缓存未命中: 块{block_num}, 从磁盘读取")
            
            # 从磁盘读取
            data = disk.read(block_num)
            
            # 加入缓存
            if len(self.cache) >= self.cache_size:
                victim = self.lru_list.pop(0)
                del self.cache[victim]
                print(f"  淘汰块{victim}")
            
            self.cache[block_num] = data
            self.lru_list.append(block_num)
            
            return data
    
    def write_block(self, block_num, data, disk):
        """写块（写回策略）"""
        # 更新缓存
        self.cache[block_num] = data
        self._update_lru(block_num)
        
        # 延迟写回（标记脏）
        print(f"写缓存: 块{block_num} (脏)")
    
    def flush(self, disk):
        """刷新脏块到磁盘"""
        print("刷新缓存到磁盘...")
        for block_num, data in self.cache.items():
            disk.write(block_num, data)
            print(f"  写回块{block_num}")
    
    def _update_lru(self, block_num):
        """更新LRU"""
        if block_num in self.lru_list:
            self.lru_list.remove(block_num)
        self.lru_list.append(block_num)
    
    def get_stats(self):
        """获取统计信息"""
        total = self.stats['hits'] + self.stats['misses']
        hit_rate = self.stats['hits'] / total * 100 if total > 0 else 0
        return {
            '命中': self.stats['hits'],
            '未命中': self.stats['misses'],
            '命中率': f"{hit_rate:.1f}%"
        }

# 模拟磁盘
class SimpleDisk:
    def __init__(self):
        self.blocks = {i: f"Block{i}Data" for i in range(100)}
    
    def read(self, block_num):
        return self.blocks.get(block_num, "")
    
    def write(self, block_num, data):
        self.blocks[block_num] = data

# 示例
disk = SimpleDisk()
cache = BufferCache(cache_size=3)

for block in [1, 2, 3, 1, 4, 1, 2]:
    cache.read_block(block, disk)

print(cache.get_stats())
```

### 10.2 预读机制

```python
class ReadAheadCache:
    """
    预读缓存
    """
    def __init__(self, readahead_size=4):
        self.cache = {}
        self.readahead_size = readahead_size
    
    def read_sequential(self, start_block, count, disk):
        """顺序读取（带预读）"""
        data = []
        
        for block_num in range(start_block, start_block + count):
            if block_num in self.cache:
                print(f"块{block_num}: 缓存命中")
                data.append(self.cache[block_num])
            else:
                # 触发预读
                self._readahead(block_num, disk)
                data.append(self.cache[block_num])
        
        return data
    
    def _readahead(self, block_num, disk):
        """预读后续块"""
        print(f"预读: 块{block_num}到块{block_num + self.readahead_size - 1}")
        
        for i in range(self.readahead_size):
            b = block_num + i
            if b not in self.cache:
                self.cache[b] = disk.read(b)

# 示例
disk = SimpleDisk()
ra_cache = ReadAheadCache(readahead_size=3)

# 顺序读取
ra_cache.read_sequential(10, 8, disk)
```

---

**本章完**