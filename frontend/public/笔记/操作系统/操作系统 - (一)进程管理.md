# 操作系统 - (一)进程管理

理解进程调度与同步。

---

## 1. 进程管理

### 1.1 进程概念

**进程控制块（PCB）：**

```c
struct PCB {
    int pid;              // 进程ID
    int state;            // 进程状态
    int priority;         // 优先级
    void *pc;             // 程序计数器
    void *registers[32];  // 寄存器
    void *mem_limits[2];  // 内存界限
    struct PCB *parent;   // 父进程
    struct PCB *children; // 子进程链表
};
```

**进程状态转换：**

```
新建 → 就绪 ⇄ 运行 → 终止
         ↕
       阻塞
```

### 1.2 进程调度算法

#### 先来先服务（FCFS）

```python
def fcfs_scheduling(processes):
    """
    先来先服务调度
    processes: [(pid, arrival_time, burst_time), ...]
    """
    processes.sort(key=lambda x: x[1])  # 按到达时间排序
    
    current_time = 0
    waiting_times = []
    turnaround_times = []
    
    for pid, arrival, burst in processes:
        if current_time < arrival:
            current_time = arrival
        
        waiting_time = current_time - arrival
        turnaround_time = waiting_time + burst
        
        waiting_times.append(waiting_time)
        turnaround_times.append(turnaround_time)
        
        current_time += burst
        
        print(f"P{pid}: 等待时间={waiting_time}, 周转时间={turnaround_time}")
    
    print(f"平均等待时间: {sum(waiting_times) / len(waiting_times):.2f}")
    print(f"平均周转时间: {sum(turnaround_times) / len(turnaround_times):.2f}")

# 示例
processes = [
    (1, 0, 24),   # P1: 到达0, 执行24
    (2, 1, 3),    # P2: 到达1, 执行3
    (3, 2, 3)     # P3: 到达2, 执行3
]

fcfs_scheduling(processes)
```

#### 最短作业优先（SJF）

```python
def sjf_scheduling(processes):
    """
    最短作业优先（非抢占）
    """
    processes.sort(key=lambda x: (x[1], x[2]))  # 到达时间, 执行时间
    
    ready_queue = []
    current_time = 0
    completed = []
    
    while len(completed) < len(processes):
        # 添加到达的进程到就绪队列
        for p in processes:
            if p not in completed and p not in ready_queue and p[1] <= current_time:
                ready_queue.append(p)
        
        if not ready_queue:
            current_time += 1
            continue
        
        # 选择最短作业
        ready_queue.sort(key=lambda x: x[2])
        pid, arrival, burst = ready_queue.pop(0)
        
        waiting_time = current_time - arrival
        current_time += burst
        
        completed.append((pid, arrival, burst))
        print(f"P{pid}: 开始={current_time-burst}, 等待={waiting_time}")

# 示例
processes = [(1, 0, 6), (2, 2, 8), (3, 4, 7), (4, 5, 3)]
sjf_scheduling(processes)
```

#### 时间片轮转（RR）

```python
from collections import deque

def round_robin(processes, quantum=4):
    """
    时间片轮转
    quantum: 时间片大小
    """
    queue = deque(processes)
    current_time = 0
    
    while queue:
        pid, arrival, remaining = queue.popleft()
        
        if current_time < arrival:
            current_time = arrival
        
        # 执行一个时间片
        exec_time = min(quantum, remaining)
        current_time += exec_time
        remaining -= exec_time
        
        print(f"时间{current_time-exec_time}-{current_time}: P{pid}")
        
        # 如果未完成，重新入队
        if remaining > 0:
            queue.append((pid, current_time, remaining))

# 示例
processes = [(1, 0, 24), (2, 0, 3), (3, 0, 3)]
round_robin(processes, quantum=4)
```

### 1.3 进程同步

#### 生产者-消费者问题

```python
import threading
import time
from queue import Queue

class ProducerConsumer:
    def __init__(self, buffer_size=5):
        self.buffer = Queue(maxsize=buffer_size)
        self.mutex = threading.Lock()
        self.not_empty = threading.Semaphore(0)
        self.not_full = threading.Semaphore(buffer_size)
    
    def producer(self, id):
        for i in range(5):
            item = f"P{id}-Item{i}"
            
            self.not_full.acquire()  # 等待空位
            
            with self.mutex:
                self.buffer.put(item)
                print(f"生产者{id}生产: {item}, 缓冲区大小: {self.buffer.qsize()}")
            
            self.not_empty.release()  # 通知非空
            time.sleep(0.1)
    
    def consumer(self, id):
        for _ in range(5):
            self.not_empty.acquire()  # 等待有数据
            
            with self.mutex:
                item = self.buffer.get()
                print(f"消费者{id}消费: {item}, 缓冲区大小: {self.buffer.qsize()}")
            
            self.not_full.release()  # 通知有空位
            time.sleep(0.15)
    
    def run(self):
        producers = [threading.Thread(target=self.producer, args=(i,)) for i in range(2)]
        consumers = [threading.Thread(target=self.consumer, args=(i,)) for i in range(2)]
        
        for t in producers + consumers:
            t.start()
        
        for t in producers + consumers:
            t.join()

pc = ProducerConsumer()
pc.run()
```

#### 哲学家就餐问题

```python
import threading
import time

class DiningPhilosophers:
    def __init__(self, n=5):
        self.n = n
        self.forks = [threading.Lock() for _ in range(n)]
    
    def philosopher(self, id):
        left = id
        right = (id + 1) % self.n
        
        for _ in range(3):
            # 思考
            print(f"哲学家{id}在思考...")
            time.sleep(0.1)
            
            # 拿起叉子（避免死锁：编号小的先拿）
            first = min(left, right)
            second = max(left, right)
            
            self.forks[first].acquire()
            print(f"哲学家{id}拿起叉子{first}")
            
            self.forks[second].acquire()
            print(f"哲学家{id}拿起叉子{second}")
            
            # 吃饭
            print(f"哲学家{id}正在吃饭")
            time.sleep(0.2)
            
            # 放下叉子
            self.forks[first].release()
            self.forks[second].release()
            print(f"哲学家{id}放下叉子")
    
    def start(self):
        philosophers = [threading.Thread(target=self.philosopher, args=(i,)) 
                       for i in range(self.n)]
        
        for p in philosophers:
            p.start()
        
        for p in philosophers:
            p.join()

dp = DiningPhilosophers(5)
dp.start()
```

### 1.4 死锁

**必要条件：**

1. **互斥** - 资源独占
2. **占有并等待** - 持有资源并等待其他资源
3. **非抢占** - 资源不可强制剥夺
4. **循环等待** - 存在资源请求环

**银行家算法（死锁避免）：**

```python
class BankerAlgorithm:
    def __init__(self, available, max_need, allocation):
        self.available = available.copy()
        self.max_need = max_need
        self.allocation = allocation
        self.need = [[max_need[i][j] - allocation[i][j] 
                      for j in range(len(available))] 
                     for i in range(len(allocation))]
    
    def is_safe(self):
        """安全性检查"""
        work = self.available.copy()
        finish = [False] * len(self.allocation)
        safe_sequence = []
        
        while len(safe_sequence) < len(self.allocation):
            found = False
            
            for i in range(len(self.allocation)):
                if not finish[i] and all(self.need[i][j] <= work[j] 
                                         for j in range(len(work))):
                    # 进程i可以完成
                    for j in range(len(work)):
                        work[j] += self.allocation[i][j]
                    
                    finish[i] = True
                    safe_sequence.append(i)
                    found = True
                    break
            
            if not found:
                return False, []
        
        return True, safe_sequence
    
    def request_resources(self, process_id, request):
        """资源请求"""
        # 检查请求合法性
        if any(request[i] > self.need[process_id][i] for i in range(len(request))):
            return False, "请求超过需求"
        
        if any(request[i] > self.available[i] for i in range(len(request))):
            return False, "资源不足"
        
        # 试探分配
        for i in range(len(request)):
            self.available[i] -= request[i]
            self.allocation[process_id][i] += request[i]
            self.need[process_id][i] -= request[i]
        
        # 安全性检查
        safe, sequence = self.is_safe()
        
        if safe:
            return True, f"分配成功，安全序列: {sequence}"
        else:
            # 回滚
            for i in range(len(request)):
                self.available[i] += request[i]
                self.allocation[process_id][i] -= request[i]
                self.need[process_id][i] += request[i]
            return False, "不安全，拒绝分配"

# 示例
available = [3, 3, 2]  # ABC三种资源
max_need = [
    [7, 5, 3],  # P0
    [3, 2, 2],  # P1
    [9, 0, 2],  # P2
    [2, 2, 2],  # P3
    [4, 3, 3]   # P4
]
allocation = [
    [0, 1, 0],
    [2, 0, 0],
    [3, 0, 2],
    [2, 1, 1],
    [0, 0, 2]
]

banker = BankerAlgorithm(available, max_need, allocation)
safe, seq = banker.is_safe()
print(f"初始状态: {'安全' if safe else '不安全'}, 序列: {seq}")

success, msg = banker.request_resources(1, [1, 0, 2])
print(f"P1请求[1,0,2]: {msg}")
```

---

**本章完**
