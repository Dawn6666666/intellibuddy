# ç½‘ç»œå®‰å…¨ - (ä¸€)å¯†ç å­¦åŸºç¡€

å­¦ä¹ åŠ å¯†ç®—æ³•ä¸åº”ç”¨ã€‚

---

## 1. å¯†ç å­¦åŸºç¡€

### 1.1 å¯¹ç§°åŠ å¯†

```python
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
from Crypto.Util.Padding import pad, unpad
import base64

class AESCipher:
    def __init__(self, key=None):
        self.key = key or get_random_bytes(32)  # 256ä½å¯†é’¥
    
    def encrypt(self, plaintext):
        """AESåŠ å¯†"""
        cipher = AES.new(self.key, AES.MODE_CBC)
        
        # å¡«å……åˆ°16å­—èŠ‚çš„å€æ•°
        padded_text = pad(plaintext.encode(), AES.block_size)
        
        # åŠ å¯†
        ciphertext = cipher.encrypt(padded_text)
        
        # è¿”å›IV + å¯†æ–‡çš„Base64ç¼–ç 
        return base64.b64encode(cipher.iv + ciphertext).decode()
    
    def decrypt(self, encrypted_text):
        """AESè§£å¯†"""
        encrypted_data = base64.b64decode(encrypted_text)
        
        # æå–IVå’Œå¯†æ–‡
        iv = encrypted_data[:AES.block_size]
        ciphertext = encrypted_data[AES.block_size:]
        
        # è§£å¯†
        cipher = AES.new(self.key, AES.MODE_CBC, iv)
        padded_plaintext = cipher.decrypt(ciphertext)
        
        # å»é™¤å¡«å……
        plaintext = unpad(padded_plaintext, AES.block_size)
        
        return plaintext.decode()

# æµ‹è¯•AESåŠ å¯†
aes = AESCipher()
message = "è¿™æ˜¯ä¸€æ¡æœºå¯†ä¿¡æ¯"

encrypted = aes.encrypt(message)
print(f"ğŸ”’ åŠ å¯†: {encrypted}")

decrypted = aes.decrypt(encrypted)
print(f"ğŸ”“ è§£å¯†: {decrypted}")
```

### 1.2 éå¯¹ç§°åŠ å¯†ï¼ˆRSAï¼‰

```python
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP
from Crypto.Signature import pkcs1_15
from Crypto.Hash import SHA256
import base64

class RSACipher:
    def __init__(self, key_size=2048):
        self.key_pair = RSA.generate(key_size)
        self.public_key = self.key_pair.publickey()
    
    def get_public_key_pem(self):
        """è·å–å…¬é’¥PEMæ ¼å¼"""
        return self.public_key.export_key().decode()
    
    def get_private_key_pem(self):
        """è·å–ç§é’¥PEMæ ¼å¼"""
        return self.key_pair.export_key().decode()
    
    def encrypt(self, plaintext, public_key=None):
        """RSAåŠ å¯†ï¼ˆä½¿ç”¨å…¬é’¥ï¼‰"""
        key = public_key or self.public_key
        cipher = PKCS1_OAEP.new(key)
        
        # RSAåŠ å¯†æœ‰é•¿åº¦é™åˆ¶ï¼Œéœ€è¦åˆ†å—
        max_length = key.size_in_bytes() - 42  # OAEPå¡«å……å¼€é”€
        
        if len(plaintext.encode()) <= max_length:
            ciphertext = cipher.encrypt(plaintext.encode())
            return base64.b64encode(ciphertext).decode()
        else:
            raise ValueError("æ¶ˆæ¯å¤ªé•¿ï¼Œéœ€è¦åˆ†å—å¤„ç†")
    
    def decrypt(self, encrypted_text):
        """RSAè§£å¯†ï¼ˆä½¿ç”¨ç§é’¥ï¼‰"""
        cipher = PKCS1_OAEP.new(self.key_pair)
        ciphertext = base64.b64decode(encrypted_text)
        
        plaintext = cipher.decrypt(ciphertext)
        return plaintext.decode()
    
    def sign(self, message):
        """æ•°å­—ç­¾å"""
        hash_obj = SHA256.new(message.encode())
        signature = pkcs1_15.new(self.key_pair).sign(hash_obj)
        return base64.b64encode(signature).decode()
    
    def verify(self, message, signature, public_key=None):
        """éªŒè¯ç­¾å"""
        key = public_key or self.public_key
        hash_obj = SHA256.new(message.encode())
        signature_bytes = base64.b64decode(signature)
        
        try:
            pkcs1_15.new(key).verify(hash_obj, signature_bytes)
            return True
        except:
            return False

# æµ‹è¯•RSA
rsa = RSACipher()
message = "é‡è¦åˆåŒå†…å®¹"

# åŠ å¯†
encrypted = rsa.encrypt(message)
print(f"ğŸ”’ RSAåŠ å¯†: {encrypted[:50]}...")

# è§£å¯†
decrypted = rsa.decrypt(encrypted)
print(f"ğŸ”“ RSAè§£å¯†: {decrypted}")

# æ•°å­—ç­¾å
signature = rsa.sign(message)
print(f"âœï¸  æ•°å­—ç­¾å: {signature[:50]}...")

# éªŒè¯ç­¾å
is_valid = rsa.verify(message, signature)
print(f"âœ… ç­¾åéªŒè¯: {is_valid}")
```

### 1.3 å“ˆå¸Œå‡½æ•°ä¸æ¶ˆæ¯è®¤è¯

```python
import hashlib
import hmac
import secrets

class HashUtils:
    @staticmethod
    def sha256(data):
        """SHA-256å“ˆå¸Œ"""
        return hashlib.sha256(data.encode()).hexdigest()
    
    @staticmethod
    def md5(data):
        """MD5å“ˆå¸Œï¼ˆä¸å®‰å…¨ï¼Œä»…ç”¨äºæ¼”ç¤ºï¼‰"""
        return hashlib.md5(data.encode()).hexdigest()
    
    @staticmethod
    def hmac_sha256(key, message):
        """HMAC-SHA256æ¶ˆæ¯è®¤è¯ç """
        return hmac.new(key.encode(), message.encode(), hashlib.sha256).hexdigest()
    
    @staticmethod
    def generate_salt(length=32):
        """ç”Ÿæˆéšæœºç›å€¼"""
        return secrets.token_hex(length)
    
    @staticmethod
    def hash_password(password, salt=None):
        """å®‰å…¨çš„å¯†ç å“ˆå¸Œ"""
        if salt is None:
            salt = HashUtils.generate_salt()
        
        # ä½¿ç”¨PBKDF2è¿›è¡Œå¯†é’¥æ‹‰ä¼¸
        import hashlib
        key = hashlib.pbkdf2_hmac('sha256', 
                                  password.encode(), 
                                  salt.encode(), 
                                  100000)  # 10ä¸‡æ¬¡è¿­ä»£
        
        return salt + key.hex()
    
    @staticmethod
    def verify_password(password, hashed):
        """éªŒè¯å¯†ç """
        salt = hashed[:64]  # å‰64ä¸ªå­—ç¬¦æ˜¯ç›å€¼
        key = hashed[64:]
        
        new_key = hashlib.pbkdf2_hmac('sha256',
                                      password.encode(),
                                      salt.encode(),
                                      100000)
        
        return key == new_key.hex()

# æµ‹è¯•å“ˆå¸Œå’ŒHMAC
data = "æ•æ„Ÿæ•°æ®"
key = "secret_key"

print(f"ğŸ“Š åŸå§‹æ•°æ®: {data}")
print(f"ğŸ”¢ SHA-256: {HashUtils.sha256(data)}")
print(f"ğŸ” HMAC-SHA256: {HashUtils.hmac_sha256(key, data)}")

# æµ‹è¯•å¯†ç å“ˆå¸Œ
password = "my_secure_password"
hashed = HashUtils.hash_password(password)
print(f"\nğŸ”’ å¯†ç å“ˆå¸Œ: {hashed}")

is_valid = HashUtils.verify_password(password, hashed)
print(f"âœ… å¯†ç éªŒè¯: {is_valid}")

is_invalid = HashUtils.verify_password("wrong_password", hashed)
print(f"âŒ é”™è¯¯å¯†ç : {is_invalid}")
```

### 1.4 æ•°å­—è¯ä¹¦ä¸PKIä½“ç³»

**å…¬é’¥åŸºç¡€è®¾æ–½ï¼ˆPKIï¼‰** æ˜¯ä¸€ä¸ªç”¨äºåˆ›å»ºã€ç®¡ç†ã€åˆ†å‘ã€ä½¿ç”¨å’Œæ’¤é”€æ•°å­—è¯ä¹¦çš„æ¡†æ¶ã€‚

```python
from cryptography import x509
from cryptography.x509.oid import NameOID, ExtensionOID
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import serialization
import datetime

class CertificateAuthority:
    def __init__(self, ca_name="IntelliBuddy CA"):
        """åˆå§‹åŒ–è¯ä¹¦é¢å‘æœºæ„"""
        # ç”ŸæˆCAçš„ç§é’¥
        self.ca_private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=4096
        )
        
        # ç”ŸæˆCAçš„è‡ªç­¾åè¯ä¹¦
        self.ca_cert = self._generate_ca_certificate(ca_name)
    
    def _generate_ca_certificate(self, ca_name):
        """ç”ŸæˆCAè‡ªç­¾åè¯ä¹¦"""
        subject = issuer = x509.Name([
            x509.NameAttribute(NameOID.COUNTRY_NAME, "CN"),
            x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, "Beijing"),
            x509.NameAttribute(NameOID.LOCALITY_NAME, "Beijing"),
            x509.NameAttribute(NameOID.ORGANIZATION_NAME, ca_name),
            x509.NameAttribute(NameOID.COMMON_NAME, ca_name)
        ])
        
        cert = (
            x509.CertificateBuilder()
            .subject_name(subject)
            .issuer_name(issuer)
            .public_key(self.ca_private_key.public_key())
            .serial_number(x509.random_serial_number())
            .not_valid_before(datetime.datetime.utcnow())
            .not_valid_after(datetime.datetime.utcnow() + datetime.timedelta(days=3650))
            .add_extension(
                x509.BasicConstraints(ca=True, path_length=None),
                critical=True
            )
            .add_extension(
                x509.KeyUsage(
                    digital_signature=True,
                    key_cert_sign=True,
                    crl_sign=True,
                    key_encipherment=False,
                    content_commitment=False,
                    data_encipherment=False,
                    key_agreement=False,
                    encipher_only=False,
                    decipher_only=False
                ),
                critical=True
            )
            .sign(self.ca_private_key, hashes.SHA256())
        )
        
        return cert
    
    def issue_certificate(self, common_name, organization="User Org", 
                         validity_days=365):
        """é¢å‘ç”¨æˆ·è¯ä¹¦"""
        # ç”Ÿæˆç”¨æˆ·çš„å¯†é’¥å¯¹
        user_private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=2048
        )
        
        # åˆ›å»ºè¯ä¹¦ä¸»é¢˜
        subject = x509.Name([
            x509.NameAttribute(NameOID.COUNTRY_NAME, "CN"),
            x509.NameAttribute(NameOID.ORGANIZATION_NAME, organization),
            x509.NameAttribute(NameOID.COMMON_NAME, common_name)
        ])
        
        # ç”Ÿæˆè¯ä¹¦
        cert = (
            x509.CertificateBuilder()
            .subject_name(subject)
            .issuer_name(self.ca_cert.subject)
            .public_key(user_private_key.public_key())
            .serial_number(x509.random_serial_number())
            .not_valid_before(datetime.datetime.utcnow())
            .not_valid_after(
                datetime.datetime.utcnow() + datetime.timedelta(days=validity_days)
            )
            .add_extension(
                x509.BasicConstraints(ca=False, path_length=None),
                critical=True
            )
            .add_extension(
                x509.KeyUsage(
                    digital_signature=True,
                    key_encipherment=True,
                    content_commitment=False,
                    data_encipherment=False,
                    key_agreement=False,
                    key_cert_sign=False,
                    crl_sign=False,
                    encipher_only=False,
                    decipher_only=False
                ),
                critical=True
            )
            .sign(self.ca_private_key, hashes.SHA256())
        )
        
        return user_private_key, cert
    
    def verify_certificate(self, cert):
        """éªŒè¯è¯ä¹¦"""
        try:
            # éªŒè¯è¯ä¹¦ç­¾å
            self.ca_cert.public_key().verify(
                cert.signature,
                cert.tbs_certificate_bytes,
                cert.signature_algorithm_parameters
            )
            
            # æ£€æŸ¥æœ‰æ•ˆæœŸ
            now = datetime.datetime.utcnow()
            if now < cert.not_valid_before or now > cert.not_valid_after:
                return False, "è¯ä¹¦å·²è¿‡æœŸæˆ–å°šæœªç”Ÿæ•ˆ"
            
            return True, "è¯ä¹¦æœ‰æ•ˆ"
        except Exception as e:
            return False, f"è¯ä¹¦éªŒè¯å¤±è´¥: {str(e)}"
    
    def export_ca_cert_pem(self):
        """å¯¼å‡ºCAè¯ä¹¦ï¼ˆPEMæ ¼å¼ï¼‰"""
        return self.ca_cert.public_bytes(
            encoding=serialization.Encoding.PEM
        ).decode()
    
    def export_cert_pem(self, cert):
        """å¯¼å‡ºè¯ä¹¦ï¼ˆPEMæ ¼å¼ï¼‰"""
        return cert.public_bytes(
            encoding=serialization.Encoding.PEM
        ).decode()
    
    def export_private_key_pem(self, private_key, password=None):
        """å¯¼å‡ºç§é’¥ï¼ˆPEMæ ¼å¼ï¼‰"""
        encryption = serialization.NoEncryption()
        if password:
            encryption = serialization.BestAvailableEncryption(password.encode())
        
        return private_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.PKCS8,
            encryption_algorithm=encryption
        ).decode()

# æµ‹è¯•PKIä½“ç³»
print("ğŸ›ï¸  PKIä½“ç³»æ¼”ç¤º:")
ca = CertificateAuthority("IntelliBuddy Root CA")

# å¯¼å‡ºCAè¯ä¹¦
ca_cert_pem = ca.export_ca_cert_pem()
print(f"\nğŸ“œ CAè¯ä¹¦:\n{ca_cert_pem[:200]}...")

# ä¸ºç”¨æˆ·é¢å‘è¯ä¹¦
user_key, user_cert = ca.issue_certificate("user@example.com", "Example Corp")
print(f"\nâœ… ä¸ºç”¨æˆ·é¢å‘è¯ä¹¦")
print(f"è¯ä¹¦åºåˆ—å·: {user_cert.serial_number}")
print(f"è¯ä¹¦ä¸»é¢˜: {user_cert.subject.rfc4514_string()}")
print(f"æœ‰æ•ˆæœŸ: {user_cert.not_valid_before} è‡³ {user_cert.not_valid_after}")

# éªŒè¯è¯ä¹¦
is_valid, message = ca.verify_certificate(user_cert)
print(f"\nğŸ” è¯ä¹¦éªŒè¯: {is_valid} - {message}")

# å¯¼å‡ºç”¨æˆ·è¯ä¹¦å’Œç§é’¥
user_cert_pem = ca.export_cert_pem(user_cert)
user_key_pem = ca.export_private_key_pem(user_key)
print(f"\nğŸ“„ ç”¨æˆ·è¯ä¹¦é•¿åº¦: {len(user_cert_pem)} å­—èŠ‚")
print(f"ğŸ”‘ ç”¨æˆ·ç§é’¥é•¿åº¦: {len(user_key_pem)} å­—èŠ‚")
```

### 1.5 å¯†é’¥äº¤æ¢åè®®ï¼ˆDiffie-Hellmanï¼‰

**Diffie-Hellmanå¯†é’¥äº¤æ¢**å…è®¸åŒæ–¹åœ¨ä¸å®‰å…¨çš„ä¿¡é“ä¸Šåå•†å‡ºå…±äº«å¯†é’¥ã€‚

```python
from cryptography.hazmat.primitives.asymmetric import dh
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.kdf.hkdf import HKDF
import hashlib

class DHKeyExchange:
    def __init__(self):
        # ç”ŸæˆDHå‚æ•°ï¼ˆå®é™…åº”ç”¨ä¸­åº”è¯¥ä½¿ç”¨æ ‡å‡†å‚æ•°ï¼‰
        self.parameters = dh.generate_parameters(
            generator=2,
            key_size=2048
        )
    
    def generate_keypair(self):
        """ç”Ÿæˆå¯†é’¥å¯¹"""
        private_key = self.parameters.generate_private_key()
        public_key = private_key.public_key()
        return private_key, public_key
    
    def compute_shared_key(self, my_private_key, peer_public_key):
        """è®¡ç®—å…±äº«å¯†é’¥"""
        shared_key = my_private_key.exchange(peer_public_key)
        
        # ä½¿ç”¨HKDFæ´¾ç”Ÿå¯†é’¥
        derived_key = HKDF(
            algorithm=hashes.SHA256(),
            length=32,
            salt=None,
            info=b'handshake data'
        ).derive(shared_key)
        
        return derived_key
    
    def serialize_public_key(self, public_key):
        """åºåˆ—åŒ–å…¬é’¥"""
        return public_key.public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo
        )
    
    def deserialize_public_key(self, public_key_bytes):
        """ååºåˆ—åŒ–å…¬é’¥"""
        return serialization.load_pem_public_key(public_key_bytes)

# æ¨¡æ‹ŸAliceå’ŒBobçš„å¯†é’¥äº¤æ¢
print("ğŸ” Diffie-Hellmanå¯†é’¥äº¤æ¢æ¼”ç¤º:")

dh_exchange = DHKeyExchange()

# Aliceç”Ÿæˆå¯†é’¥å¯¹
alice_private, alice_public = dh_exchange.generate_keypair()
print("\nğŸ‘© Aliceç”Ÿæˆäº†å¯†é’¥å¯¹")

# Bobç”Ÿæˆå¯†é’¥å¯¹
bob_private, bob_public = dh_exchange.generate_keypair()
print("ğŸ‘¨ Bobç”Ÿæˆäº†å¯†é’¥å¯¹")

# Aliceè®¡ç®—å…±äº«å¯†é’¥ï¼ˆä½¿ç”¨Bobçš„å…¬é’¥ï¼‰
alice_shared_key = dh_exchange.compute_shared_key(alice_private, bob_public)
print(f"\nğŸ‘© Aliceè®¡ç®—çš„å…±äº«å¯†é’¥: {alice_shared_key.hex()[:32]}...")

# Bobè®¡ç®—å…±äº«å¯†é’¥ï¼ˆä½¿ç”¨Aliceçš„å…¬é’¥ï¼‰
bob_shared_key = dh_exchange.compute_shared_key(bob_private, alice_public)
print(f"ğŸ‘¨ Bobè®¡ç®—çš„å…±äº«å¯†é’¥: {bob_shared_key.hex()[:32]}...")

# éªŒè¯åŒæ–¹å¯†é’¥ç›¸åŒ
if alice_shared_key == bob_shared_key:
    print("\nâœ… å¯†é’¥äº¤æ¢æˆåŠŸï¼åŒæ–¹å…±äº«å¯†é’¥ç›¸åŒ")
else:
    print("\nâŒ å¯†é’¥äº¤æ¢å¤±è´¥ï¼")
```

### 1.6 æ¶ˆæ¯è®¤è¯ç ï¼ˆMACï¼‰ä¸æ•°å­—ç­¾åå¯¹æ¯”

```python
import hmac
import hashlib
from Crypto.PublicKey import RSA
from Crypto.Signature import pkcs1_15
from Crypto.Hash import SHA256

class SecurityComparison:
    """MAC vs æ•°å­—ç­¾åå¯¹æ¯”"""
    
    def __init__(self):
        # MACå¯†é’¥ï¼ˆå¯¹ç§°ï¼‰
        self.mac_key = b"shared_secret_key_12345"
        
        # RSAå¯†é’¥å¯¹ï¼ˆéå¯¹ç§°ï¼‰
        self.rsa_key = RSA.generate(2048)
        self.rsa_public = self.rsa_key.publickey()
    
    def generate_mac(self, message):
        """ç”Ÿæˆæ¶ˆæ¯è®¤è¯ç ï¼ˆHMACï¼‰"""
        mac = hmac.new(
            self.mac_key,
            message.encode(),
            hashlib.sha256
        ).hexdigest()
        return mac
    
    def verify_mac(self, message, mac):
        """éªŒè¯MAC"""
        expected_mac = self.generate_mac(message)
        return hmac.compare_digest(mac, expected_mac)
    
    def generate_signature(self, message):
        """ç”Ÿæˆæ•°å­—ç­¾å"""
        hash_obj = SHA256.new(message.encode())
        signature = pkcs1_15.new(self.rsa_key).sign(hash_obj)
        return signature.hex()
    
    def verify_signature(self, message, signature):
        """éªŒè¯æ•°å­—ç­¾å"""
        hash_obj = SHA256.new(message.encode())
        signature_bytes = bytes.fromhex(signature)
        
        try:
            pkcs1_15.new(self.rsa_public).verify(hash_obj, signature_bytes)
            return True
        except:
            return False

# å¯¹æ¯”æ¼”ç¤º
print("ğŸ“Š MAC vs æ•°å­—ç­¾åå¯¹æ¯”:\n")

sec = SecurityComparison()
message = "é‡è¦çš„ä¸šåŠ¡æ•°æ®"

print("=" * 60)
print("1ï¸âƒ£  æ¶ˆæ¯è®¤è¯ç ï¼ˆMAC/HMACï¼‰")
print("=" * 60)
print("ç‰¹ç‚¹ï¼š")
print("  â€¢ ä½¿ç”¨å¯¹ç§°å¯†é’¥ï¼ˆåŒæ–¹å…±äº«åŒä¸€å¯†é’¥ï¼‰")
print("  â€¢ é€Ÿåº¦å¿«")
print("  â€¢ å¯ä»¥è®¤è¯æ¶ˆæ¯å®Œæ•´æ€§")
print("  â€¢ ä¸æä¾›ä¸å¯å¦è®¤æ€§")
print()

mac = sec.generate_mac(message)
print(f"æ¶ˆæ¯: {message}")
print(f"MAC: {mac}")
print(f"éªŒè¯ç»“æœ: {sec.verify_mac(message, mac)}")

print("\n" + "=" * 60)
print("2ï¸âƒ£  æ•°å­—ç­¾åï¼ˆDigital Signatureï¼‰")
print("=" * 60)
print("ç‰¹ç‚¹ï¼š")
print("  â€¢ ä½¿ç”¨éå¯¹ç§°å¯†é’¥ï¼ˆç§é’¥ç­¾åï¼Œå…¬é’¥éªŒè¯ï¼‰")
print("  â€¢ é€Ÿåº¦è¾ƒæ…¢")
print("  â€¢ æä¾›æ¶ˆæ¯å®Œæ•´æ€§å’Œèº«ä»½è®¤è¯")
print("  â€¢ æä¾›ä¸å¯å¦è®¤æ€§")
print()

signature = sec.generate_signature(message)
print(f"æ¶ˆæ¯: {message}")
print(f"ç­¾å: {signature[:64]}...")
print(f"éªŒè¯ç»“æœ: {sec.verify_signature(message, signature)}")

print("\n" + "=" * 60)
print("ğŸ“Œ ä½¿ç”¨åœºæ™¯å¯¹æ¯”")
print("=" * 60)
print()
print("ä½¿ç”¨MACçš„åœºæ™¯ï¼š")
print("  â€¢ APIæ¥å£è®¤è¯ï¼ˆåŒæ–¹å…±äº«å¯†é’¥ï¼‰")
print("  â€¢ Cookieå®Œæ•´æ€§ä¿æŠ¤")
print("  â€¢ åˆ†å¸ƒå¼ç³»ç»Ÿå†…éƒ¨é€šä¿¡")
print()
print("ä½¿ç”¨æ•°å­—ç­¾åçš„åœºæ™¯ï¼š")
print("  â€¢ è½¯ä»¶åˆ†å‘ï¼ˆéªŒè¯å‘å¸ƒè€…ï¼‰")
print("  â€¢ ç”µå­åˆåŒï¼ˆæ³•å¾‹æ•ˆåŠ›ï¼‰")
print("  â€¢ åŒºå—é“¾äº¤æ˜“ï¼ˆä¸å¯ç¯¡æ”¹ï¼‰")
print("  â€¢ SSL/TLSè¯ä¹¦")
```

### 1.7 å¯†ç å­¦æ”»å‡»ä¸é˜²æŠ¤

```python
import string
import itertools
import time
import hashlib

class CryptographicAttacks:
    """å¯†ç å­¦æ”»å‡»æ¼”ç¤ºï¼ˆæ•™è‚²ç”¨é€”ï¼‰"""
    
    @staticmethod
    def brute_force_attack(target_hash, hash_type='md5', max_length=4):
        """æš´åŠ›ç ´è§£æ”»å‡»"""
        charset = string.ascii_lowercase + string.digits
        
        print(f"ğŸ”¨ æš´åŠ›ç ´è§£æ”»å‡»æ¼”ç¤º")
        print(f"ç›®æ ‡å“ˆå¸Œ: {target_hash}")
        print(f"å“ˆå¸Œç®—æ³•: {hash_type.upper()}")
        print(f"å­—ç¬¦é›†: {charset}")
        print(f"æœ€å¤§é•¿åº¦: {max_length}\n")
        
        start_time = time.time()
        attempts = 0
        
        for length in range(1, max_length + 1):
            for candidate in itertools.product(charset, repeat=length):
                attempts += 1
                password = ''.join(candidate)
                
                # è®¡ç®—å“ˆå¸Œ
                if hash_type == 'md5':
                    computed_hash = hashlib.md5(password.encode()).hexdigest()
                elif hash_type == 'sha256':
                    computed_hash = hashlib.sha256(password.encode()).hexdigest()
                else:
                    raise ValueError(f"ä¸æ”¯æŒçš„å“ˆå¸Œç±»å‹: {hash_type}")
                
                # æ£€æŸ¥æ˜¯å¦åŒ¹é…
                if computed_hash == target_hash:
                    elapsed = time.time() - start_time
                    print(f"âœ… ç ´è§£æˆåŠŸï¼")
                    print(f"å¯†ç : {password}")
                    print(f"å°è¯•æ¬¡æ•°: {attempts:,}")
                    print(f"è€—æ—¶: {elapsed:.2f}ç§’")
                    print(f"é€Ÿåº¦: {attempts/elapsed:,.0f} æ¬¡/ç§’")
                    return password
                
                # è¿›åº¦æ˜¾ç¤º
                if attempts % 10000 == 0:
                    print(f"å·²å°è¯• {attempts:,} æ¬¡...")
        
        print(f"âŒ ç ´è§£å¤±è´¥ï¼ˆå°è¯•äº† {attempts:,} æ¬¡ï¼‰")
        return None
    
    @staticmethod
    def dictionary_attack(target_hash, dictionary_file=None):
        """å­—å…¸æ”»å‡»"""
        # å¸¸è§å¯†ç å­—å…¸
        common_passwords = [
            'password', '123456', '12345678', 'qwerty',
            'abc123', 'monkey', '1234567', 'letmein',
            'trustno1', 'dragon', 'baseball', 'iloveyou',
            'master', 'sunshine', 'ashley', 'bailey'
        ]
        
        print(f"ğŸ“– å­—å…¸æ”»å‡»æ¼”ç¤º")
        print(f"ç›®æ ‡å“ˆå¸Œ: {target_hash}\n")
        
        start_time = time.time()
        
        for i, password in enumerate(common_passwords, 1):
            computed_hash = hashlib.md5(password.encode()).hexdigest()
            
            if computed_hash == target_hash:
                elapsed = time.time() - start_time
                print(f"âœ… ç ´è§£æˆåŠŸï¼")
                print(f"å¯†ç : {password}")
                print(f"å°è¯•æ¬¡æ•°: {i}")
                print(f"è€—æ—¶: {elapsed:.4f}ç§’")
                return password
        
        print(f"âŒ å­—å…¸ä¸­æœªæ‰¾åˆ°åŒ¹é…å¯†ç ")
        return None
    
    @staticmethod
    def rainbow_table_demo(password_list):
        """å½©è™¹è¡¨æ¼”ç¤º"""
        print("ğŸŒˆ å½©è™¹è¡¨æ¼”ç¤º\n")
        
        # æ„å»ºå½©è™¹è¡¨ï¼ˆé¢„è®¡ç®—å“ˆå¸Œï¼‰
        rainbow_table = {}
        
        print("æ„å»ºå½©è™¹è¡¨...")
        for password in password_list:
            md5_hash = hashlib.md5(password.encode()).hexdigest()
            sha256_hash = hashlib.sha256(password.encode()).hexdigest()
            
            rainbow_table[md5_hash] = password
            rainbow_table[sha256_hash] = password
        
        print(f"âœ… å½©è™¹è¡¨åŒ…å« {len(password_list)} ä¸ªå¯†ç ")
        print(f"   è¡¨å¤§å°: {len(rainbow_table)} ä¸ªå“ˆå¸Œ\n")
        
        # æ¨¡æ‹ŸæŸ¥è¯¢
        test_password = "password"
        test_hash = hashlib.md5(test_password.encode()).hexdigest()
        
        print(f"æŸ¥è¯¢å“ˆå¸Œ: {test_hash}")
        if test_hash in rainbow_table:
            print(f"âœ… æ‰¾åˆ°å¯†ç : {rainbow_table[test_hash]}")
        else:
            print(f"âŒ æœªåœ¨å½©è™¹è¡¨ä¸­æ‰¾åˆ°")
        
        return rainbow_table

# æ¼”ç¤ºæ”»å‡»ï¼ˆæ•™è‚²ç”¨é€”ï¼‰
print("âš ï¸  ä»¥ä¸‹æ¼”ç¤ºä»…ç”¨äºæ•™è‚²ç›®çš„\n")

attacks = CryptographicAttacks()

# 1. æš´åŠ›ç ´è§£ï¼ˆç®€å•å¯†ç ï¼‰
print("\n" + "=" * 60)
weak_password = "abc"
weak_hash = hashlib.md5(weak_password.encode()).hexdigest()
attacks.brute_force_attack(weak_hash, max_length=3)

# 2. å­—å…¸æ”»å‡»
print("\n" + "=" * 60)
common_password = "password"
common_hash = hashlib.md5(common_password.encode()).hexdigest()
attacks.dictionary_attack(common_hash)

# 3. å½©è™¹è¡¨
print("\n" + "=" * 60)
password_list = ['password', '123456', 'admin', 'letmein', 'welcome']
rainbow_table = attacks.rainbow_table_demo(password_list)

# é˜²æŠ¤å»ºè®®
print("\n" + "=" * 60)
print("ğŸ›¡ï¸  é˜²æŠ¤å»ºè®®")
print("=" * 60)
print("""
1. ä½¿ç”¨å¼ºå¯†ç ï¼š
   â€¢ è‡³å°‘12ä¸ªå­—ç¬¦
   â€¢ åŒ…å«å¤§å°å†™å­—æ¯ã€æ•°å­—ã€ç‰¹æ®Šå­—ç¬¦
   â€¢ é¿å…ä½¿ç”¨å¸¸è§è¯è¯­

2. ä½¿ç”¨ç›å€¼ï¼ˆSaltï¼‰ï¼š
   â€¢ æ¯ä¸ªå¯†ç ä½¿ç”¨å”¯ä¸€çš„éšæœºç›å€¼
   â€¢ é˜²æ­¢å½©è™¹è¡¨æ”»å‡»

3. ä½¿ç”¨å¯†é’¥æ‹‰ä¼¸ï¼ˆKey Stretchingï¼‰ï¼š
   â€¢ ä½¿ç”¨PBKDF2ã€bcryptã€scryptã€Argon2
   â€¢ å¢åŠ è®¡ç®—æˆæœ¬ï¼Œé™ä½æš´åŠ›ç ´è§£é€Ÿåº¦

4. ä½¿ç”¨å¤šå› ç´ è®¤è¯ï¼ˆMFAï¼‰ï¼š
   â€¢ å¯†ç  + çŸ­ä¿¡éªŒè¯ç 
   â€¢ å¯†ç  + ç”Ÿç‰©è¯†åˆ«
   â€¢ å¯†ç  + ç¡¬ä»¶ä»¤ç‰Œ

5. å®šæœŸæ›´æ–°å¯†ç ç­–ç•¥ï¼š
   â€¢ å¼ºåˆ¶å®šæœŸæ›´æ”¹å¯†ç 
   â€¢ æ£€æµ‹å¼±å¯†ç å’Œæ³„éœ²å¯†ç 
""")
```

---

**æœ¬ç« å®Œ**
