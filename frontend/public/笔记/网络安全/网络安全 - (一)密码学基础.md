# 网络安全 - (一)密码学基础

学习加密算法与应用。

---

## 1. 密码学基础

### 1.1 对称加密

```python
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
from Crypto.Util.Padding import pad, unpad
import base64

class AESCipher:
    def __init__(self, key=None):
        self.key = key or get_random_bytes(32)  # 256位密钥
    
    def encrypt(self, plaintext):
        """AES加密"""
        cipher = AES.new(self.key, AES.MODE_CBC)
        
        # 填充到16字节的倍数
        padded_text = pad(plaintext.encode(), AES.block_size)
        
        # 加密
        ciphertext = cipher.encrypt(padded_text)
        
        # 返回IV + 密文的Base64编码
        return base64.b64encode(cipher.iv + ciphertext).decode()
    
    def decrypt(self, encrypted_text):
        """AES解密"""
        encrypted_data = base64.b64decode(encrypted_text)
        
        # 提取IV和密文
        iv = encrypted_data[:AES.block_size]
        ciphertext = encrypted_data[AES.block_size:]
        
        # 解密
        cipher = AES.new(self.key, AES.MODE_CBC, iv)
        padded_plaintext = cipher.decrypt(ciphertext)
        
        # 去除填充
        plaintext = unpad(padded_plaintext, AES.block_size)
        
        return plaintext.decode()

# 测试AES加密
aes = AESCipher()
message = "这是一条机密信息"

encrypted = aes.encrypt(message)
print(f"🔒 加密: {encrypted}")

decrypted = aes.decrypt(encrypted)
print(f"🔓 解密: {decrypted}")
```

### 1.2 非对称加密（RSA）

```python
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP
from Crypto.Signature import pkcs1_15
from Crypto.Hash import SHA256
import base64

class RSACipher:
    def __init__(self, key_size=2048):
        self.key_pair = RSA.generate(key_size)
        self.public_key = self.key_pair.publickey()
    
    def get_public_key_pem(self):
        """获取公钥PEM格式"""
        return self.public_key.export_key().decode()
    
    def get_private_key_pem(self):
        """获取私钥PEM格式"""
        return self.key_pair.export_key().decode()
    
    def encrypt(self, plaintext, public_key=None):
        """RSA加密（使用公钥）"""
        key = public_key or self.public_key
        cipher = PKCS1_OAEP.new(key)
        
        # RSA加密有长度限制，需要分块
        max_length = key.size_in_bytes() - 42  # OAEP填充开销
        
        if len(plaintext.encode()) <= max_length:
            ciphertext = cipher.encrypt(plaintext.encode())
            return base64.b64encode(ciphertext).decode()
        else:
            raise ValueError("消息太长，需要分块处理")
    
    def decrypt(self, encrypted_text):
        """RSA解密（使用私钥）"""
        cipher = PKCS1_OAEP.new(self.key_pair)
        ciphertext = base64.b64decode(encrypted_text)
        
        plaintext = cipher.decrypt(ciphertext)
        return plaintext.decode()
    
    def sign(self, message):
        """数字签名"""
        hash_obj = SHA256.new(message.encode())
        signature = pkcs1_15.new(self.key_pair).sign(hash_obj)
        return base64.b64encode(signature).decode()
    
    def verify(self, message, signature, public_key=None):
        """验证签名"""
        key = public_key or self.public_key
        hash_obj = SHA256.new(message.encode())
        signature_bytes = base64.b64decode(signature)
        
        try:
            pkcs1_15.new(key).verify(hash_obj, signature_bytes)
            return True
        except:
            return False

# 测试RSA
rsa = RSACipher()
message = "重要合同内容"

# 加密
encrypted = rsa.encrypt(message)
print(f"🔒 RSA加密: {encrypted[:50]}...")

# 解密
decrypted = rsa.decrypt(encrypted)
print(f"🔓 RSA解密: {decrypted}")

# 数字签名
signature = rsa.sign(message)
print(f"✍️  数字签名: {signature[:50]}...")

# 验证签名
is_valid = rsa.verify(message, signature)
print(f"✅ 签名验证: {is_valid}")
```

### 1.3 哈希函数与消息认证

```python
import hashlib
import hmac
import secrets

class HashUtils:
    @staticmethod
    def sha256(data):
        """SHA-256哈希"""
        return hashlib.sha256(data.encode()).hexdigest()
    
    @staticmethod
    def md5(data):
        """MD5哈希（不安全，仅用于演示）"""
        return hashlib.md5(data.encode()).hexdigest()
    
    @staticmethod
    def hmac_sha256(key, message):
        """HMAC-SHA256消息认证码"""
        return hmac.new(key.encode(), message.encode(), hashlib.sha256).hexdigest()
    
    @staticmethod
    def generate_salt(length=32):
        """生成随机盐值"""
        return secrets.token_hex(length)
    
    @staticmethod
    def hash_password(password, salt=None):
        """安全的密码哈希"""
        if salt is None:
            salt = HashUtils.generate_salt()
        
        # 使用PBKDF2进行密钥拉伸
        import hashlib
        key = hashlib.pbkdf2_hmac('sha256', 
                                  password.encode(), 
                                  salt.encode(), 
                                  100000)  # 10万次迭代
        
        return salt + key.hex()
    
    @staticmethod
    def verify_password(password, hashed):
        """验证密码"""
        salt = hashed[:64]  # 前64个字符是盐值
        key = hashed[64:]
        
        new_key = hashlib.pbkdf2_hmac('sha256',
                                      password.encode(),
                                      salt.encode(),
                                      100000)
        
        return key == new_key.hex()

# 测试哈希和HMAC
data = "敏感数据"
key = "secret_key"

print(f"📊 原始数据: {data}")
print(f"🔢 SHA-256: {HashUtils.sha256(data)}")
print(f"🔐 HMAC-SHA256: {HashUtils.hmac_sha256(key, data)}")

# 测试密码哈希
password = "my_secure_password"
hashed = HashUtils.hash_password(password)
print(f"\n🔒 密码哈希: {hashed}")

is_valid = HashUtils.verify_password(password, hashed)
print(f"✅ 密码验证: {is_valid}")

is_invalid = HashUtils.verify_password("wrong_password", hashed)
print(f"❌ 错误密码: {is_invalid}")
```

### 1.4 数字证书与PKI体系

**公钥基础设施（PKI）** 是一个用于创建、管理、分发、使用和撤销数字证书的框架。

```python
from cryptography import x509
from cryptography.x509.oid import NameOID, ExtensionOID
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import serialization
import datetime

class CertificateAuthority:
    def __init__(self, ca_name="IntelliBuddy CA"):
        """初始化证书颁发机构"""
        # 生成CA的私钥
        self.ca_private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=4096
        )
        
        # 生成CA的自签名证书
        self.ca_cert = self._generate_ca_certificate(ca_name)
    
    def _generate_ca_certificate(self, ca_name):
        """生成CA自签名证书"""
        subject = issuer = x509.Name([
            x509.NameAttribute(NameOID.COUNTRY_NAME, "CN"),
            x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, "Beijing"),
            x509.NameAttribute(NameOID.LOCALITY_NAME, "Beijing"),
            x509.NameAttribute(NameOID.ORGANIZATION_NAME, ca_name),
            x509.NameAttribute(NameOID.COMMON_NAME, ca_name)
        ])
        
        cert = (
            x509.CertificateBuilder()
            .subject_name(subject)
            .issuer_name(issuer)
            .public_key(self.ca_private_key.public_key())
            .serial_number(x509.random_serial_number())
            .not_valid_before(datetime.datetime.utcnow())
            .not_valid_after(datetime.datetime.utcnow() + datetime.timedelta(days=3650))
            .add_extension(
                x509.BasicConstraints(ca=True, path_length=None),
                critical=True
            )
            .add_extension(
                x509.KeyUsage(
                    digital_signature=True,
                    key_cert_sign=True,
                    crl_sign=True,
                    key_encipherment=False,
                    content_commitment=False,
                    data_encipherment=False,
                    key_agreement=False,
                    encipher_only=False,
                    decipher_only=False
                ),
                critical=True
            )
            .sign(self.ca_private_key, hashes.SHA256())
        )
        
        return cert
    
    def issue_certificate(self, common_name, organization="User Org", 
                         validity_days=365):
        """颁发用户证书"""
        # 生成用户的密钥对
        user_private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=2048
        )
        
        # 创建证书主题
        subject = x509.Name([
            x509.NameAttribute(NameOID.COUNTRY_NAME, "CN"),
            x509.NameAttribute(NameOID.ORGANIZATION_NAME, organization),
            x509.NameAttribute(NameOID.COMMON_NAME, common_name)
        ])
        
        # 生成证书
        cert = (
            x509.CertificateBuilder()
            .subject_name(subject)
            .issuer_name(self.ca_cert.subject)
            .public_key(user_private_key.public_key())
            .serial_number(x509.random_serial_number())
            .not_valid_before(datetime.datetime.utcnow())
            .not_valid_after(
                datetime.datetime.utcnow() + datetime.timedelta(days=validity_days)
            )
            .add_extension(
                x509.BasicConstraints(ca=False, path_length=None),
                critical=True
            )
            .add_extension(
                x509.KeyUsage(
                    digital_signature=True,
                    key_encipherment=True,
                    content_commitment=False,
                    data_encipherment=False,
                    key_agreement=False,
                    key_cert_sign=False,
                    crl_sign=False,
                    encipher_only=False,
                    decipher_only=False
                ),
                critical=True
            )
            .sign(self.ca_private_key, hashes.SHA256())
        )
        
        return user_private_key, cert
    
    def verify_certificate(self, cert):
        """验证证书"""
        try:
            # 验证证书签名
            self.ca_cert.public_key().verify(
                cert.signature,
                cert.tbs_certificate_bytes,
                cert.signature_algorithm_parameters
            )
            
            # 检查有效期
            now = datetime.datetime.utcnow()
            if now < cert.not_valid_before or now > cert.not_valid_after:
                return False, "证书已过期或尚未生效"
            
            return True, "证书有效"
        except Exception as e:
            return False, f"证书验证失败: {str(e)}"
    
    def export_ca_cert_pem(self):
        """导出CA证书（PEM格式）"""
        return self.ca_cert.public_bytes(
            encoding=serialization.Encoding.PEM
        ).decode()
    
    def export_cert_pem(self, cert):
        """导出证书（PEM格式）"""
        return cert.public_bytes(
            encoding=serialization.Encoding.PEM
        ).decode()
    
    def export_private_key_pem(self, private_key, password=None):
        """导出私钥（PEM格式）"""
        encryption = serialization.NoEncryption()
        if password:
            encryption = serialization.BestAvailableEncryption(password.encode())
        
        return private_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.PKCS8,
            encryption_algorithm=encryption
        ).decode()

# 测试PKI体系
print("🏛️  PKI体系演示:")
ca = CertificateAuthority("IntelliBuddy Root CA")

# 导出CA证书
ca_cert_pem = ca.export_ca_cert_pem()
print(f"\n📜 CA证书:\n{ca_cert_pem[:200]}...")

# 为用户颁发证书
user_key, user_cert = ca.issue_certificate("user@example.com", "Example Corp")
print(f"\n✅ 为用户颁发证书")
print(f"证书序列号: {user_cert.serial_number}")
print(f"证书主题: {user_cert.subject.rfc4514_string()}")
print(f"有效期: {user_cert.not_valid_before} 至 {user_cert.not_valid_after}")

# 验证证书
is_valid, message = ca.verify_certificate(user_cert)
print(f"\n🔍 证书验证: {is_valid} - {message}")

# 导出用户证书和私钥
user_cert_pem = ca.export_cert_pem(user_cert)
user_key_pem = ca.export_private_key_pem(user_key)
print(f"\n📄 用户证书长度: {len(user_cert_pem)} 字节")
print(f"🔑 用户私钥长度: {len(user_key_pem)} 字节")
```

### 1.5 密钥交换协议（Diffie-Hellman）

**Diffie-Hellman密钥交换**允许双方在不安全的信道上协商出共享密钥。

```python
from cryptography.hazmat.primitives.asymmetric import dh
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.kdf.hkdf import HKDF
import hashlib

class DHKeyExchange:
    def __init__(self):
        # 生成DH参数（实际应用中应该使用标准参数）
        self.parameters = dh.generate_parameters(
            generator=2,
            key_size=2048
        )
    
    def generate_keypair(self):
        """生成密钥对"""
        private_key = self.parameters.generate_private_key()
        public_key = private_key.public_key()
        return private_key, public_key
    
    def compute_shared_key(self, my_private_key, peer_public_key):
        """计算共享密钥"""
        shared_key = my_private_key.exchange(peer_public_key)
        
        # 使用HKDF派生密钥
        derived_key = HKDF(
            algorithm=hashes.SHA256(),
            length=32,
            salt=None,
            info=b'handshake data'
        ).derive(shared_key)
        
        return derived_key
    
    def serialize_public_key(self, public_key):
        """序列化公钥"""
        return public_key.public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo
        )
    
    def deserialize_public_key(self, public_key_bytes):
        """反序列化公钥"""
        return serialization.load_pem_public_key(public_key_bytes)

# 模拟Alice和Bob的密钥交换
print("🔐 Diffie-Hellman密钥交换演示:")

dh_exchange = DHKeyExchange()

# Alice生成密钥对
alice_private, alice_public = dh_exchange.generate_keypair()
print("\n👩 Alice生成了密钥对")

# Bob生成密钥对
bob_private, bob_public = dh_exchange.generate_keypair()
print("👨 Bob生成了密钥对")

# Alice计算共享密钥（使用Bob的公钥）
alice_shared_key = dh_exchange.compute_shared_key(alice_private, bob_public)
print(f"\n👩 Alice计算的共享密钥: {alice_shared_key.hex()[:32]}...")

# Bob计算共享密钥（使用Alice的公钥）
bob_shared_key = dh_exchange.compute_shared_key(bob_private, alice_public)
print(f"👨 Bob计算的共享密钥: {bob_shared_key.hex()[:32]}...")

# 验证双方密钥相同
if alice_shared_key == bob_shared_key:
    print("\n✅ 密钥交换成功！双方共享密钥相同")
else:
    print("\n❌ 密钥交换失败！")
```

### 1.6 消息认证码（MAC）与数字签名对比

```python
import hmac
import hashlib
from Crypto.PublicKey import RSA
from Crypto.Signature import pkcs1_15
from Crypto.Hash import SHA256

class SecurityComparison:
    """MAC vs 数字签名对比"""
    
    def __init__(self):
        # MAC密钥（对称）
        self.mac_key = b"shared_secret_key_12345"
        
        # RSA密钥对（非对称）
        self.rsa_key = RSA.generate(2048)
        self.rsa_public = self.rsa_key.publickey()
    
    def generate_mac(self, message):
        """生成消息认证码（HMAC）"""
        mac = hmac.new(
            self.mac_key,
            message.encode(),
            hashlib.sha256
        ).hexdigest()
        return mac
    
    def verify_mac(self, message, mac):
        """验证MAC"""
        expected_mac = self.generate_mac(message)
        return hmac.compare_digest(mac, expected_mac)
    
    def generate_signature(self, message):
        """生成数字签名"""
        hash_obj = SHA256.new(message.encode())
        signature = pkcs1_15.new(self.rsa_key).sign(hash_obj)
        return signature.hex()
    
    def verify_signature(self, message, signature):
        """验证数字签名"""
        hash_obj = SHA256.new(message.encode())
        signature_bytes = bytes.fromhex(signature)
        
        try:
            pkcs1_15.new(self.rsa_public).verify(hash_obj, signature_bytes)
            return True
        except:
            return False

# 对比演示
print("📊 MAC vs 数字签名对比:\n")

sec = SecurityComparison()
message = "重要的业务数据"

print("=" * 60)
print("1️⃣  消息认证码（MAC/HMAC）")
print("=" * 60)
print("特点：")
print("  • 使用对称密钥（双方共享同一密钥）")
print("  • 速度快")
print("  • 可以认证消息完整性")
print("  • 不提供不可否认性")
print()

mac = sec.generate_mac(message)
print(f"消息: {message}")
print(f"MAC: {mac}")
print(f"验证结果: {sec.verify_mac(message, mac)}")

print("\n" + "=" * 60)
print("2️⃣  数字签名（Digital Signature）")
print("=" * 60)
print("特点：")
print("  • 使用非对称密钥（私钥签名，公钥验证）")
print("  • 速度较慢")
print("  • 提供消息完整性和身份认证")
print("  • 提供不可否认性")
print()

signature = sec.generate_signature(message)
print(f"消息: {message}")
print(f"签名: {signature[:64]}...")
print(f"验证结果: {sec.verify_signature(message, signature)}")

print("\n" + "=" * 60)
print("📌 使用场景对比")
print("=" * 60)
print()
print("使用MAC的场景：")
print("  • API接口认证（双方共享密钥）")
print("  • Cookie完整性保护")
print("  • 分布式系统内部通信")
print()
print("使用数字签名的场景：")
print("  • 软件分发（验证发布者）")
print("  • 电子合同（法律效力）")
print("  • 区块链交易（不可篡改）")
print("  • SSL/TLS证书")
```

### 1.7 密码学攻击与防护

```python
import string
import itertools
import time
import hashlib

class CryptographicAttacks:
    """密码学攻击演示（教育用途）"""
    
    @staticmethod
    def brute_force_attack(target_hash, hash_type='md5', max_length=4):
        """暴力破解攻击"""
        charset = string.ascii_lowercase + string.digits
        
        print(f"🔨 暴力破解攻击演示")
        print(f"目标哈希: {target_hash}")
        print(f"哈希算法: {hash_type.upper()}")
        print(f"字符集: {charset}")
        print(f"最大长度: {max_length}\n")
        
        start_time = time.time()
        attempts = 0
        
        for length in range(1, max_length + 1):
            for candidate in itertools.product(charset, repeat=length):
                attempts += 1
                password = ''.join(candidate)
                
                # 计算哈希
                if hash_type == 'md5':
                    computed_hash = hashlib.md5(password.encode()).hexdigest()
                elif hash_type == 'sha256':
                    computed_hash = hashlib.sha256(password.encode()).hexdigest()
                else:
                    raise ValueError(f"不支持的哈希类型: {hash_type}")
                
                # 检查是否匹配
                if computed_hash == target_hash:
                    elapsed = time.time() - start_time
                    print(f"✅ 破解成功！")
                    print(f"密码: {password}")
                    print(f"尝试次数: {attempts:,}")
                    print(f"耗时: {elapsed:.2f}秒")
                    print(f"速度: {attempts/elapsed:,.0f} 次/秒")
                    return password
                
                # 进度显示
                if attempts % 10000 == 0:
                    print(f"已尝试 {attempts:,} 次...")
        
        print(f"❌ 破解失败（尝试了 {attempts:,} 次）")
        return None
    
    @staticmethod
    def dictionary_attack(target_hash, dictionary_file=None):
        """字典攻击"""
        # 常见密码字典
        common_passwords = [
            'password', '123456', '12345678', 'qwerty',
            'abc123', 'monkey', '1234567', 'letmein',
            'trustno1', 'dragon', 'baseball', 'iloveyou',
            'master', 'sunshine', 'ashley', 'bailey'
        ]
        
        print(f"📖 字典攻击演示")
        print(f"目标哈希: {target_hash}\n")
        
        start_time = time.time()
        
        for i, password in enumerate(common_passwords, 1):
            computed_hash = hashlib.md5(password.encode()).hexdigest()
            
            if computed_hash == target_hash:
                elapsed = time.time() - start_time
                print(f"✅ 破解成功！")
                print(f"密码: {password}")
                print(f"尝试次数: {i}")
                print(f"耗时: {elapsed:.4f}秒")
                return password
        
        print(f"❌ 字典中未找到匹配密码")
        return None
    
    @staticmethod
    def rainbow_table_demo(password_list):
        """彩虹表演示"""
        print("🌈 彩虹表演示\n")
        
        # 构建彩虹表（预计算哈希）
        rainbow_table = {}
        
        print("构建彩虹表...")
        for password in password_list:
            md5_hash = hashlib.md5(password.encode()).hexdigest()
            sha256_hash = hashlib.sha256(password.encode()).hexdigest()
            
            rainbow_table[md5_hash] = password
            rainbow_table[sha256_hash] = password
        
        print(f"✅ 彩虹表包含 {len(password_list)} 个密码")
        print(f"   表大小: {len(rainbow_table)} 个哈希\n")
        
        # 模拟查询
        test_password = "password"
        test_hash = hashlib.md5(test_password.encode()).hexdigest()
        
        print(f"查询哈希: {test_hash}")
        if test_hash in rainbow_table:
            print(f"✅ 找到密码: {rainbow_table[test_hash]}")
        else:
            print(f"❌ 未在彩虹表中找到")
        
        return rainbow_table

# 演示攻击（教育用途）
print("⚠️  以下演示仅用于教育目的\n")

attacks = CryptographicAttacks()

# 1. 暴力破解（简单密码）
print("\n" + "=" * 60)
weak_password = "abc"
weak_hash = hashlib.md5(weak_password.encode()).hexdigest()
attacks.brute_force_attack(weak_hash, max_length=3)

# 2. 字典攻击
print("\n" + "=" * 60)
common_password = "password"
common_hash = hashlib.md5(common_password.encode()).hexdigest()
attacks.dictionary_attack(common_hash)

# 3. 彩虹表
print("\n" + "=" * 60)
password_list = ['password', '123456', 'admin', 'letmein', 'welcome']
rainbow_table = attacks.rainbow_table_demo(password_list)

# 防护建议
print("\n" + "=" * 60)
print("🛡️  防护建议")
print("=" * 60)
print("""
1. 使用强密码：
   • 至少12个字符
   • 包含大小写字母、数字、特殊字符
   • 避免使用常见词语

2. 使用盐值（Salt）：
   • 每个密码使用唯一的随机盐值
   • 防止彩虹表攻击

3. 使用密钥拉伸（Key Stretching）：
   • 使用PBKDF2、bcrypt、scrypt、Argon2
   • 增加计算成本，降低暴力破解速度

4. 使用多因素认证（MFA）：
   • 密码 + 短信验证码
   • 密码 + 生物识别
   • 密码 + 硬件令牌

5. 定期更新密码策略：
   • 强制定期更改密码
   • 检测弱密码和泄露密码
""")
```

---

**本章完**
