# 网络安全 - (三)网络攻击与防护

理解网络攻防技术。

---

## 3. 网络攻击与防护

### 3.1 DDoS防护

```python
import time
import threading
from collections import defaultdict, deque

class DDoSProtection:
    def __init__(self):
        # 请求计数器
        self.request_counts = defaultdict(deque)
        self.blocked_ips = set()
        
        # 配置参数
        self.rate_limit = 100  # 每分钟最大请求数
        self.time_window = 60  # 时间窗口（秒）
        self.block_duration = 300  # 封禁时长（秒）
        
        # 地理位置异常检测
        self.geo_requests = defaultdict(lambda: defaultdict(int))
        
        # 启动清理线程
        self.cleanup_thread = threading.Thread(target=self._cleanup_expired, daemon=True)
        self.cleanup_thread.start()
    
    def is_request_allowed(self, ip_address, user_agent=None, geo_country=None):
        """检查请求是否被允许"""
        current_time = time.time()
        
        # 检查IP是否被封禁
        if ip_address in self.blocked_ips:
            return False, "IP已被封禁"
        
        # 速率限制检查
        if not self._check_rate_limit(ip_address, current_time):
            self.blocked_ips.add(ip_address)
            # 设置解封定时器
            threading.Timer(self.block_duration, 
                          lambda: self.blocked_ips.discard(ip_address)).start()
            return False, "请求频率过高，IP已被封禁"
        
        # User-Agent检查
        if user_agent and self._is_suspicious_user_agent(user_agent):
            return False, "可疑的User-Agent"
        
        # 地理位置异常检查
        if geo_country and self._is_geo_anomaly(ip_address, geo_country):
            return False, "地理位置异常"
        
        return True, "请求允许"
    
    def _check_rate_limit(self, ip_address, current_time):
        """检查速率限制"""
        requests = self.request_counts[ip_address]
        
        # 移除过期请求
        while requests and current_time - requests[0] > self.time_window:
            requests.popleft()
        
        # 添加当前请求
        requests.append(current_time)
        
        # 检查是否超过限制
        return len(requests) <= self.rate_limit
    
    def _is_suspicious_user_agent(self, user_agent):
        """检查可疑的User-Agent"""
        suspicious_patterns = [
            'bot', 'crawler', 'spider', 'scraper',
            'python-requests', 'curl', 'wget'
        ]
        
        user_agent_lower = user_agent.lower()
        return any(pattern in user_agent_lower for pattern in suspicious_patterns)
    
    def _is_geo_anomaly(self, ip_address, country):
        """检查地理位置异常"""
        # 记录IP的地理位置
        self.geo_requests[ip_address][country] += 1
        
        # 如果同一IP来自多个国家，可能是代理
        countries = list(self.geo_requests[ip_address].keys())
        if len(countries) > 3:  # 超过3个国家
            return True
        
        return False
    
    def _cleanup_expired(self):
        """清理过期数据"""
        while True:
            time.sleep(60)  # 每分钟清理一次
            current_time = time.time()
            
            # 清理过期的请求记录
            for ip in list(self.request_counts.keys()):
                requests = self.request_counts[ip]
                while requests and current_time - requests[0] > self.time_window:
                    requests.popleft()
                
                # 如果队列为空，删除记录
                if not requests:
                    del self.request_counts[ip]

class LoadBalancer:
    def __init__(self, servers):
        self.servers = servers
        self.current_index = 0
        self.server_health = {server: True for server in servers}
    
    def get_server(self):
        """获取可用服务器"""
        # 简单轮询
        attempts = 0
        while attempts < len(self.servers):
            server = self.servers[self.current_index]
            self.current_index = (self.current_index + 1) % len(self.servers)
            
            if self.server_health[server]:
                return server
            
            attempts += 1
        
        return None  # 所有服务器都不可用
    
    def mark_server_down(self, server):
        """标记服务器下线"""
        self.server_health[server] = False
        print(f"🚨 服务器 {server} 标记为下线")
    
    def mark_server_up(self, server):
        """标记服务器上线"""
        self.server_health[server] = True
        print(f"✅ 服务器 {server} 恢复上线")

# 测试DDoS防护
ddos_protection = DDoSProtection()
load_balancer = LoadBalancer(['server1', 'server2', 'server3'])

print("🧪 DDoS防护测试:")

# 模拟正常请求
for i in range(5):
    allowed, reason = ddos_protection.is_request_allowed(
        "192.168.1.100", 
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
    )
    print(f"正常请求 {i+1}: {allowed} - {reason}")

# 模拟攻击请求
print("\n🚨 模拟DDoS攻击:")
for i in range(105):  # 超过速率限制
    allowed, reason = ddos_protection.is_request_allowed("192.168.1.200")
    if not allowed:
        print(f"攻击请求 {i+1}: {allowed} - {reason}")
        break

# 模拟可疑User-Agent
allowed, reason = ddos_protection.is_request_allowed(
    "192.168.1.300", 
    "python-requests/2.25.1"
)
print(f"可疑UA: {allowed} - {reason}")

# 负载均衡测试
print(f"\n⚖️  负载均衡:")
for i in range(5):
    server = load_balancer.get_server()
    print(f"请求 {i+1} -> {server}")
```

### 3.2 端口扫描与漏洞检测

```python
import socket
import threading
from queue import Queue
from datetime import datetime

class PortScanner:
    """端口扫描器"""
    
    def __init__(self, target, timeout=1):
        self.target = target
        self.timeout = timeout
        self.open_ports = []
        self.queue = Queue()
        
        # 常见端口及服务
        self.common_ports = {
            21: 'FTP',
            22: 'SSH',
            23: 'Telnet',
            25: 'SMTP',
            53: 'DNS',
            80: 'HTTP',
            110: 'POP3',
            143: 'IMAP',
            443: 'HTTPS',
            445: 'SMB',
            3306: 'MySQL',
            3389: 'RDP',
            5432: 'PostgreSQL',
            6379: 'Redis',
            8080: 'HTTP-Alt',
            27017: 'MongoDB'
        }
    
    def scan_port(self, port):
        """扫描单个端口"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(self.timeout)
            
            result = sock.connect_ex((self.target, port))
            
            if result == 0:
                service = self.common_ports.get(port, 'Unknown')
                
                # 尝试获取banner（服务指纹）
                banner = self.grab_banner(sock, port)
                
                self.open_ports.append({
                    'port': port,
                    'service': service,
                    'banner': banner
                })
            
            sock.close()
        
        except Exception:
            pass
    
    def grab_banner(self, sock, port):
        """获取服务banner"""
        try:
            # 对某些服务发送探测请求
            if port in [80, 8080]:
                sock.send(b'GET / HTTP/1.0\r\n\r\n')
            elif port == 22:
                pass  # SSH会主动发送banner
            elif port in [21, 25, 110, 143]:
                pass  # 这些服务会自动发送欢迎信息
            
            banner = sock.recv(1024).decode('utf-8', errors='ignore').strip()
            return banner[:100]  # 限制长度
        except:
            return None
    
    def worker(self):
        """工作线程"""
        while not self.queue.empty():
            port = self.queue.get()
            self.scan_port(port)
            self.queue.task_done()
    
    def scan_range(self, start_port=1, end_port=1024, num_threads=100):
        """扫描端口范围"""
        print(f"🔍 开始扫描 {self.target}")
        print(f"端口范围: {start_port}-{end_port}")
        print(f"线程数: {num_threads}\n")
        
        start_time = datetime.now()
        
        # 将端口放入队列
        for port in range(start_port, end_port + 1):
            self.queue.put(port)
        
        # 创建线程
        threads = []
        for _ in range(num_threads):
            thread = threading.Thread(target=self.worker)
            thread.daemon = True
            thread.start()
            threads.append(thread)
        
        # 等待完成
        self.queue.join()
        
        end_time = datetime.now()
        elapsed = end_time - start_time
        
        # 显示结果
        print(f"✅ 扫描完成，耗时: {elapsed}")
        print(f"\n发现 {len(self.open_ports)} 个开放端口:\n")
        
        for port_info in sorted(self.open_ports, key=lambda x: x['port']):
            print(f"  端口 {port_info['port']:5d} | {port_info['service']:15s} | ", end='')
            if port_info['banner']:
                print(f"{port_info['banner'][:50]}")
            else:
                print("无banner")
        
        return self.open_ports

class VulnerabilityScanner:
    """漏洞扫描器（简化版）"""
    
    def __init__(self, target, open_ports):
        self.target = target
        self.open_ports = open_ports
        self.vulnerabilities = []
    
    def check_weak_services(self):
        """检查不安全的服务"""
        vulnerable_services = {
            21: ('FTP', '未加密的文件传输协议'),
            23: ('Telnet', '未加密的远程登录'),
            80: ('HTTP', '未加密的Web服务'),
            3306: ('MySQL', '数据库端口暴露'),
            6379: ('Redis', '默认无认证的缓存服务'),
            27017: ('MongoDB', '默认无认证的数据库')
        }
        
        print("\n🔍 检查不安全的服务:")
        
        for port_info in self.open_ports:
            port = port_info['port']
            
            if port in vulnerable_services:
                service, risk = vulnerable_services[port]
                
                vuln = {
                    'type': '不安全的服务',
                    'port': port,
                    'service': service,
                    'severity': 'Medium' if port in [21, 23] else 'Low',
                    'description': risk
                }
                
                self.vulnerabilities.append(vuln)
                
                print(f"  ⚠️  [{vuln['severity']}] 端口 {port}: {risk}")
    
    def check_default_credentials(self):
        """检查默认凭据（模拟）"""
        print("\n🔐 检查默认凭据:")
        
        # 常见的默认凭据
        default_creds = {
            22: [('root', 'root'), ('admin', 'admin')],
            3306: [('root', ''), ('root', 'root')],
            3389: [('Administrator', 'admin'), ('Admin', '123456')]
        }
        
        for port_info in self.open_ports:
            port = port_info['port']
            
            if port in default_creds:
                print(f"  ⚠️  端口 {port} ({port_info['service']}): 建议检查是否使用默认密码")
    
    def check_outdated_software(self):
        """检查过时的软件版本"""
        print("\n🔄 检查软件版本:")
        
        for port_info in self.open_ports:
            banner = port_info.get('banner', '')
            
            if banner:
                # 检查已知的过时版本（简化）
                if 'Apache/2.2' in banner:
                    print(f"  ⚠️  [High] 端口 {port_info['port']}: Apache 2.2 版本过旧")
                elif 'OpenSSH' in banner and '5.' in banner:
                    print(f"  ⚠️  [Medium] 端口 {port_info['port']}: OpenSSH 版本过旧")
    
    def generate_report(self):
        """生成漏洞报告"""
        print("\n" + "=" * 60)
        print("📊 漏洞扫描报告")
        print("=" * 60)
        
        print(f"\n目标: {self.target}")
        print(f"开放端口数: {len(self.open_ports)}")
        print(f"发现漏洞数: {len(self.vulnerabilities)}\n")
        
        # 按严重程度分类
        severity_count = {'High': 0, 'Medium': 0, 'Low': 0}
        
        for vuln in self.vulnerabilities:
            severity_count[vuln['severity']] += 1
        
        print("严重程度统计:")
        print(f"  🔴 High:   {severity_count['High']}")
        print(f"  🟡 Medium: {severity_count['Medium']}")
        print(f"  🟢 Low:    {severity_count['Low']}")
        
        # 修复建议
        print("\n修复建议:")
        print("  1. 关闭不必要的端口和服务")
        print("  2. 更新软件到最新版本")
        print("  3. 修改默认密码")
        print("  4. 启用防火墙和访问控制")
        print("  5. 使用加密协议（SSH代替Telnet，HTTPS代替HTTP）")

# 测试（仅用于演示，实际使用需谨慎）
print("⚠️  以下演示仅用于本地测试和教育目的\n")
print("=" * 60)
print("端口扫描演示")
print("=" * 60)

# 扫描本地主机
scanner = PortScanner('127.0.0.1', timeout=0.5)
open_ports = scanner.scan_range(start_port=20, end_port=100, num_threads=50)

if open_ports:
    # 漏洞扫描
    vuln_scanner = VulnerabilityScanner('127.0.0.1', open_ports)
    vuln_scanner.check_weak_services()
    vuln_scanner.check_default_credentials()
    vuln_scanner.check_outdated_software()
    vuln_scanner.generate_report()
```

### 3.3 防火墙与包过滤

```python
import ipaddress
from datetime import datetime, timedelta
from collections import defaultdict

class Firewall:
    """简易防火墙"""
    
    def __init__(self):
        # 规则列表
        self.rules = []
        
        # 黑名单/白名单
        self.blacklist = set()
        self.whitelist = set()
        
        # 连接跟踪（状态防火墙）
        self.connections = defaultdict(list)
        
        # 统计信息
        self.stats = {
            'allowed': 0,
            'blocked': 0,
            'total': 0
        }
    
    def add_rule(self, action, protocol, src_ip, dst_ip, dst_port, priority=100):
        """添加防火墙规则"""
        rule = {
            'action': action,  # 'allow' or 'deny'
            'protocol': protocol,  # 'tcp', 'udp', 'icmp', 'any'
            'src_ip': src_ip,
            'dst_ip': dst_ip,
            'dst_port': dst_port,
            'priority': priority,
            'created_at': datetime.now()
        }
        
        self.rules.append(rule)
        
        # 按优先级排序（数字越小优先级越高）
        self.rules.sort(key=lambda x: x['priority'])
    
    def match_ip(self, ip, pattern):
        """匹配IP地址"""
        if pattern == 'any':
            return True
        
        try:
            if '/' in pattern:
                # CIDR notation
                network = ipaddress.ip_network(pattern, strict=False)
                return ipaddress.ip_address(ip) in network
            else:
                return ip == pattern
        except:
            return False
    
    def match_port(self, port, pattern):
        """匹配端口"""
        if pattern == 'any':
            return True
        
        if isinstance(pattern, int):
            return port == pattern
        
        if isinstance(pattern, str):
            if '-' in pattern:
                # 端口范围
                start, end = map(int, pattern.split('-'))
                return start <= port <= end
        
        return False
    
    def check_packet(self, packet):
        """检查数据包"""
        self.stats['total'] += 1
        
        src_ip = packet['src_ip']
        dst_ip = packet['dst_ip']
        protocol = packet['protocol']
        dst_port = packet.get('dst_port', 'any')
        
        # 检查白名单
        if src_ip in self.whitelist:
            self.stats['allowed'] += 1
            return True, "白名单"
        
        # 检查黑名单
        if src_ip in self.blacklist:
            self.stats['blocked'] += 1
            return False, "黑名单"
        
        # 检查规则
        for rule in self.rules:
            # 匹配协议
            if rule['protocol'] != 'any' and rule['protocol'] != protocol:
                continue
            
            # 匹配源IP
            if not self.match_ip(src_ip, rule['src_ip']):
                continue
            
            # 匹配目标IP
            if not self.match_ip(dst_ip, rule['dst_ip']):
                continue
            
            # 匹配端口
            if not self.match_port(dst_port, rule['dst_port']):
                continue
            
            # 规则匹配
            if rule['action'] == 'allow':
                self.stats['allowed'] += 1
                return True, f"规则匹配 (优先级 {rule['priority']})"
            else:
                self.stats['blocked'] += 1
                return False, f"规则拒绝 (优先级 {rule['priority']})"
        
        # 默认策略：拒绝
        self.stats['blocked'] += 1
        return False, "默认策略拒绝"
    
    def add_to_blacklist(self, ip):
        """添加到黑名单"""
        self.blacklist.add(ip)
    
    def add_to_whitelist(self, ip):
        """添加到白名单"""
        self.whitelist.add(ip)
    
    def get_stats(self):
        """获取统计信息"""
        return self.stats
    
    def list_rules(self):
        """列出所有规则"""
        print("\n🛡️  防火墙规则列表:\n")
        print(f"{'优先级':<8} {'动作':<8} {'协议':<8} {'源IP':<18} {'目标IP':<18} {'端口':<10}")
        print("-" * 80)
        
        for rule in self.rules:
            print(f"{rule['priority']:<8} {rule['action']:<8} {rule['protocol']:<8} "
                  f"{rule['src_ip']:<18} {rule['dst_ip']:<18} {str(rule['dst_port']):<10}")

class IntrusionDetectionSystem:
    """入侵检测系统（IDS）"""
    
    def __init__(self):
        # 检测规则
        self.signatures = []
        
        # 异常检测基线
        self.baseline = {
            'normal_connection_rate': 100,  # 每分钟正常连接数
            'normal_packet_size': 1500,     # 正常包大小
        }
        
        # 告警
        self.alerts = []
    
    def add_signature(self, name, pattern, severity):
        """添加特征签名"""
        signature = {
            'name': name,
            'pattern': pattern,
            'severity': severity
        }
        self.signatures.append(signature)
    
    def analyze_packet(self, packet):
        """分析数据包"""
        alerts = []
        
        # 特征匹配检测
        payload = packet.get('payload', b'')
        
        for sig in self.signatures:
            if sig['pattern'] in payload:
                alert = {
                    'type': 'signature',
                    'name': sig['name'],
                    'severity': sig['severity'],
                    'src_ip': packet['src_ip'],
                    'dst_ip': packet['dst_ip'],
                    'timestamp': datetime.now()
                }
                alerts.append(alert)
                self.alerts.append(alert)
        
        # 异常检测
        if packet.get('size', 0) > self.baseline['normal_packet_size'] * 10:
            alert = {
                'type': 'anomaly',
                'name': '异常大包',
                'severity': 'medium',
                'src_ip': packet['src_ip'],
                'details': f"包大小: {packet['size']} 字节",
                'timestamp': datetime.now()
            }
            alerts.append(alert)
            self.alerts.append(alert)
        
        return alerts
    
    def get_alerts(self, last_n=10):
        """获取最近的告警"""
        return self.alerts[-last_n:]
    
    def generate_alert_report(self):
        """生成告警报告"""
        print("\n🚨 入侵检测报告\n")
        
        severity_count = defaultdict(int)
        
        for alert in self.alerts:
            severity_count[alert['severity']] += 1
        
        print(f"总告警数: {len(self.alerts)}")
        print(f"  High:   {severity_count['high']}")
        print(f"  Medium: {severity_count['medium']}")
        print(f"  Low:    {severity_count['low']}\n")
        
        # 显示最近的告警
        recent_alerts = self.get_alerts(5)
        
        if recent_alerts:
            print("最近告警:")
            for alert in recent_alerts:
                print(f"  [{alert['severity'].upper()}] {alert['name']}")
                print(f"    {alert['src_ip']} -> {alert['dst_ip']}")
                print(f"    时间: {alert['timestamp'].strftime('%Y-%m-%d %H:%M:%S')}\n")

# 测试防火墙和IDS
print("=" * 60)
print("防火墙演示")
print("=" * 60)

firewall = Firewall()

# 添加规则
firewall.add_rule('allow', 'tcp', 'any', 'any', 80, priority=10)  # 允许HTTP
firewall.add_rule('allow', 'tcp', 'any', 'any', 443, priority=10)  # 允许HTTPS
firewall.add_rule('allow', 'tcp', '192.168.1.0/24', 'any', 22, priority=20)  # 内网SSH
firewall.add_rule('deny', 'tcp', 'any', 'any', 23, priority=5)  # 拒绝Telnet
firewall.add_rule('deny', 'tcp', '10.0.0.100', 'any', 'any', priority=1)  # 封禁特定IP

# 显示规则
firewall.list_rules()

# 测试数据包
test_packets = [
    {'src_ip': '192.168.1.100', 'dst_ip': '10.0.0.1', 'protocol': 'tcp', 'dst_port': 80},
    {'src_ip': '192.168.1.100', 'dst_ip': '10.0.0.1', 'protocol': 'tcp', 'dst_port': 443},
    {'src_ip': '192.168.1.100', 'dst_ip': '10.0.0.1', 'protocol': 'tcp', 'dst_port': 22},
    {'src_ip': '1.2.3.4', 'dst_ip': '10.0.0.1', 'protocol': 'tcp', 'dst_port': 22},
    {'src_ip': '10.0.0.100', 'dst_ip': '10.0.0.1', 'protocol': 'tcp', 'dst_port': 80},
    {'src_ip': '8.8.8.8', 'dst_ip': '10.0.0.1', 'protocol': 'tcp', 'dst_port': 23},
]

print("\n测试数据包过滤:\n")

for i, packet in enumerate(test_packets, 1):
    allowed, reason = firewall.check_packet(packet)
    status = "✅ 允许" if allowed else "❌ 拒绝"
    
    print(f"{i}. {packet['src_ip']}:{packet.get('dst_port')} -> "
          f"{packet['dst_ip']} | {status} | {reason}")

# 显示统计
print(f"\n📊 统计信息:")
stats = firewall.get_stats()
print(f"  总计: {stats['total']}")
print(f"  允许: {stats['allowed']}")
print(f"  拒绝: {stats['blocked']}")

# IDS演示
print("\n" + "=" * 60)
print("入侵检测系统（IDS）演示")
print("=" * 60)

ids = IntrusionDetectionSystem()

# 添加攻击特征
ids.add_signature('SQL注入', b"' OR '1'='1", 'high')
ids.add_signature('XSS攻击', b'<script>', 'high')
ids.add_signature('路径遍历', b'../../../', 'medium')

# 测试数据包
attack_packets = [
    {
        'src_ip': '1.2.3.4',
        'dst_ip': '10.0.0.1',
        'protocol': 'tcp',
        'dst_port': 80,
        'payload': b"GET /login?username=admin' OR '1'='1 HTTP/1.1",
        'size': 200
    },
    {
        'src_ip': '5.6.7.8',
        'dst_ip': '10.0.0.1',
        'protocol': 'tcp',
        'dst_port': 80,
        'payload': b'GET /search?q=<script>alert("XSS")</script> HTTP/1.1',
        'size': 150
    },
    {
        'src_ip': '9.10.11.12',
        'dst_ip': '10.0.0.1',
        'protocol': 'tcp',
        'dst_port': 80,
        'payload': b'A' * 50000,  # 异常大包
        'size': 50000
    }
]

print("\n检测攻击流量:\n")

for packet in attack_packets:
    alerts = ids.analyze_packet(packet)
    
    if alerts:
        print(f"🚨 检测到攻击: {packet['src_ip']} -> {packet['dst_ip']}")
        for alert in alerts:
            print(f"  [{alert['severity'].upper()}] {alert['name']}")
    else:
        print(f"✅ 正常流量: {packet['src_ip']} -> {packet['dst_ip']}")

# 生成报告
ids.generate_alert_report()

---

## 📚 学习建议

### 实践项目

1. **Web应用安全扫描器**
   - 实现爬虫发现URL
   - 自动化SQL注入测试
   - XSS漏洞检测

2. **网络入侵检测系统**
   - 实时流量监控
   - 特征匹配引擎
   - 异常行为分析

3. **密码破解工具**
   - 暴力破解引擎
   - 字典生成器
   - Rainbow表构建

4. **安全审计系统**
   - 日志分析
   - 合规性检查
   - 漏洞评估

### 推荐工具

🛠️ **安全工具：**
- **Nmap** - 网络扫描和服务发现
- **Wireshark** - 流量分析和协议调试
- **Burp Suite** - Web安全测试平台
- **Metasploit** - 渗透测试框架
- **OWASP ZAP** - Web应用扫描器
- **Snort/Suricata** - 入侵检测系统
- **John the Ripper** - 密码破解工具

### 认证考试

🏆 **安全认证：**
- **CISSP** - 注册信息系统安全专家
- **CEH** - 注册道德黑客
- **OSCP** - 进攻性安全认证专家
- **CompTIA Security+** - 安全基础认证
- **CISA** - 注册信息系统审计师

### 学习路径

```plain
初级阶段（3-6个月）:
  ├─ 网络基础（TCP/IP、HTTP）
  ├─ 操作系统安全（Linux/Windows）
  ├─ 基础密码学
  └─ Web安全基础（OWASP Top 10）

中级阶段（6-12个月）:
  ├─ 渗透测试方法论
  ├─ 漏洞挖掘技术
  ├─ 逆向工程基础
  └─ 安全编程实践

高级阶段（12个月+）:
  ├─ 高级漏洞研究
  ├─ 恶意软件分析
  ├─ 二进制漏洞利用
  └─ 安全架构设计
```

### 实战平台

🎯 **在线靶场：**
- **Hack The Box** - 真实渗透测试环境
- **TryHackMe** - 互动式安全学习
- **VulnHub** - 漏洞虚拟机
- **PentesterLab** - Web渗透测试
- **PortSwigger Web Security Academy** - 免费Web安全训练

---

> **⚠️ 重要提示**：
> 
> 1. 仅在授权的环境中进行安全测试
> 2. 遵守法律法规和道德规范
> 3. 未经许可的渗透测试是违法行为
> 4. 安全是一个持续的过程，不是一次性的产品
> 5. 保持学习，技术日新月异

---

**本章完**
