# ç½‘ç»œå®‰å…¨ - (ä¸‰)ç½‘ç»œæ”»å‡»ä¸é˜²æŠ¤

ç†è§£ç½‘ç»œæ”»é˜²æŠ€æœ¯ã€‚

---

## 3. ç½‘ç»œæ”»å‡»ä¸é˜²æŠ¤

### 3.1 DDoSé˜²æŠ¤

```python
import time
import threading
from collections import defaultdict, deque

class DDoSProtection:
    def __init__(self):
        # è¯·æ±‚è®¡æ•°å™¨
        self.request_counts = defaultdict(deque)
        self.blocked_ips = set()
        
        # é…ç½®å‚æ•°
        self.rate_limit = 100  # æ¯åˆ†é’Ÿæœ€å¤§è¯·æ±‚æ•°
        self.time_window = 60  # æ—¶é—´çª—å£ï¼ˆç§’ï¼‰
        self.block_duration = 300  # å°ç¦æ—¶é•¿ï¼ˆç§’ï¼‰
        
        # åœ°ç†ä½ç½®å¼‚å¸¸æ£€æµ‹
        self.geo_requests = defaultdict(lambda: defaultdict(int))
        
        # å¯åŠ¨æ¸…ç†çº¿ç¨‹
        self.cleanup_thread = threading.Thread(target=self._cleanup_expired, daemon=True)
        self.cleanup_thread.start()
    
    def is_request_allowed(self, ip_address, user_agent=None, geo_country=None):
        """æ£€æŸ¥è¯·æ±‚æ˜¯å¦è¢«å…è®¸"""
        current_time = time.time()
        
        # æ£€æŸ¥IPæ˜¯å¦è¢«å°ç¦
        if ip_address in self.blocked_ips:
            return False, "IPå·²è¢«å°ç¦"
        
        # é€Ÿç‡é™åˆ¶æ£€æŸ¥
        if not self._check_rate_limit(ip_address, current_time):
            self.blocked_ips.add(ip_address)
            # è®¾ç½®è§£å°å®šæ—¶å™¨
            threading.Timer(self.block_duration, 
                          lambda: self.blocked_ips.discard(ip_address)).start()
            return False, "è¯·æ±‚é¢‘ç‡è¿‡é«˜ï¼ŒIPå·²è¢«å°ç¦"
        
        # User-Agentæ£€æŸ¥
        if user_agent and self._is_suspicious_user_agent(user_agent):
            return False, "å¯ç–‘çš„User-Agent"
        
        # åœ°ç†ä½ç½®å¼‚å¸¸æ£€æŸ¥
        if geo_country and self._is_geo_anomaly(ip_address, geo_country):
            return False, "åœ°ç†ä½ç½®å¼‚å¸¸"
        
        return True, "è¯·æ±‚å…è®¸"
    
    def _check_rate_limit(self, ip_address, current_time):
        """æ£€æŸ¥é€Ÿç‡é™åˆ¶"""
        requests = self.request_counts[ip_address]
        
        # ç§»é™¤è¿‡æœŸè¯·æ±‚
        while requests and current_time - requests[0] > self.time_window:
            requests.popleft()
        
        # æ·»åŠ å½“å‰è¯·æ±‚
        requests.append(current_time)
        
        # æ£€æŸ¥æ˜¯å¦è¶…è¿‡é™åˆ¶
        return len(requests) <= self.rate_limit
    
    def _is_suspicious_user_agent(self, user_agent):
        """æ£€æŸ¥å¯ç–‘çš„User-Agent"""
        suspicious_patterns = [
            'bot', 'crawler', 'spider', 'scraper',
            'python-requests', 'curl', 'wget'
        ]
        
        user_agent_lower = user_agent.lower()
        return any(pattern in user_agent_lower for pattern in suspicious_patterns)
    
    def _is_geo_anomaly(self, ip_address, country):
        """æ£€æŸ¥åœ°ç†ä½ç½®å¼‚å¸¸"""
        # è®°å½•IPçš„åœ°ç†ä½ç½®
        self.geo_requests[ip_address][country] += 1
        
        # å¦‚æœåŒä¸€IPæ¥è‡ªå¤šä¸ªå›½å®¶ï¼Œå¯èƒ½æ˜¯ä»£ç†
        countries = list(self.geo_requests[ip_address].keys())
        if len(countries) > 3:  # è¶…è¿‡3ä¸ªå›½å®¶
            return True
        
        return False
    
    def _cleanup_expired(self):
        """æ¸…ç†è¿‡æœŸæ•°æ®"""
        while True:
            time.sleep(60)  # æ¯åˆ†é’Ÿæ¸…ç†ä¸€æ¬¡
            current_time = time.time()
            
            # æ¸…ç†è¿‡æœŸçš„è¯·æ±‚è®°å½•
            for ip in list(self.request_counts.keys()):
                requests = self.request_counts[ip]
                while requests and current_time - requests[0] > self.time_window:
                    requests.popleft()
                
                # å¦‚æœé˜Ÿåˆ—ä¸ºç©ºï¼Œåˆ é™¤è®°å½•
                if not requests:
                    del self.request_counts[ip]

class LoadBalancer:
    def __init__(self, servers):
        self.servers = servers
        self.current_index = 0
        self.server_health = {server: True for server in servers}
    
    def get_server(self):
        """è·å–å¯ç”¨æœåŠ¡å™¨"""
        # ç®€å•è½®è¯¢
        attempts = 0
        while attempts < len(self.servers):
            server = self.servers[self.current_index]
            self.current_index = (self.current_index + 1) % len(self.servers)
            
            if self.server_health[server]:
                return server
            
            attempts += 1
        
        return None  # æ‰€æœ‰æœåŠ¡å™¨éƒ½ä¸å¯ç”¨
    
    def mark_server_down(self, server):
        """æ ‡è®°æœåŠ¡å™¨ä¸‹çº¿"""
        self.server_health[server] = False
        print(f"ğŸš¨ æœåŠ¡å™¨ {server} æ ‡è®°ä¸ºä¸‹çº¿")
    
    def mark_server_up(self, server):
        """æ ‡è®°æœåŠ¡å™¨ä¸Šçº¿"""
        self.server_health[server] = True
        print(f"âœ… æœåŠ¡å™¨ {server} æ¢å¤ä¸Šçº¿")

# æµ‹è¯•DDoSé˜²æŠ¤
ddos_protection = DDoSProtection()
load_balancer = LoadBalancer(['server1', 'server2', 'server3'])

print("ğŸ§ª DDoSé˜²æŠ¤æµ‹è¯•:")

# æ¨¡æ‹Ÿæ­£å¸¸è¯·æ±‚
for i in range(5):
    allowed, reason = ddos_protection.is_request_allowed(
        "192.168.1.100", 
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
    )
    print(f"æ­£å¸¸è¯·æ±‚ {i+1}: {allowed} - {reason}")

# æ¨¡æ‹Ÿæ”»å‡»è¯·æ±‚
print("\nğŸš¨ æ¨¡æ‹ŸDDoSæ”»å‡»:")
for i in range(105):  # è¶…è¿‡é€Ÿç‡é™åˆ¶
    allowed, reason = ddos_protection.is_request_allowed("192.168.1.200")
    if not allowed:
        print(f"æ”»å‡»è¯·æ±‚ {i+1}: {allowed} - {reason}")
        break

# æ¨¡æ‹Ÿå¯ç–‘User-Agent
allowed, reason = ddos_protection.is_request_allowed(
    "192.168.1.300", 
    "python-requests/2.25.1"
)
print(f"å¯ç–‘UA: {allowed} - {reason}")

# è´Ÿè½½å‡è¡¡æµ‹è¯•
print(f"\nâš–ï¸  è´Ÿè½½å‡è¡¡:")
for i in range(5):
    server = load_balancer.get_server()
    print(f"è¯·æ±‚ {i+1} -> {server}")
```

### 3.2 ç«¯å£æ‰«æä¸æ¼æ´æ£€æµ‹

```python
import socket
import threading
from queue import Queue
from datetime import datetime

class PortScanner:
    """ç«¯å£æ‰«æå™¨"""
    
    def __init__(self, target, timeout=1):
        self.target = target
        self.timeout = timeout
        self.open_ports = []
        self.queue = Queue()
        
        # å¸¸è§ç«¯å£åŠæœåŠ¡
        self.common_ports = {
            21: 'FTP',
            22: 'SSH',
            23: 'Telnet',
            25: 'SMTP',
            53: 'DNS',
            80: 'HTTP',
            110: 'POP3',
            143: 'IMAP',
            443: 'HTTPS',
            445: 'SMB',
            3306: 'MySQL',
            3389: 'RDP',
            5432: 'PostgreSQL',
            6379: 'Redis',
            8080: 'HTTP-Alt',
            27017: 'MongoDB'
        }
    
    def scan_port(self, port):
        """æ‰«æå•ä¸ªç«¯å£"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(self.timeout)
            
            result = sock.connect_ex((self.target, port))
            
            if result == 0:
                service = self.common_ports.get(port, 'Unknown')
                
                # å°è¯•è·å–bannerï¼ˆæœåŠ¡æŒ‡çº¹ï¼‰
                banner = self.grab_banner(sock, port)
                
                self.open_ports.append({
                    'port': port,
                    'service': service,
                    'banner': banner
                })
            
            sock.close()
        
        except Exception:
            pass
    
    def grab_banner(self, sock, port):
        """è·å–æœåŠ¡banner"""
        try:
            # å¯¹æŸäº›æœåŠ¡å‘é€æ¢æµ‹è¯·æ±‚
            if port in [80, 8080]:
                sock.send(b'GET / HTTP/1.0\r\n\r\n')
            elif port == 22:
                pass  # SSHä¼šä¸»åŠ¨å‘é€banner
            elif port in [21, 25, 110, 143]:
                pass  # è¿™äº›æœåŠ¡ä¼šè‡ªåŠ¨å‘é€æ¬¢è¿ä¿¡æ¯
            
            banner = sock.recv(1024).decode('utf-8', errors='ignore').strip()
            return banner[:100]  # é™åˆ¶é•¿åº¦
        except:
            return None
    
    def worker(self):
        """å·¥ä½œçº¿ç¨‹"""
        while not self.queue.empty():
            port = self.queue.get()
            self.scan_port(port)
            self.queue.task_done()
    
    def scan_range(self, start_port=1, end_port=1024, num_threads=100):
        """æ‰«æç«¯å£èŒƒå›´"""
        print(f"ğŸ” å¼€å§‹æ‰«æ {self.target}")
        print(f"ç«¯å£èŒƒå›´: {start_port}-{end_port}")
        print(f"çº¿ç¨‹æ•°: {num_threads}\n")
        
        start_time = datetime.now()
        
        # å°†ç«¯å£æ”¾å…¥é˜Ÿåˆ—
        for port in range(start_port, end_port + 1):
            self.queue.put(port)
        
        # åˆ›å»ºçº¿ç¨‹
        threads = []
        for _ in range(num_threads):
            thread = threading.Thread(target=self.worker)
            thread.daemon = True
            thread.start()
            threads.append(thread)
        
        # ç­‰å¾…å®Œæˆ
        self.queue.join()
        
        end_time = datetime.now()
        elapsed = end_time - start_time
        
        # æ˜¾ç¤ºç»“æœ
        print(f"âœ… æ‰«æå®Œæˆï¼Œè€—æ—¶: {elapsed}")
        print(f"\nå‘ç° {len(self.open_ports)} ä¸ªå¼€æ”¾ç«¯å£:\n")
        
        for port_info in sorted(self.open_ports, key=lambda x: x['port']):
            print(f"  ç«¯å£ {port_info['port']:5d} | {port_info['service']:15s} | ", end='')
            if port_info['banner']:
                print(f"{port_info['banner'][:50]}")
            else:
                print("æ— banner")
        
        return self.open_ports

class VulnerabilityScanner:
    """æ¼æ´æ‰«æå™¨ï¼ˆç®€åŒ–ç‰ˆï¼‰"""
    
    def __init__(self, target, open_ports):
        self.target = target
        self.open_ports = open_ports
        self.vulnerabilities = []
    
    def check_weak_services(self):
        """æ£€æŸ¥ä¸å®‰å…¨çš„æœåŠ¡"""
        vulnerable_services = {
            21: ('FTP', 'æœªåŠ å¯†çš„æ–‡ä»¶ä¼ è¾“åè®®'),
            23: ('Telnet', 'æœªåŠ å¯†çš„è¿œç¨‹ç™»å½•'),
            80: ('HTTP', 'æœªåŠ å¯†çš„WebæœåŠ¡'),
            3306: ('MySQL', 'æ•°æ®åº“ç«¯å£æš´éœ²'),
            6379: ('Redis', 'é»˜è®¤æ— è®¤è¯çš„ç¼“å­˜æœåŠ¡'),
            27017: ('MongoDB', 'é»˜è®¤æ— è®¤è¯çš„æ•°æ®åº“')
        }
        
        print("\nğŸ” æ£€æŸ¥ä¸å®‰å…¨çš„æœåŠ¡:")
        
        for port_info in self.open_ports:
            port = port_info['port']
            
            if port in vulnerable_services:
                service, risk = vulnerable_services[port]
                
                vuln = {
                    'type': 'ä¸å®‰å…¨çš„æœåŠ¡',
                    'port': port,
                    'service': service,
                    'severity': 'Medium' if port in [21, 23] else 'Low',
                    'description': risk
                }
                
                self.vulnerabilities.append(vuln)
                
                print(f"  âš ï¸  [{vuln['severity']}] ç«¯å£ {port}: {risk}")
    
    def check_default_credentials(self):
        """æ£€æŸ¥é»˜è®¤å‡­æ®ï¼ˆæ¨¡æ‹Ÿï¼‰"""
        print("\nğŸ” æ£€æŸ¥é»˜è®¤å‡­æ®:")
        
        # å¸¸è§çš„é»˜è®¤å‡­æ®
        default_creds = {
            22: [('root', 'root'), ('admin', 'admin')],
            3306: [('root', ''), ('root', 'root')],
            3389: [('Administrator', 'admin'), ('Admin', '123456')]
        }
        
        for port_info in self.open_ports:
            port = port_info['port']
            
            if port in default_creds:
                print(f"  âš ï¸  ç«¯å£ {port} ({port_info['service']}): å»ºè®®æ£€æŸ¥æ˜¯å¦ä½¿ç”¨é»˜è®¤å¯†ç ")
    
    def check_outdated_software(self):
        """æ£€æŸ¥è¿‡æ—¶çš„è½¯ä»¶ç‰ˆæœ¬"""
        print("\nğŸ”„ æ£€æŸ¥è½¯ä»¶ç‰ˆæœ¬:")
        
        for port_info in self.open_ports:
            banner = port_info.get('banner', '')
            
            if banner:
                # æ£€æŸ¥å·²çŸ¥çš„è¿‡æ—¶ç‰ˆæœ¬ï¼ˆç®€åŒ–ï¼‰
                if 'Apache/2.2' in banner:
                    print(f"  âš ï¸  [High] ç«¯å£ {port_info['port']}: Apache 2.2 ç‰ˆæœ¬è¿‡æ—§")
                elif 'OpenSSH' in banner and '5.' in banner:
                    print(f"  âš ï¸  [Medium] ç«¯å£ {port_info['port']}: OpenSSH ç‰ˆæœ¬è¿‡æ—§")
    
    def generate_report(self):
        """ç”Ÿæˆæ¼æ´æŠ¥å‘Š"""
        print("\n" + "=" * 60)
        print("ğŸ“Š æ¼æ´æ‰«ææŠ¥å‘Š")
        print("=" * 60)
        
        print(f"\nç›®æ ‡: {self.target}")
        print(f"å¼€æ”¾ç«¯å£æ•°: {len(self.open_ports)}")
        print(f"å‘ç°æ¼æ´æ•°: {len(self.vulnerabilities)}\n")
        
        # æŒ‰ä¸¥é‡ç¨‹åº¦åˆ†ç±»
        severity_count = {'High': 0, 'Medium': 0, 'Low': 0}
        
        for vuln in self.vulnerabilities:
            severity_count[vuln['severity']] += 1
        
        print("ä¸¥é‡ç¨‹åº¦ç»Ÿè®¡:")
        print(f"  ğŸ”´ High:   {severity_count['High']}")
        print(f"  ğŸŸ¡ Medium: {severity_count['Medium']}")
        print(f"  ğŸŸ¢ Low:    {severity_count['Low']}")
        
        # ä¿®å¤å»ºè®®
        print("\nä¿®å¤å»ºè®®:")
        print("  1. å…³é—­ä¸å¿…è¦çš„ç«¯å£å’ŒæœåŠ¡")
        print("  2. æ›´æ–°è½¯ä»¶åˆ°æœ€æ–°ç‰ˆæœ¬")
        print("  3. ä¿®æ”¹é»˜è®¤å¯†ç ")
        print("  4. å¯ç”¨é˜²ç«å¢™å’Œè®¿é—®æ§åˆ¶")
        print("  5. ä½¿ç”¨åŠ å¯†åè®®ï¼ˆSSHä»£æ›¿Telnetï¼ŒHTTPSä»£æ›¿HTTPï¼‰")

# æµ‹è¯•ï¼ˆä»…ç”¨äºæ¼”ç¤ºï¼Œå®é™…ä½¿ç”¨éœ€è°¨æ…ï¼‰
print("âš ï¸  ä»¥ä¸‹æ¼”ç¤ºä»…ç”¨äºæœ¬åœ°æµ‹è¯•å’Œæ•™è‚²ç›®çš„\n")
print("=" * 60)
print("ç«¯å£æ‰«ææ¼”ç¤º")
print("=" * 60)

# æ‰«ææœ¬åœ°ä¸»æœº
scanner = PortScanner('127.0.0.1', timeout=0.5)
open_ports = scanner.scan_range(start_port=20, end_port=100, num_threads=50)

if open_ports:
    # æ¼æ´æ‰«æ
    vuln_scanner = VulnerabilityScanner('127.0.0.1', open_ports)
    vuln_scanner.check_weak_services()
    vuln_scanner.check_default_credentials()
    vuln_scanner.check_outdated_software()
    vuln_scanner.generate_report()
```

### 3.3 é˜²ç«å¢™ä¸åŒ…è¿‡æ»¤

```python
import ipaddress
from datetime import datetime, timedelta
from collections import defaultdict

class Firewall:
    """ç®€æ˜“é˜²ç«å¢™"""
    
    def __init__(self):
        # è§„åˆ™åˆ—è¡¨
        self.rules = []
        
        # é»‘åå•/ç™½åå•
        self.blacklist = set()
        self.whitelist = set()
        
        # è¿æ¥è·Ÿè¸ªï¼ˆçŠ¶æ€é˜²ç«å¢™ï¼‰
        self.connections = defaultdict(list)
        
        # ç»Ÿè®¡ä¿¡æ¯
        self.stats = {
            'allowed': 0,
            'blocked': 0,
            'total': 0
        }
    
    def add_rule(self, action, protocol, src_ip, dst_ip, dst_port, priority=100):
        """æ·»åŠ é˜²ç«å¢™è§„åˆ™"""
        rule = {
            'action': action,  # 'allow' or 'deny'
            'protocol': protocol,  # 'tcp', 'udp', 'icmp', 'any'
            'src_ip': src_ip,
            'dst_ip': dst_ip,
            'dst_port': dst_port,
            'priority': priority,
            'created_at': datetime.now()
        }
        
        self.rules.append(rule)
        
        # æŒ‰ä¼˜å…ˆçº§æ’åºï¼ˆæ•°å­—è¶Šå°ä¼˜å…ˆçº§è¶Šé«˜ï¼‰
        self.rules.sort(key=lambda x: x['priority'])
    
    def match_ip(self, ip, pattern):
        """åŒ¹é…IPåœ°å€"""
        if pattern == 'any':
            return True
        
        try:
            if '/' in pattern:
                # CIDR notation
                network = ipaddress.ip_network(pattern, strict=False)
                return ipaddress.ip_address(ip) in network
            else:
                return ip == pattern
        except:
            return False
    
    def match_port(self, port, pattern):
        """åŒ¹é…ç«¯å£"""
        if pattern == 'any':
            return True
        
        if isinstance(pattern, int):
            return port == pattern
        
        if isinstance(pattern, str):
            if '-' in pattern:
                # ç«¯å£èŒƒå›´
                start, end = map(int, pattern.split('-'))
                return start <= port <= end
        
        return False
    
    def check_packet(self, packet):
        """æ£€æŸ¥æ•°æ®åŒ…"""
        self.stats['total'] += 1
        
        src_ip = packet['src_ip']
        dst_ip = packet['dst_ip']
        protocol = packet['protocol']
        dst_port = packet.get('dst_port', 'any')
        
        # æ£€æŸ¥ç™½åå•
        if src_ip in self.whitelist:
            self.stats['allowed'] += 1
            return True, "ç™½åå•"
        
        # æ£€æŸ¥é»‘åå•
        if src_ip in self.blacklist:
            self.stats['blocked'] += 1
            return False, "é»‘åå•"
        
        # æ£€æŸ¥è§„åˆ™
        for rule in self.rules:
            # åŒ¹é…åè®®
            if rule['protocol'] != 'any' and rule['protocol'] != protocol:
                continue
            
            # åŒ¹é…æºIP
            if not self.match_ip(src_ip, rule['src_ip']):
                continue
            
            # åŒ¹é…ç›®æ ‡IP
            if not self.match_ip(dst_ip, rule['dst_ip']):
                continue
            
            # åŒ¹é…ç«¯å£
            if not self.match_port(dst_port, rule['dst_port']):
                continue
            
            # è§„åˆ™åŒ¹é…
            if rule['action'] == 'allow':
                self.stats['allowed'] += 1
                return True, f"è§„åˆ™åŒ¹é… (ä¼˜å…ˆçº§ {rule['priority']})"
            else:
                self.stats['blocked'] += 1
                return False, f"è§„åˆ™æ‹’ç» (ä¼˜å…ˆçº§ {rule['priority']})"
        
        # é»˜è®¤ç­–ç•¥ï¼šæ‹’ç»
        self.stats['blocked'] += 1
        return False, "é»˜è®¤ç­–ç•¥æ‹’ç»"
    
    def add_to_blacklist(self, ip):
        """æ·»åŠ åˆ°é»‘åå•"""
        self.blacklist.add(ip)
    
    def add_to_whitelist(self, ip):
        """æ·»åŠ åˆ°ç™½åå•"""
        self.whitelist.add(ip)
    
    def get_stats(self):
        """è·å–ç»Ÿè®¡ä¿¡æ¯"""
        return self.stats
    
    def list_rules(self):
        """åˆ—å‡ºæ‰€æœ‰è§„åˆ™"""
        print("\nğŸ›¡ï¸  é˜²ç«å¢™è§„åˆ™åˆ—è¡¨:\n")
        print(f"{'ä¼˜å…ˆçº§':<8} {'åŠ¨ä½œ':<8} {'åè®®':<8} {'æºIP':<18} {'ç›®æ ‡IP':<18} {'ç«¯å£':<10}")
        print("-" * 80)
        
        for rule in self.rules:
            print(f"{rule['priority']:<8} {rule['action']:<8} {rule['protocol']:<8} "
                  f"{rule['src_ip']:<18} {rule['dst_ip']:<18} {str(rule['dst_port']):<10}")

class IntrusionDetectionSystem:
    """å…¥ä¾µæ£€æµ‹ç³»ç»Ÿï¼ˆIDSï¼‰"""
    
    def __init__(self):
        # æ£€æµ‹è§„åˆ™
        self.signatures = []
        
        # å¼‚å¸¸æ£€æµ‹åŸºçº¿
        self.baseline = {
            'normal_connection_rate': 100,  # æ¯åˆ†é’Ÿæ­£å¸¸è¿æ¥æ•°
            'normal_packet_size': 1500,     # æ­£å¸¸åŒ…å¤§å°
        }
        
        # å‘Šè­¦
        self.alerts = []
    
    def add_signature(self, name, pattern, severity):
        """æ·»åŠ ç‰¹å¾ç­¾å"""
        signature = {
            'name': name,
            'pattern': pattern,
            'severity': severity
        }
        self.signatures.append(signature)
    
    def analyze_packet(self, packet):
        """åˆ†ææ•°æ®åŒ…"""
        alerts = []
        
        # ç‰¹å¾åŒ¹é…æ£€æµ‹
        payload = packet.get('payload', b'')
        
        for sig in self.signatures:
            if sig['pattern'] in payload:
                alert = {
                    'type': 'signature',
                    'name': sig['name'],
                    'severity': sig['severity'],
                    'src_ip': packet['src_ip'],
                    'dst_ip': packet['dst_ip'],
                    'timestamp': datetime.now()
                }
                alerts.append(alert)
                self.alerts.append(alert)
        
        # å¼‚å¸¸æ£€æµ‹
        if packet.get('size', 0) > self.baseline['normal_packet_size'] * 10:
            alert = {
                'type': 'anomaly',
                'name': 'å¼‚å¸¸å¤§åŒ…',
                'severity': 'medium',
                'src_ip': packet['src_ip'],
                'details': f"åŒ…å¤§å°: {packet['size']} å­—èŠ‚",
                'timestamp': datetime.now()
            }
            alerts.append(alert)
            self.alerts.append(alert)
        
        return alerts
    
    def get_alerts(self, last_n=10):
        """è·å–æœ€è¿‘çš„å‘Šè­¦"""
        return self.alerts[-last_n:]
    
    def generate_alert_report(self):
        """ç”Ÿæˆå‘Šè­¦æŠ¥å‘Š"""
        print("\nğŸš¨ å…¥ä¾µæ£€æµ‹æŠ¥å‘Š\n")
        
        severity_count = defaultdict(int)
        
        for alert in self.alerts:
            severity_count[alert['severity']] += 1
        
        print(f"æ€»å‘Šè­¦æ•°: {len(self.alerts)}")
        print(f"  High:   {severity_count['high']}")
        print(f"  Medium: {severity_count['medium']}")
        print(f"  Low:    {severity_count['low']}\n")
        
        # æ˜¾ç¤ºæœ€è¿‘çš„å‘Šè­¦
        recent_alerts = self.get_alerts(5)
        
        if recent_alerts:
            print("æœ€è¿‘å‘Šè­¦:")
            for alert in recent_alerts:
                print(f"  [{alert['severity'].upper()}] {alert['name']}")
                print(f"    {alert['src_ip']} -> {alert['dst_ip']}")
                print(f"    æ—¶é—´: {alert['timestamp'].strftime('%Y-%m-%d %H:%M:%S')}\n")

# æµ‹è¯•é˜²ç«å¢™å’ŒIDS
print("=" * 60)
print("é˜²ç«å¢™æ¼”ç¤º")
print("=" * 60)

firewall = Firewall()

# æ·»åŠ è§„åˆ™
firewall.add_rule('allow', 'tcp', 'any', 'any', 80, priority=10)  # å…è®¸HTTP
firewall.add_rule('allow', 'tcp', 'any', 'any', 443, priority=10)  # å…è®¸HTTPS
firewall.add_rule('allow', 'tcp', '192.168.1.0/24', 'any', 22, priority=20)  # å†…ç½‘SSH
firewall.add_rule('deny', 'tcp', 'any', 'any', 23, priority=5)  # æ‹’ç»Telnet
firewall.add_rule('deny', 'tcp', '10.0.0.100', 'any', 'any', priority=1)  # å°ç¦ç‰¹å®šIP

# æ˜¾ç¤ºè§„åˆ™
firewall.list_rules()

# æµ‹è¯•æ•°æ®åŒ…
test_packets = [
    {'src_ip': '192.168.1.100', 'dst_ip': '10.0.0.1', 'protocol': 'tcp', 'dst_port': 80},
    {'src_ip': '192.168.1.100', 'dst_ip': '10.0.0.1', 'protocol': 'tcp', 'dst_port': 443},
    {'src_ip': '192.168.1.100', 'dst_ip': '10.0.0.1', 'protocol': 'tcp', 'dst_port': 22},
    {'src_ip': '1.2.3.4', 'dst_ip': '10.0.0.1', 'protocol': 'tcp', 'dst_port': 22},
    {'src_ip': '10.0.0.100', 'dst_ip': '10.0.0.1', 'protocol': 'tcp', 'dst_port': 80},
    {'src_ip': '8.8.8.8', 'dst_ip': '10.0.0.1', 'protocol': 'tcp', 'dst_port': 23},
]

print("\næµ‹è¯•æ•°æ®åŒ…è¿‡æ»¤:\n")

for i, packet in enumerate(test_packets, 1):
    allowed, reason = firewall.check_packet(packet)
    status = "âœ… å…è®¸" if allowed else "âŒ æ‹’ç»"
    
    print(f"{i}. {packet['src_ip']}:{packet.get('dst_port')} -> "
          f"{packet['dst_ip']} | {status} | {reason}")

# æ˜¾ç¤ºç»Ÿè®¡
print(f"\nğŸ“Š ç»Ÿè®¡ä¿¡æ¯:")
stats = firewall.get_stats()
print(f"  æ€»è®¡: {stats['total']}")
print(f"  å…è®¸: {stats['allowed']}")
print(f"  æ‹’ç»: {stats['blocked']}")

# IDSæ¼”ç¤º
print("\n" + "=" * 60)
print("å…¥ä¾µæ£€æµ‹ç³»ç»Ÿï¼ˆIDSï¼‰æ¼”ç¤º")
print("=" * 60)

ids = IntrusionDetectionSystem()

# æ·»åŠ æ”»å‡»ç‰¹å¾
ids.add_signature('SQLæ³¨å…¥', b"' OR '1'='1", 'high')
ids.add_signature('XSSæ”»å‡»', b'<script>', 'high')
ids.add_signature('è·¯å¾„éå†', b'../../../', 'medium')

# æµ‹è¯•æ•°æ®åŒ…
attack_packets = [
    {
        'src_ip': '1.2.3.4',
        'dst_ip': '10.0.0.1',
        'protocol': 'tcp',
        'dst_port': 80,
        'payload': b"GET /login?username=admin' OR '1'='1 HTTP/1.1",
        'size': 200
    },
    {
        'src_ip': '5.6.7.8',
        'dst_ip': '10.0.0.1',
        'protocol': 'tcp',
        'dst_port': 80,
        'payload': b'GET /search?q=<script>alert("XSS")</script> HTTP/1.1',
        'size': 150
    },
    {
        'src_ip': '9.10.11.12',
        'dst_ip': '10.0.0.1',
        'protocol': 'tcp',
        'dst_port': 80,
        'payload': b'A' * 50000,  # å¼‚å¸¸å¤§åŒ…
        'size': 50000
    }
]

print("\næ£€æµ‹æ”»å‡»æµé‡:\n")

for packet in attack_packets:
    alerts = ids.analyze_packet(packet)
    
    if alerts:
        print(f"ğŸš¨ æ£€æµ‹åˆ°æ”»å‡»: {packet['src_ip']} -> {packet['dst_ip']}")
        for alert in alerts:
            print(f"  [{alert['severity'].upper()}] {alert['name']}")
    else:
        print(f"âœ… æ­£å¸¸æµé‡: {packet['src_ip']} -> {packet['dst_ip']}")

# ç”ŸæˆæŠ¥å‘Š
ids.generate_alert_report()

---

## ğŸ“š å­¦ä¹ å»ºè®®

### å®è·µé¡¹ç›®

1. **Webåº”ç”¨å®‰å…¨æ‰«æå™¨**
   - å®ç°çˆ¬è™«å‘ç°URL
   - è‡ªåŠ¨åŒ–SQLæ³¨å…¥æµ‹è¯•
   - XSSæ¼æ´æ£€æµ‹

2. **ç½‘ç»œå…¥ä¾µæ£€æµ‹ç³»ç»Ÿ**
   - å®æ—¶æµé‡ç›‘æ§
   - ç‰¹å¾åŒ¹é…å¼•æ“
   - å¼‚å¸¸è¡Œä¸ºåˆ†æ

3. **å¯†ç ç ´è§£å·¥å…·**
   - æš´åŠ›ç ´è§£å¼•æ“
   - å­—å…¸ç”Ÿæˆå™¨
   - Rainbowè¡¨æ„å»º

4. **å®‰å…¨å®¡è®¡ç³»ç»Ÿ**
   - æ—¥å¿—åˆ†æ
   - åˆè§„æ€§æ£€æŸ¥
   - æ¼æ´è¯„ä¼°

### æ¨èå·¥å…·

ğŸ› ï¸ **å®‰å…¨å·¥å…·ï¼š**
- **Nmap** - ç½‘ç»œæ‰«æå’ŒæœåŠ¡å‘ç°
- **Wireshark** - æµé‡åˆ†æå’Œåè®®è°ƒè¯•
- **Burp Suite** - Webå®‰å…¨æµ‹è¯•å¹³å°
- **Metasploit** - æ¸—é€æµ‹è¯•æ¡†æ¶
- **OWASP ZAP** - Webåº”ç”¨æ‰«æå™¨
- **Snort/Suricata** - å…¥ä¾µæ£€æµ‹ç³»ç»Ÿ
- **John the Ripper** - å¯†ç ç ´è§£å·¥å…·

### è®¤è¯è€ƒè¯•

ğŸ† **å®‰å…¨è®¤è¯ï¼š**
- **CISSP** - æ³¨å†Œä¿¡æ¯ç³»ç»Ÿå®‰å…¨ä¸“å®¶
- **CEH** - æ³¨å†Œé“å¾·é»‘å®¢
- **OSCP** - è¿›æ”»æ€§å®‰å…¨è®¤è¯ä¸“å®¶
- **CompTIA Security+** - å®‰å…¨åŸºç¡€è®¤è¯
- **CISA** - æ³¨å†Œä¿¡æ¯ç³»ç»Ÿå®¡è®¡å¸ˆ

### å­¦ä¹ è·¯å¾„

```plain
åˆçº§é˜¶æ®µï¼ˆ3-6ä¸ªæœˆï¼‰:
  â”œâ”€ ç½‘ç»œåŸºç¡€ï¼ˆTCP/IPã€HTTPï¼‰
  â”œâ”€ æ“ä½œç³»ç»Ÿå®‰å…¨ï¼ˆLinux/Windowsï¼‰
  â”œâ”€ åŸºç¡€å¯†ç å­¦
  â””â”€ Webå®‰å…¨åŸºç¡€ï¼ˆOWASP Top 10ï¼‰

ä¸­çº§é˜¶æ®µï¼ˆ6-12ä¸ªæœˆï¼‰:
  â”œâ”€ æ¸—é€æµ‹è¯•æ–¹æ³•è®º
  â”œâ”€ æ¼æ´æŒ–æ˜æŠ€æœ¯
  â”œâ”€ é€†å‘å·¥ç¨‹åŸºç¡€
  â””â”€ å®‰å…¨ç¼–ç¨‹å®è·µ

é«˜çº§é˜¶æ®µï¼ˆ12ä¸ªæœˆ+ï¼‰:
  â”œâ”€ é«˜çº§æ¼æ´ç ”ç©¶
  â”œâ”€ æ¶æ„è½¯ä»¶åˆ†æ
  â”œâ”€ äºŒè¿›åˆ¶æ¼æ´åˆ©ç”¨
  â””â”€ å®‰å…¨æ¶æ„è®¾è®¡
```

### å®æˆ˜å¹³å°

ğŸ¯ **åœ¨çº¿é¶åœºï¼š**
- **Hack The Box** - çœŸå®æ¸—é€æµ‹è¯•ç¯å¢ƒ
- **TryHackMe** - äº’åŠ¨å¼å®‰å…¨å­¦ä¹ 
- **VulnHub** - æ¼æ´è™šæ‹Ÿæœº
- **PentesterLab** - Webæ¸—é€æµ‹è¯•
- **PortSwigger Web Security Academy** - å…è´¹Webå®‰å…¨è®­ç»ƒ

---

> **âš ï¸ é‡è¦æç¤º**ï¼š
> 
> 1. ä»…åœ¨æˆæƒçš„ç¯å¢ƒä¸­è¿›è¡Œå®‰å…¨æµ‹è¯•
> 2. éµå®ˆæ³•å¾‹æ³•è§„å’Œé“å¾·è§„èŒƒ
> 3. æœªç»è®¸å¯çš„æ¸—é€æµ‹è¯•æ˜¯è¿æ³•è¡Œä¸º
> 4. å®‰å…¨æ˜¯ä¸€ä¸ªæŒç»­çš„è¿‡ç¨‹ï¼Œä¸æ˜¯ä¸€æ¬¡æ€§çš„äº§å“
> 5. ä¿æŒå­¦ä¹ ï¼ŒæŠ€æœ¯æ—¥æ–°æœˆå¼‚

---

**æœ¬ç« å®Œ**
