# 算法设计与分析 - (二)高级分治算法

掌握高级分治策略。

---

## 2. 高级分治算法

### 2.1 快速傅里叶变换（FFT）

**问题：**多项式乘法

$$
C(x) = A(x) \cdot B(x)
$$

**朴素算法：**$O(n^2)$

**FFT算法：**$O(n \log n)$

```python
import numpy as np

def fft(a):
    """
    快速傅里叶变换
    Cooley-Tukey算法
    """
    n = len(a)
    if n == 1:
        return a
    
    # 分治
    even = fft(a[::2])
    odd = fft(a[1::2])
    
    # 合并
    T = [np.exp(-2j * np.pi * k / n) * odd[k] for k in range(n // 2)]
    return [even[k] + T[k] for k in range(n // 2)] + \
           [even[k] - T[k] for k in range(n // 2)]

def poly_multiply_fft(A, B):
    """FFT多项式乘法"""
    n = 1
    while n < len(A) + len(B):
        n <<= 1
    
    # 补零到2的幂次
    A_padded = A + [0] * (n - len(A))
    B_padded = B + [0] * (n - len(B))
    
    # FFT变换
    A_fft = fft(A_padded)
    B_fft = fft(B_padded)
    
    # 点值乘法
    C_fft = [A_fft[i] * B_fft[i] for i in range(n)]
    
    # 逆FFT
    C = fft(C_fft)
    C = [c / n for c in C]  # 归一化
    
    return [int(round(c.real)) for c in C[:len(A) + len(B) - 1]]

# 示例
A = [1, 2, 3]  # 1 + 2x + 3x²
B = [4, 5, 6]  # 4 + 5x + 6x²

C = poly_multiply_fft(A, B)
print(f"结果: {C}")  # [4, 13, 28, 27, 18]
```

### 2.2 Strassen矩阵乘法

**标准算法：**$O(n^3)$

**Strassen算法：**$O(n^{2.807})$

```python
def strassen(A, B):
    """
    Strassen矩阵乘法
    """
    n = len(A)
    
    # 基础情况
    if n == 1:
        return [[A[0][0] * B[0][0]]]
    
    # 分块
    mid = n // 2
    A11 = [row[:mid] for row in A[:mid]]
    A12 = [row[mid:] for row in A[:mid]]
    A21 = [row[:mid] for row in A[mid:]]
    A22 = [row[mid:] for row in A[mid:]]
    
    B11 = [row[:mid] for row in B[:mid]]
    B12 = [row[mid:] for row in B[:mid]]
    B21 = [row[:mid] for row in B[mid:]]
    B22 = [row[mid:] for row in B[mid:]]
    
    # 7次乘法
    def add(X, Y):
        return [[X[i][j] + Y[i][j] for j in range(len(X[0]))] for i in range(len(X))]
    
    def sub(X, Y):
        return [[X[i][j] - Y[i][j] for j in range(len(X[0]))] for i in range(len(X))]
    
    M1 = strassen(add(A11, A22), add(B11, B22))
    M2 = strassen(add(A21, A22), B11)
    M3 = strassen(A11, sub(B12, B22))
    M4 = strassen(A22, sub(B21, B11))
    M5 = strassen(add(A11, A12), B22)
    M6 = strassen(sub(A21, A11), add(B11, B12))
    M7 = strassen(sub(A12, A22), add(B21, B22))
    
    C11 = add(sub(add(M1, M4), M5), M7)
    C12 = add(M3, M5)
    C21 = add(M2, M4)
    C22 = add(sub(add(M1, M3), M2), M6)
    
    # 合并
    C = [[0] * n for _ in range(n)]
    for i in range(mid):
        for j in range(mid):
            C[i][j] = C11[i][j]
            C[i][j+mid] = C12[i][j]
            C[i+mid][j] = C21[i][j]
            C[i+mid][j+mid] = C22[i][j]
    
    return C
```

### 2.3 中位数与选择算法

#### 2.3.1 快速选择算法

```python
import random

def quickselect(arr, k):
    """
    快速选择算法 - 期望O(n)
    找第k小的元素（k从0开始）
    """
    if len(arr) == 1:
        return arr[0]
    
    # 随机选择主元
    pivot = random.choice(arr)
    
    # 三路划分
    lows = [x for x in arr if x < pivot]
    highs = [x for x in arr if x > pivot]
    pivots = [x for x in arr if x == pivot]
    
    if k < len(lows):
        return quickselect(lows, k)
    elif k < len(lows) + len(pivots):
        return pivots[0]
    else:
        return quickselect(highs, k - len(lows) - len(pivots))

# 测试
arr = [3, 2, 1, 5, 4, 6, 8, 7, 9]
print(f"数组: {arr}")
for k in range(len(arr)):
    print(f"第{k+1}小的元素: {quickselect(arr.copy(), k)}")
```

#### 2.3.2 中位数的中位数算法（BFPRT）

```python
def median_of_medians(arr, k):
    """
    BFPRT算法 - 最坏O(n)
    确定性选择算法
    """
    def select(arr, k):
        if len(arr) <= 5:
            return sorted(arr)[k]
        
        # 分成5个一组
        groups = [arr[i:i+5] for i in range(0, len(arr), 5)]
        
        # 每组的中位数
        medians = [sorted(group)[len(group)//2] for group in groups]
        
        # 递归找中位数的中位数
        pivot = select(medians, len(medians)//2)
        
        # 三路划分
        lows = [x for x in arr if x < pivot]
        highs = [x for x in arr if x > pivot]
        pivots = [x for x in arr if x == pivot]
        
        if k < len(lows):
            return select(lows, k)
        elif k < len(lows) + len(pivots):
            return pivot
        else:
            return select(highs, k - len(lows) - len(pivots))
    
    return select(arr, k)

# 测试
arr = [3, 2, 1, 5, 4, 6, 8, 7, 9, 10, 11, 12]
print(f"\n数组: {arr}")
print(f"中位数: {median_of_medians(arr, len(arr)//2)}")
```

### 2.4 分治优化技巧

#### 2.4.1 分治+记忆化

```python
def closest_pair(points):
    """
    最近点对问题 - O(n log n)
    分治算法
    """
    def distance(p1, p2):
        return ((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)**0.5
    
    def brute_force(points):
        """暴力求解小规模问题"""
        min_dist = float('inf')
        n = len(points)
        for i in range(n):
            for j in range(i + 1, n):
                min_dist = min(min_dist, distance(points[i], points[j]))
        return min_dist
    
    def strip_closest(strip, d):
        """在条带中找最近点对"""
        min_dist = d
        strip.sort(key=lambda p: p[1])  # 按y坐标排序
        
        for i in range(len(strip)):
            j = i + 1
            while j < len(strip) and (strip[j][1] - strip[i][1]) < min_dist:
                min_dist = min(min_dist, distance(strip[i], strip[j]))
                j += 1
        
        return min_dist
    
    def closest_pair_rec(px, py):
        """递归求解"""
        n = len(px)
        
        # 基础情况
        if n <= 3:
            return brute_force(px)
        
        # 分治
        mid = n // 2
        midpoint = px[mid]
        
        pyl = [p for p in py if p[0] <= midpoint[0]]
        pyr = [p for p in py if p[0] > midpoint[0]]
        
        dl = closest_pair_rec(px[:mid], pyl)
        dr = closest_pair_rec(px[mid:], pyr)
        
        d = min(dl, dr)
        
        # 合并：检查跨越中线的点对
        strip = [p for p in py if abs(p[0] - midpoint[0]) < d]
        
        return min(d, strip_closest(strip, d))
    
    # 预处理：按x和y坐标排序
    px = sorted(points, key=lambda p: p[0])
    py = sorted(points, key=lambda p: p[1])
    
    return closest_pair_rec(px, py)

# 测试
points = [(2, 3), (12, 30), (40, 50), (5, 1), (12, 10), (3, 4)]
print(f"\n点集: {points}")
print(f"最近点对距离: {closest_pair(points):.2f}")
```

#### 2.4.2 整数乘法（Karatsuba算法）

```python
def karatsuba(x, y):
    """
    Karatsuba算法 - O(n^1.585)
    大整数乘法
    """
    # 基础情况
    if x < 10 or y < 10:
        return x * y
    
    # 计算位数
    n = max(len(str(x)), len(str(y)))
    m = n // 2
    
    # 分割
    high1, low1 = divmod(x, 10**m)
    high2, low2 = divmod(y, 10**m)
    
    # 三次乘法
    z0 = karatsuba(low1, low2)
    z1 = karatsuba(low1 + high1, low2 + high2)
    z2 = karatsuba(high1, high2)
    
    # 合并
    return z2 * 10**(2*m) + (z1 - z2 - z0) * 10**m + z0

# 测试
x = 1234567890
y = 9876543210

print(f"\nKaratsuba算法:")
print(f"{x} × {y}")
print(f"结果: {karatsuba(x, y)}")
print(f"验证: {x * y}")
print(f"相等: {karatsuba(x, y) == x * y}")
```

### 2.5 分治算法复杂度分析

```python
import matplotlib.pyplot as plt
import numpy as np

def analyze_divide_conquer():
    """
    分析不同分治策略的复杂度
    """
    print("=" * 60)
    print("分治算法复杂度分析")
    print("=" * 60)
    
    algorithms = [
        ("归并排序", "T(n) = 2T(n/2) + n", "O(n log n)"),
        ("二分查找", "T(n) = T(n/2) + 1", "O(log n)"),
        ("Strassen", "T(n) = 7T(n/2) + n²", "O(n^2.807)"),
        ("Karatsuba", "T(n) = 3T(n/2) + n", "O(n^1.585)"),
        ("快速幂", "T(n) = T(n/2) + 1", "O(log n)"),
        ("最近点对", "T(n) = 2T(n/2) + n", "O(n log n)"),
    ]
    
    print(f"\n{'算法':<15} {'递推式':<25} {'复杂度':<15}")
    print("-" * 60)
    
    for name, recurrence, complexity in algorithms:
        print(f"{name:<15} {recurrence:<25} {complexity:<15}")
    
    # 可视化对比
    n_values = np.logspace(1, 3, 50)  # 10 到 1000
    
    plt.figure(figsize=(12, 6))
    
    complexities = {
        'O(log n)': n_values * 0 + np.log2(n_values),
        'O(n)': n_values,
        'O(n log n)': n_values * np.log2(n_values),
        'O(n^1.585)': n_values ** 1.585,
        'O(n²)': n_values ** 2,
        'O(n^2.807)': n_values ** 2.807,
    }
    
    for name, values in complexities.items():
        plt.loglog(n_values, values, label=name, linewidth=2)
    
    plt.xlabel('输入规模 n', fontsize=12)
    plt.ylabel('运行时间（对数刻度）', fontsize=12)
    plt.title('分治算法复杂度对比', fontsize=14, fontweight='bold')
    plt.legend(fontsize=10)
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    # plt.savefig('divide_conquer_complexity.png', dpi=300)
    plt.show()

analyze_divide_conquer()
```

### 2.6 分治算法设计模式

```python
def divide_conquer_template(problem, threshold=1):
    """
    分治算法通用模板
    """
    # 1. 基础情况（小规模问题直接求解）
    if problem.size() <= threshold:
        return problem.solve_directly()
    
    # 2. 分解（Divide）
    subproblems = problem.divide()
    
    # 3. 递归求解（Conquer）
    subsolutions = []
    for subproblem in subproblems:
        subsolutions.append(divide_conquer_template(subproblem, threshold))
    
    # 4. 合并（Combine）
    solution = problem.combine(subsolutions)
    
    return solution

# 示例：归并排序的实现
class MergeSortProblem:
    """归并排序问题封装"""
    
    def __init__(self, arr):
        self.arr = arr
    
    def size(self):
        return len(self.arr)
    
    def solve_directly(self):
        return self.arr
    
    def divide(self):
        mid = len(self.arr) // 2
        return [
            MergeSortProblem(self.arr[:mid]),
            MergeSortProblem(self.arr[mid:])
        ]
    
    def combine(self, subsolutions):
        left, right = subsolutions[0], subsolutions[1]
        result = []
        i = j = 0
        
        while i < len(left) and j < len(right):
            if left[i] <= right[j]:
                result.append(left[i])
                i += 1
            else:
                result.append(right[j])
                j += 1
        
        result.extend(left[i:])
        result.extend(right[j:])
        return result

# 测试
arr = [64, 34, 25, 12, 22, 11, 90]
problem = MergeSortProblem(arr)
sorted_arr = divide_conquer_template(problem)
print(f"\n原数组: {arr}")
print(f"排序后: {sorted_arr}")
```

---

**本章完**
