# 算法设计与分析 - (五)字符串算法

掌握字符串处理算法。

---

## 5. 字符串算法

### 5.1 KMP算法

```python
def kmp_search(text, pattern):
    """KMP字符串匹配"""
    # 构建部分匹配表
    def build_lps(p):
        lps = [0] * len(p)
        j = 0
        for i in range(1, len(p)):
            while j > 0 and p[i] != p[j]:
                j = lps[j-1]
            if p[i] == p[j]:
                j += 1
            lps[i] = j
        return lps
    
    lps = build_lps(pattern)
    matches = []
    j = 0
    
    for i in range(len(text)):
        while j > 0 and text[i] != pattern[j]:
            j = lps[j-1]
        
        if text[i] == pattern[j]:
            j += 1
        
        if j == len(pattern):
            matches.append(i - j + 1)
            j = lps[j-1]
    
    return matches

text = "ABABDABACDABABCABAB"
pattern = "ABABCABAB"
print(kmp_search(text, pattern))  # [10]
```

### 5.2 后缀数组

```python
def suffix_array(s):
    """
    O(n log n) 后缀数组构建
    """
    n = len(s)
    sa = list(range(n))
    rank = [ord(c) for c in s]
    k = 1
    
    while k < n:
        # 按(rank[i], rank[i+k])排序
        sa.sort(key=lambda i: (rank[i], rank[i+k] if i+k < n else -1))
        
        # 更新rank
        new_rank = [0] * n
        for i in range(1, n):
            prev = (rank[sa[i-1]], rank[sa[i-1]+k] if sa[i-1]+k < n else -1)
            curr = (rank[sa[i]], rank[sa[i]+k] if sa[i]+k < n else -1)
            new_rank[sa[i]] = new_rank[sa[i-1]] + (prev != curr)
        
        rank = new_rank
        k *= 2
    
    return sa

s = "banana"
sa = suffix_array(s)
print("后缀数组:", sa)
for i in sa:
    print(f"{i}: {s[i:]}")
```

### 5.3 AC自动机

**AC自动机**（Aho-Corasick）是多模式串匹配的经典算法。

```python
from collections import deque

class ACAutomaton:
    """AC自动机"""
    
    def __init__(self):
        self.goto = [{}]  # 转移函数
        self.fail = [0]   # 失配指针
        self.output = [[]]  # 输出函数
    
    def add_pattern(self, pattern, pattern_id):
        """添加模式串"""
        state = 0
        
        for char in pattern:
            if char not in self.goto[state]:
                self.goto[state][char] = len(self.goto)
                self.goto.append({})
                self.fail.append(0)
                self.output.append([])
            
            state = self.goto[state][char]
        
        self.output[state].append(pattern_id)
    
    def build_fail(self):
        """构建失配指针"""
        queue = deque()
        
        # 第一层的失配指针指向根
        for char, state in self.goto[0].items():
            self.fail[state] = 0
            queue.append(state)
        
        # BFS构建失配指针
        while queue:
            current = queue.popleft()
            
            for char, next_state in self.goto[current].items():
                queue.append(next_state)
                
                # 寻找失配指针
                fail_state = self.fail[current]
                while fail_state != 0 and char not in self.goto[fail_state]:
                    fail_state = self.fail[fail_state]
                
                if char in self.goto[fail_state]:
                    self.fail[next_state] = self.goto[fail_state][char]
                else:
                    self.fail[next_state] = 0
                
                # 合并输出
                self.output[next_state].extend(self.output[self.fail[next_state]])
    
    def search(self, text):
        """在文本中搜索所有模式串"""
        matches = []
        state = 0
        
        for i, char in enumerate(text):
            # 失配时沿着失配指针走
            while state != 0 and char not in self.goto[state]:
                state = self.fail[state]
            
            if char in self.goto[state]:
                state = self.goto[state][char]
            
            # 输出匹配
            for pattern_id in self.output[state]:
                matches.append((i, pattern_id))
        
        return matches

# 测试
ac = ACAutomaton()

patterns = ["he", "she", "his", "hers"]
for i, pattern in enumerate(patterns):
    ac.add_pattern(pattern, i)

ac.build_fail()

text = "ushers"
matches = ac.search(text)

print("\nAC自动机多模式匹配:")
print(f"文本: {text}")
print(f"模式串: {patterns}")
print("匹配结果:")
for pos, pattern_id in matches:
    pattern = patterns[pattern_id]
    start = pos - len(pattern) + 1
    print(f"  位置{start}: '{pattern}'")
```

### 5.4 后缀树（Suffix Tree）

```python
class SuffixTreeNode:
    """后缀树节点"""
    
    def __init__(self):
        self.children = {}
        self.start = -1
        self.end = None
        self.suffix_link = None
        self.suffix_index = -1

class SuffixTree:
    """
    后缀树 - Ukkonen算法
    O(n)构建
    """
    
    def __init__(self, text):
        self.text = text + "$"  # 添加终止符
        self.n = len(self.text)
        self.root = SuffixTreeNode()
        self.active_node = self.root
        self.active_edge = -1
        self.active_length = 0
        self.remaining = 0
        self.leaf_end = -1
        
        self.build_tree()
    
    def edge_length(self, node):
        """获取边长度"""
        if node.end is None:
            return self.leaf_end - node.start + 1
        return node.end - node.start + 1
    
    def walk_down(self, node):
        """向下走"""
        length = self.edge_length(node)
        
        if self.active_length >= length:
            self.active_edge += length
            self.active_length -= length
            self.active_node = node
            return True
        
        return False
    
    def extend(self, pos):
        """扩展后缀树"""
        self.leaf_end = pos
        self.remaining += 1
        last_new_node = None
        
        while self.remaining > 0:
            if self.active_length == 0:
                self.active_edge = pos
            
            char = self.text[self.active_edge]
            
            if char not in self.active_node.children:
                # 创建新叶子
                self.active_node.children[char] = SuffixTreeNode()
                self.active_node.children[char].start = pos
                
                if last_new_node:
                    last_new_node.suffix_link = self.active_node
                    last_new_node = None
            else:
                next_node = self.active_node.children[char]
                
                if self.walk_down(next_node):
                    continue
                
                # 检查是否匹配
                if self.text[next_node.start + self.active_length] == self.text[pos]:
                    if last_new_node and self.active_node != self.root:
                        last_new_node.suffix_link = self.active_node
                        last_new_node = None
                    
                    self.active_length += 1
                    break
                
                # 分裂边
                split = SuffixTreeNode()
                split.start = next_node.start
                split.end = next_node.start + self.active_length
                self.active_node.children[char] = split
                
                # 创建新叶子
                split.children[self.text[pos]] = SuffixTreeNode()
                split.children[self.text[pos]].start = pos
                
                # 调整原节点
                next_node.start += self.active_length
                split.children[self.text[next_node.start]] = next_node
                
                if last_new_node:
                    last_new_node.suffix_link = split
                
                last_new_node = split
            
            self.remaining -= 1
            
            if self.active_node == self.root and self.active_length > 0:
                self.active_length -= 1
                self.active_edge = pos - self.remaining + 1
            elif self.active_node != self.root:
                self.active_node = self.active_node.suffix_link or self.root
    
    def build_tree(self):
        """构建后缀树"""
        for i in range(self.n):
            self.extend(i)
    
    def search(self, pattern):
        """搜索模式串"""
        node = self.root
        i = 0
        
        while i < len(pattern):
            char = pattern[i]
            
            if char not in node.children:
                return False
            
            edge_node = node.children[char]
            j = edge_node.start
            end = edge_node.end if edge_node.end else self.leaf_end + 1
            
            while j < end and i < len(pattern):
                if self.text[j] != pattern[i]:
                    return False
                i += 1
                j += 1
            
            node = edge_node
        
        return True

# 测试
text = "banana"
st = SuffixTree(text)

patterns = ["ana", "nan", "apple", "ban"]
print(f"\n后缀树搜索:")
print(f"文本: {text}")

for pattern in patterns:
    found = st.search(pattern)
    print(f"  '{pattern}': {'找到' if found else '未找到'}")
```

### 5.5 Manacher算法（最长回文子串）

```python
def manacher(s):
    """
    Manacher算法 - O(n)
    找最长回文子串
    """
    # 预处理：在每个字符间插入#
    t = '#'.join('^{}$'.format(s))
    n = len(t)
    
    # p[i]: 以i为中心的最长回文半径
    p = [0] * n
    center = 0  # 当前最右回文的中心
    right = 0   # 当前最右回文的右边界
    
    max_len = 0
    max_center = 0
    
    for i in range(1, n - 1):
        # 利用对称性
        if i < right:
            mirror = 2 * center - i
            p[i] = min(right - i, p[mirror])
        
        # 尝试扩展
        while t[i + p[i] + 1] == t[i - p[i] - 1]:
            p[i] += 1
        
        # 更新最右边界
        if i + p[i] > right:
            center = i
            right = i + p[i]
        
        # 更新最长回文
        if p[i] > max_len:
            max_len = p[i]
            max_center = i
    
    # 还原原字符串中的位置
    start = (max_center - max_len) // 2
    return s[start:start + max_len]

# 测试
test_strings = [
    "babad",
    "cbbd",
    "racecar",
    "abcdcba",
    "banana"
]

print("\nManacher算法 - 最长回文子串:")
for s in test_strings:
    lps = manacher(s)
    print(f"  '{s}' -> '{lps}'")
```

### 5.6 Z算法

```python
def z_algorithm(s):
    """
    Z算法 - O(n)
    z[i]: s[i:]与s的最长公共前缀长度
    """
    n = len(s)
    z = [0] * n
    z[0] = n
    
    l, r = 0, 0
    
    for i in range(1, n):
        if i > r:
            # 暴力扩展
            l = r = i
            while r < n and s[r - l] == s[r]:
                r += 1
            z[i] = r - l
            r -= 1
        else:
            # 利用已知信息
            k = i - l
            
            if z[k] < r - i + 1:
                z[i] = z[k]
            else:
                l = i
                while r < n and s[r - l] == s[r]:
                    r += 1
                z[i] = r - l
                r -= 1
    
    return z

def z_search(text, pattern):
    """使用Z算法进行模式匹配"""
    s = pattern + "$" + text
    z = z_algorithm(s)
    
    matches = []
    pattern_len = len(pattern)
    
    for i in range(pattern_len + 1, len(s)):
        if z[i] == pattern_len:
            matches.append(i - pattern_len - 1)
    
    return matches

# 测试
text = "ababcababa"
pattern = "aba"

print(f"\nZ算法模式匹配:")
print(f"文本: {text}")
print(f"模式: {pattern}")

matches = z_search(text, pattern)
print(f"匹配位置: {matches}")
```

### 5.7 字符串哈希

```python
class StringHash:
    """
    字符串哈希（Rabin-Karp）
    """
    
    def __init__(self, s, base=131, mod=10**9+7):
        self.s = s
        self.n = len(s)
        self.base = base
        self.mod = mod
        
        # 预计算哈希值和幂
        self.hash_val = [0] * (self.n + 1)
        self.pow_base = [1] * (self.n + 1)
        
        for i in range(self.n):
            self.hash_val[i + 1] = (self.hash_val[i] * base + ord(s[i])) % mod
            self.pow_base[i + 1] = (self.pow_base[i] * base) % mod
    
    def get_hash(self, l, r):
        """
        获取子串s[l:r+1]的哈希值
        """
        h = (self.hash_val[r + 1] - self.hash_val[l] * self.pow_base[r - l + 1]) % self.mod
        return (h + self.mod) % self.mod
    
    def compare(self, l1, r1, l2, r2):
        """
        比较两个子串是否相等
        """
        return self.get_hash(l1, r1) == self.get_hash(l2, r2)

# 测试
s = "abracadabra"
sh = StringHash(s)

print(f"\n字符串哈希:")
print(f"字符串: {s}")

# 查找重复子串
substrings = {}
for length in range(1, len(s)):
    for i in range(len(s) - length + 1):
        h = sh.get_hash(i, i + length - 1)
        
        if h in substrings:
            print(f"重复子串: '{s[i:i+length]}' 出现在位置 {substrings[h]} 和 {i}")
        else:
            substrings[h] = i
```

### 5.8 字符串算法总结

```python
def string_algorithms_summary():
    """
    字符串算法总结
    """
    print("=" * 70)
    print("字符串算法总结")
    print("=" * 70)
    
    algorithms = [
        ("KMP", "O(n+m)", "单模式匹配", "失配函数"),
        ("AC自动机", "O(n+m+z)", "多模式匹配", "Trie+失配指针"),
        ("后缀数组", "O(n log n)", "子串问题", "排序+倍增"),
        ("后缀树", "O(n)", "子串问题", "Ukkonen算法"),
        ("Manacher", "O(n)", "最长回文", "中心扩展+对称性"),
        ("Z算法", "O(n)", "前缀匹配", "Z函数"),
        ("字符串哈希", "O(n)", "子串比较", "Rabin-Karp"),
    ]
    
    print(f"\n{'算法':<15} {'时间复杂度':<15} {'应用':<20} {'核心思想':<15}")
    print("-" * 70)
    
    for name, complexity, application, idea in algorithms:
        print(f"{name:<15} {complexity:<15} {application:<20} {idea:<15}")
    
    print("\n" + "=" * 70)
    print("算法选择建议")
    print("=" * 70)
    print("""
1. 单模式匹配：
   - KMP: 通用，稳定
   - Z算法: 实现简单
   - 字符串哈希: 常数小

2. 多模式匹配：
   - AC自动机: 标准解法
   - 后缀自动机: 更强大

3. 子串问题：
   - 后缀数组: 实现简单
   - 后缀树: 功能强大

4. 回文问题：
   - Manacher: 最长回文子串
   - 字符串哈希: 判断回文

5. 在线查询：
   - 字符串哈希: O(1)查询
   - 后缀树: 复杂查询
    """)

string_algorithms_summary()
```

---

**本章完**
