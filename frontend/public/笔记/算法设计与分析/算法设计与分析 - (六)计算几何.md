# 算法设计与分析 - (六)计算几何

学习计算几何基础。

---

## 6. 计算几何

### 6.1 凸包算法

```python
def convex_hull(points):
    """
    Andrew算法求凸包
    """
    points = sorted(set(points))
    
    def cross(O, A, B):
        return (A[0] - O[0]) * (B[1] - O[1]) - (A[1] - O[1]) * (B[0] - O[0])
    
    # 下凸包
    lower = []
    for p in points:
        while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0:
            lower.pop()
        lower.append(p)
    
    # 上凸包
    upper = []
    for p in reversed(points):
        while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0:
            upper.pop()
        upper.append(p)
    
    return lower[:-1] + upper[:-1]

points = [(0,0), (1,1), (2,2), (0,2), (2,0), (1,0), (1,2)]
hull = convex_hull(points)
print(f"凸包: {hull}")
```

### 6.2 线段相交

#### 6.2.1 两线段相交判断

```python
class Point:
    """点类"""
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __repr__(self):
        return f"({self.x}, {self.y})"

class Segment:
    """线段类"""
    def __init__(self, p1, p2):
        self.p1 = p1
        self.p2 = p2

def cross_product(o, a, b):
    """
    叉积：判断b相对于向量oa的方向
    > 0: 左侧
    < 0: 右侧
    = 0: 共线
    """
    return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x)

def on_segment(p, q, r):
    """判断点q是否在线段pr上（假设已知共线）"""
    return (min(p.x, r.x) <= q.x <= max(p.x, r.x) and
            min(p.y, r.y) <= q.y <= max(p.y, r.y))

def segments_intersect(seg1, seg2):
    """
    判断两线段是否相交
    """
    p1, q1 = seg1.p1, seg1.p2
    p2, q2 = seg2.p1, seg2.p2
    
    d1 = cross_product(p2, q2, p1)
    d2 = cross_product(p2, q2, q1)
    d3 = cross_product(p1, q1, p2)
    d4 = cross_product(p1, q1, q2)
    
    # 一般情况：跨立
    if ((d1 > 0 and d2 < 0) or (d1 < 0 and d2 > 0)) and \
       ((d3 > 0 and d4 < 0) or (d3 < 0 and d4 > 0)):
        return True
    
    # 特殊情况：端点在另一线段上
    if d1 == 0 and on_segment(p2, p1, q2):
        return True
    if d2 == 0 and on_segment(p2, q1, q2):
        return True
    if d3 == 0 and on_segment(p1, p2, q1):
        return True
    if d4 == 0 and on_segment(p1, q2, q1):
        return True
    
    return False

# 测试
seg1 = Segment(Point(0, 0), Point(4, 4))
seg2 = Segment(Point(0, 4), Point(4, 0))
seg3 = Segment(Point(5, 5), Point(6, 6))

print("\n线段相交判断:")
print(f"seg1: {seg1.p1} - {seg1.p2}")
print(f"seg2: {seg2.p1} - {seg2.p2}")
print(f"seg1与seg2相交: {segments_intersect(seg1, seg2)}")

print(f"\nseg3: {seg3.p1} - {seg3.p2}")
print(f"seg1与seg3相交: {segments_intersect(seg1, seg3)}")
```

#### 6.2.2 扫描线算法（所有线段相交）

```python
def find_all_intersections(segments):
    """
    扫描线算法找所有相交线段对
    """
    events = []
    
    # 创建事件点
    for i, seg in enumerate(segments):
        p1, p2 = seg.p1, seg.p2
        if p1.x > p2.x or (p1.x == p2.x and p1.y > p2.y):
            p1, p2 = p2, p1
        
        events.append((p1.x, 0, i))  # 左端点
        events.append((p2.x, 1, i))  # 右端点
    
    events.sort()
    
    active = set()
    intersections = []
    
    for x, event_type, seg_id in events:
        if event_type == 0:  # 左端点
            # 检查与活动集中的线段是否相交
            for other_id in active:
                if segments_intersect(segments[seg_id], segments[other_id]):
                    intersections.append((seg_id, other_id))
            
            active.add(seg_id)
        else:  # 右端点
            active.discard(seg_id)
    
    return intersections

# 测试
segments = [
    Segment(Point(0, 0), Point(4, 4)),
    Segment(Point(0, 4), Point(4, 0)),
    Segment(Point(1, 1), Point(3, 3)),
    Segment(Point(5, 0), Point(5, 4))
]

intersections = find_all_intersections(segments)
print(f"\n相交线段对: {len(intersections)}")
for i, j in intersections:
    print(f"  线段{i}与线段{j}相交")
```

### 6.3 最近点对问题

```python
def closest_pair_of_points(points):
    """
    最近点对 - 分治算法 O(n log n)
    """
    def distance(p1, p2):
        return ((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)**0.5
    
    def brute_force(points):
        """暴力求解"""
        min_dist = float('inf')
        n = len(points)
        pair = None
        
        for i in range(n):
            for j in range(i + 1, n):
                d = distance(points[i], points[j])
                if d < min_dist:
                    min_dist = d
                    pair = (points[i], points[j])
        
        return min_dist, pair
    
    def strip_closest(strip, d):
        """在条带中找最近点对"""
        min_dist = d
        pair = None
        strip.sort(key=lambda p: p[1])
        
        for i in range(len(strip)):
            j = i + 1
            while j < len(strip) and (strip[j][1] - strip[i][1]) < min_dist:
                dist = distance(strip[i], strip[j])
                if dist < min_dist:
                    min_dist = dist
                    pair = (strip[i], strip[j])
                j += 1
        
        return min_dist, pair
    
    def closest_pair_rec(px, py):
        """递归求解"""
        n = len(px)
        
        if n <= 3:
            return brute_force(px)
        
        # 分治
        mid = n // 2
        midpoint = px[mid]
        
        pyl = [p for p in py if p[0] <= midpoint[0]]
        pyr = [p for p in py if p[0] > midpoint[0]]
        
        dl, pairl = closest_pair_rec(px[:mid], pyl)
        dr, pairr = closest_pair_rec(px[mid:], pyr)
        
        if dl < dr:
            d = dl
            pair = pairl
        else:
            d = dr
            pair = pairr
        
        # 检查跨越中线的点对
        strip = [p for p in py if abs(p[0] - midpoint[0]) < d]
        ds, pairs = strip_closest(strip, d)
        
        if ds < d:
            return ds, pairs
        return d, pair
    
    # 预处理
    px = sorted(points, key=lambda p: p[0])
    py = sorted(points, key=lambda p: p[1])
    
    return closest_pair_rec(px, py)

# 测试
points = [
    (2, 3), (12, 30), (40, 50), (5, 1),
    (12, 10), (3, 4), (20, 25), (30, 15)
]

dist, pair = closest_pair_of_points(points)
print(f"\n最近点对:")
print(f"  点对: {pair}")
print(f"  距离: {dist:.2f}")
```

### 6.4 旋转卡壳

**旋转卡壳**用于求凸包的各种几何性质。

```python
def rotating_calipers(hull):
    """
    旋转卡壳算法
    求凸包直径（最远点对距离）
    """
    def distance_sq(p1, p2):
        return (p1[0] - p2[0])**2 + (p1[1] - p2[1])**2
    
    def cross(o, a, b):
        return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])
    
    n = len(hull)
    if n <= 2:
        if n == 2:
            return distance_sq(hull[0], hull[1])**0.5
        return 0
    
    max_dist_sq = 0
    
    # 旋转卡壳
    j = 1
    for i in range(n):
        # 找对踵点
        while True:
            next_j = (j + 1) % n
            # 比较三角形面积（叉积）
            if cross(hull[i], hull[(i+1)%n], hull[next_j]) > \
               cross(hull[i], hull[(i+1)%n], hull[j]):
                j = next_j
            else:
                break
        
        # 更新最大距离
        max_dist_sq = max(max_dist_sq, 
                         distance_sq(hull[i], hull[j]),
                         distance_sq(hull[(i+1)%n], hull[j]))
    
    return max_dist_sq**0.5

# 测试
points = [(0,0), (1,1), (2,2), (0,2), (2,0), (1,0), (1,2)]
hull = convex_hull(points)

print(f"\n旋转卡壳 - 凸包直径:")
print(f"凸包: {hull}")
diameter = rotating_calipers(hull)
print(f"直径: {diameter:.2f}")
```

### 6.5 点与多边形的关系

```python
def point_in_polygon(point, polygon):
    """
    射线法判断点是否在多边形内
    """
    x, y = point
    n = len(polygon)
    inside = False
    
    p1x, p1y = polygon[0]
    
    for i in range(1, n + 1):
        p2x, p2y = polygon[i % n]
        
        if y > min(p1y, p2y):
            if y <= max(p1y, p2y):
                if x <= max(p1x, p2x):
                    if p1y != p2y:
                        xinters = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x
                    
                    if p1x == p2x or x <= xinters:
                        inside = not inside
        
        p1x, p1y = p2x, p2y
    
    return inside

# 测试
polygon = [(0, 0), (4, 0), (4, 4), (0, 4)]
test_points = [(2, 2), (5, 5), (0, 0), (2, 4)]

print("\n点与多边形关系:")
print(f"多边形: {polygon}")

for point in test_points:
    inside = point_in_polygon(point, polygon)
    print(f"  {point}: {'内部' if inside else '外部'}")
```

### 6.6 多边形面积

```python
def polygon_area(polygon):
    """
    Shoelace公式计算多边形面积
    """
    n = len(polygon)
    area = 0
    
    for i in range(n):
        j = (i + 1) % n
        area += polygon[i][0] * polygon[j][1]
        area -= polygon[j][0] * polygon[i][1]
    
    return abs(area) / 2

# 测试
polygon = [(0, 0), (4, 0), (4, 3), (0, 3)]
area = polygon_area(polygon)
print(f"\n多边形面积:")
print(f"顶点: {polygon}")
print(f"面积: {area}")
```

### 6.7 半平面交

```python
class HalfPlane:
    """半平面"""
    def __init__(self, p1, p2):
        self.p1 = p1
        self.p2 = p2
    
    def side(self, p):
        """判断点在半平面的哪一侧"""
        return cross_product(self.p1, self.p2, p)

def half_plane_intersection(half_planes):
    """
    半平面交 - S&I算法
    """
    # 按极角排序
    def angle(hp):
        dx = hp.p2.x - hp.p1.x
        dy = hp.p2.y - hp.p1.y
        import math
        return math.atan2(dy, dx)
    
    half_planes.sort(key=angle)
    
    # 双端队列维护半平面交
    from collections import deque
    dq = deque()
    
    for hp in half_planes:
        # 删除队尾无用半平面
        while len(dq) >= 2 and hp.side(intersection(dq[-2], dq[-1])) < 0:
            dq.pop()
        
        # 删除队首无用半平面
        while len(dq) >= 2 and hp.side(intersection(dq[0], dq[1])) < 0:
            dq.popleft()
        
        # 添加当前半平面
        if not dq or angle(hp) != angle(dq[-1]):
            dq.append(hp)
    
    # 检查队首队尾
    while len(dq) >= 3 and dq[0].side(intersection(dq[-2], dq[-1])) < 0:
        dq.pop()
    
    while len(dq) >= 3 and dq[-1].side(intersection(dq[0], dq[1])) < 0:
        dq.popleft()
    
    # 计算交点
    result = []
    for i in range(len(dq)):
        result.append(intersection(dq[i], dq[(i+1)%len(dq)]))
    
    return result

def intersection(hp1, hp2):
    """计算两半平面的交点"""
    # 简化实现
    return Point(0, 0)  # 实际需要求直线交点
```

### 6.8 计算几何算法总结

```python
def computational_geometry_summary():
    """
    计算几何算法总结
    """
    print("=" * 70)
    print("计算几何算法总结")
    print("=" * 70)
    
    algorithms = [
        ("凸包", "O(n log n)", "Graham扫描/Andrew", "极角排序"),
        ("线段相交", "O(1)", "跨立实验", "叉积"),
        ("最近点对", "O(n log n)", "分治", "分治+条带"),
        ("旋转卡壳", "O(n)", "对踵点", "双指针"),
        ("点在多边形内", "O(n)", "射线法", "奇偶性"),
        ("多边形面积", "O(n)", "Shoelace", "叉积求和"),
        ("半平面交", "O(n log n)", "S&I算法", "双端队列"),
    ]
    
    print(f"\n{'算法':<20} {'复杂度':<15} {'方法':<20} {'核心思想':<15}")
    print("-" * 70)
    
    for name, complexity, method, idea in algorithms:
        print(f"{name:<20} {complexity:<15} {method:<20} {idea:<15}")
    
    print("\n" + "=" * 70)
    print("常用几何运算")
    print("=" * 70)
    print("""
1. 向量运算：
   - 点积（内积）：判断角度
   - 叉积（外积）：判断方向、面积
   - 向量旋转：极角变换

2. 距离计算：
   - 点到点：欧几里得距离
   - 点到线：垂直距离
   - 点到线段：分情况讨论

3. 位置关系：
   - 点与线段：共线+在区间内
   - 线段相交：跨立实验
   - 点在多边形：射线法、转角法

4. 几何变换：
   - 平移：坐标加减
   - 旋转：旋转矩阵
   - 缩放：坐标乘除
    """)
    
    print("\n精度处理建议:")
    print("""
- 浮点数比较：使用eps（如1e-9）
- 整数坐标：尽可能避免除法
- 叉积：可用整数避免精度损失
- 复杂运算：注意数值稳定性
    """)

computational_geometry_summary()
```

### 6.9 三维几何基础

```python
class Point3D:
    """三维点"""
    def __init__(self, x, y, z):
        self.x = x
        self.y = y
        self.z = z
    
    def __repr__(self):
        return f"({self.x}, {self.y}, {self.z})"
    
    def distance(self, other):
        """计算到另一点的距离"""
        dx = self.x - other.x
        dy = self.y - other.y
        dz = self.z - other.z
        return (dx*dx + dy*dy + dz*dz)**0.5
    
    def dot(self, other):
        """点积"""
        return self.x*other.x + self.y*other.y + self.z*other.z
    
    def cross(self, other):
        """叉积"""
        return Point3D(
            self.y*other.z - self.z*other.y,
            self.z*other.x - self.x*other.z,
            self.x*other.y - self.y*other.x
        )

def triangle_area_3d(p1, p2, p3):
    """三维三角形面积"""
    v1 = Point3D(p2.x - p1.x, p2.y - p1.y, p2.z - p1.z)
    v2 = Point3D(p3.x - p1.x, p3.y - p1.y, p3.z - p1.z)
    
    cross = v1.cross(v2)
    length = (cross.x**2 + cross.y**2 + cross.z**2)**0.5
    
    return length / 2

# 测试
p1 = Point3D(0, 0, 0)
p2 = Point3D(1, 0, 0)
p3 = Point3D(0, 1, 0)

print(f"\n三维几何:")
print(f"三角形顶点: {p1}, {p2}, {p3}")
print(f"面积: {triangle_area_3d(p1, p2, p3):.2f}")
```

---

**本章完**
