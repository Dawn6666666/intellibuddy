# 算法设计与分析 - (十二)在线算法

理解在线算法设计。

---

## 12. 在线算法

### 12.1 LRU缓存

```python
class LRUCache:
    """
    LRU缓存（最近最少使用）
    O(1)查询和更新
    """
    class Node:
        def __init__(self, key, value):
            self.key = key
            self.value = value
            self.prev = None
            self.next = None
    
    def __init__(self, capacity):
        self.capacity = capacity
        self.cache = {}  # key -> Node
        self.head = self.Node(0, 0)  # 虚拟头
        self.tail = self.Node(0, 0)  # 虚拟尾
        self.head.next = self.tail
        self.tail.prev = self.head
    
    def _add(self, node):
        """添加到头部（最近使用）"""
        node.prev = self.head
        node.next = self.head.next
        self.head.next.prev = node
        self.head.next = node
    
    def _remove(self, node):
        """移除节点"""
        node.prev.next = node.next
        node.next.prev = node.prev
    
    def get(self, key):
        """获取值"""
        if key in self.cache:
            node = self.cache[key]
            self._remove(node)
            self._add(node)
            return node.value
        return -1
    
    def put(self, key, value):
        """设置值"""
        if key in self.cache:
            self._remove(self.cache[key])
        
        node = self.Node(key, value)
        self._add(node)
        self.cache[key] = node
        
        if len(self.cache) > self.capacity:
            # 删除最久未使用
            lru = self.tail.prev
            self._remove(lru)
            del self.cache[lru.key]

# 示例
lru = LRUCache(2)
lru.put(1, 1)
lru.put(2, 2)
print(lru.get(1))  # 1
lru.put(3, 3)      # 淘汰2
print(lru.get(2))  # -1
```

### 12.2 滑动窗口中位数

```python
import heapq

class MedianFinder:
    """
    数据流中的中位数
    使用两个堆：大顶堆（左半部分）+小顶堆（右半部分）
    """
    def __init__(self):
        self.small = []  # 大顶堆（存负数）
        self.large = []  # 小顶堆
    
    def add_num(self, num):
        """添加数字 O(log n)"""
        # 先加到large
        heapq.heappush(self.large, num)
        
        # 平衡：large最小值 → small最大值
        heapq.heappush(self.small, -heapq.heappop(self.large))
        
        # 保持small长度 ≤ large长度
        if len(self.small) > len(self.large):
            heapq.heappush(self.large, -heapq.heappop(self.small))
    
    def find_median(self):
        """查找中位数 O(1)"""
        if len(self.large) > len(self.small):
            return self.large[0]
        else:
            return (self.large[0] - self.small[0]) / 2.0

# 示例
mf = MedianFinder()
for num in [1, 2, 3, 4, 5]:
    mf.add_num(num)
    print(f"添加{num}后中位数: {mf.find_median()}")
```

---

## 📚 学习建议

### 算法竞赛资源

🏆 **在线平台：**
- **LeetCode**（面试刷题）
  - 精选题单：Hot 100, 剑指Offer
  - 竞赛：每周赛、双周赛
- **Codeforces**（竞赛训练）
  - Rating分级：Div1, Div2, Div3
  - 虚拟比赛训练
- **AtCoder**（日本OJ）
  - Beginner Contest（入门友好）
  - 题解详细
- **USACO**（美国信息学奥赛）
  - Bronze/Silver/Gold/Platinum分级
  - 系统训练体系

📖 **经典教材：**
- 《算法导论》（CLRS）- 理论基础
- 《算法竞赛进阶指南》（李煜东）- 竞赛技巧
- 《挑战程序设计竞赛》- 实战训练
- 《算法第4版》（Robert Sedgewick）- 代码实现

💻 **可视化工具：**
- VisuAlgo - 算法可视化
- Algorithm Visualizer
- LeetCode动画题解

### 学习路线图

**阶段1：基础算法（2-3个月）**
- ✅ 排序与搜索
- ✅ 递归与分治
- ✅ 贪心策略
- ✅ 动态规划入门

**阶段2：图论（1-2个月）**
- ✅ 最短路径（Dijkstra, Bellman-Ford, Floyd）
- ✅ 最小生成树（Prim, Kruskal）
- ✅ 拓扑排序与强连通分量
- ✅ 网络流（Ford-Fulkerson, Dinic）

**阶段3：字符串（2-4周）**
- ✅ KMP算法
- ✅ 后缀数组
- ✅ AC自动机
- ✅ Manacher（最长回文）

**阶段4：数学与数论（1个月）**
- ✅ 快速幂与矩阵快速幂
- ✅ 欧几里得与扩展欧几里得
- ✅ 素数筛法
- ✅ 组合数学

**阶段5：高级技巧（持续）**
- ✅ 分块算法
- ✅ 莫队算法
- ✅ CDQ分治
- ✅ 树链剖分

### 刷题策略

**按类型刷题：**
1. **数组**（100题）
   - 双指针、滑动窗口
   - 前缀和、差分数组
   
2. **链表**（30题）
   - 快慢指针
   - 反转、合并

3. **树**（80题）
   - DFS、BFS遍历
   - 二叉搜索树
   - 树形DP

4. **图**（50题）
   - 最短路
   - 拓扑排序
   - 并查集

5. **动态规划**（150题）
   - 背包问题
   - 区间DP
   - 状态压缩DP

**每日计划：**
- 🔥 **新题**：2-3题（不同难度）
- 📝 **复习**：1题（以前做错的）
- 💡 **总结**：记录技巧和模板

### 常见错误

❌ **错误1**：只看题解不动手

- ✅ 必须自己实现一遍
- ✅ 理解每一行代码

❌ **错误2**：遇到难题就放弃

- ✅ 思考30分钟后再看题解
- ✅ 循序渐进，从简单题开始

❌ **错误3**：不总结模板

- ✅ 整理常用算法模板
- ✅ 定期复习

❌ **错误4**：忽视复杂度分析

- ✅ 每道题分析时间和空间复杂度
- ✅ 理解为什么超时

### 面试技巧

**面试高频算法：**
1. 双指针（Two Pointers）
2. 滑动窗口（Sliding Window）
3. 二分查找（Binary Search）
4. BFS/DFS遍历
5. 动态规划（背包、子序列）
6. 贪心算法
7. 回溯（Backtracking）
8. 排序算法

**面试流程：**
1. **理解题意**：确认输入输出、边界条件
2. **暴力解法**：先给出O(n²)等暴力方案
3. **优化思路**：讨论如何优化到O(n log n)或O(n)
4. **编码实现**：边写边讲解
5. **测试用例**：常规、边界、极端情况

### 竞赛技巧

**比赛策略：**
- 📖 先快速浏览所有题目
- 🎯 先做擅长的题型
- ⏱️ 控制时间，卡住30分钟换题
- 🐛 提交前多测试边界情况

**常用技巧：**
- **读题仔细**：注意数据范围、特殊条件
- **快速判断**：根据n的大小判断算法复杂度
  - n ≤ 10: O(n!)
  - n ≤ 20: O(2ⁿ)
  - n ≤ 100: O(n³)
  - n ≤ 1000: O(n²)
  - n ≤ 10⁶: O(n log n)
  - n ≤ 10⁸: O(n)
- **打表技巧**：找规律、预处理
- **对拍**：生成随机数据对拍答案

---

> **记住**：算法是计算机科学的核心！坚持刷题，终有所成！💪
> 
> **学习心得**：
> - 理解原理比背代码重要
> - 多画图、多举例
> - 从暴力到优化，循序渐进
> - 坚持每天刷题，量变引起质变

---

**本章完**

