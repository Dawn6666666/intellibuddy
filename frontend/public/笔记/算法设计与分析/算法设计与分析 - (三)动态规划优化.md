# 算法设计与分析 - (三)动态规划优化

学习动态规划优化技巧。

---

## 3. 动态规划优化

### 3.1 单调队列优化

**问题：**滑动窗口最大值

```python
from collections import deque

def sliding_window_maximum(nums, k):
    """
    O(n)单调队列优化
    """
    dq = deque()  # 单调递减队列（存索引）
    result = []
    
    for i in range(len(nums)):
        # 移除超出窗口的元素
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        
        # 维护单调性
        while dq and nums[dq[-1]] < nums[i]:
            dq.pop()
        
        dq.append(i)
        
        # 窗口形成后记录结果
        if i >= k - 1:
            result.append(nums[dq[0]])
    
    return result

nums = [1, 3, -1, -3, 5, 3, 6, 7]
k = 3
print(sliding_window_maximum(nums, k))  # [3, 3, 5, 5, 6, 7]
```

### 3.2 斜率优化DP

**问题：**任务分配（凸优化）

```python
def convex_hull_trick(tasks):
    """
    斜率优化DP（凸包技巧）
    问题：将n个任务分配到若干批次，最小化代价
    """
    n = len(tasks)
    dp = [float('inf')] * n
    dp[0] = 0
    
    # 维护下凸包
    hull = []
    
    def slope(i, j):
        """计算斜率"""
        return (dp[j] - dp[i]) / (tasks[j] - tasks[i])
    
    for i in range(1, n):
        # 添加新线段到凸包
        while len(hull) >= 2 and slope(hull[-2], hull[-1]) >= slope(hull[-1], i):
            hull.pop()
        hull.append(i)
        
        # 查询最优点
        dp[i] = min(dp[j] + cost(j, i) for j in hull)
    
    return dp[n-1]

def cost(i, j):
    """代价函数"""
    return (j - i) ** 2
```

### 3.3 状态压缩DP

**问题：**旅行商问题（TSP）

```python
def tsp_dp(dist):
    """
    状态压缩DP解TSP
    dist: 距离矩阵
    """
    n = len(dist)
    INF = float('inf')
    
    # dp[mask][i]: 访问状态为mask，当前在i的最短路径
    dp = [[INF] * n for _ in range(1 << n)]
    dp[1][0] = 0  # 从0出发
    
    for mask in range(1 << n):
        for u in range(n):
            if not (mask & (1 << u)):
                continue
            
            for v in range(n):
                if mask & (1 << v):
                    continue
                
                new_mask = mask | (1 << v)
                dp[new_mask][v] = min(dp[new_mask][v], 
                                      dp[mask][u] + dist[u][v])
    
    # 返回起点
    ans = min(dp[(1 << n) - 1][i] + dist[i][0] for i in range(1, n))
    return ans

# 示例
dist = [
    [0, 10, 15, 20],
    [10, 0, 35, 25],
    [15, 35, 0, 30],
    [20, 25, 30, 0]
]

print(f"最短路径: {tsp_dp(dist)}")  # 80
```

### 3.4 四边形不等式优化

**四边形不等式**是一种强大的DP优化技术，可以将 $O(n^3)$ 优化到 $O(n^2)$。

```python
def quadrangle_inequality_dp(arr):
    """
    四边形不等式优化DP
    问题：最优二叉搜索树
    """
    n = len(arr)
    
    # dp[i][j]: 区间[i,j]的最小代价
    dp = [[float('inf')] * n for _ in range(n)]
    
    # s[i][j]: 区间[i,j]的最优分割点
    s = [[0] * n for _ in range(n)]
    
    # 基础情况
    for i in range(n):
        dp[i][i] = arr[i]
        s[i][i] = i
    
    # 区间DP
    for length in range(2, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            
            # 四边形不等式优化：只需在[s[i][j-1], s[i+1][j]]范围内搜索
            start = s[i][j-1] if j > 0 else i
            end = s[i+1][j] if i + 1 < n else j
            
            for k in range(start, min(end + 1, j + 1)):
                left_cost = dp[i][k-1] if k > i else 0
                right_cost = dp[k+1][j] if k < j else 0
                cost = left_cost + right_cost + sum(arr[i:j+1])
                
                if cost < dp[i][j]:
                    dp[i][j] = cost
                    s[i][j] = k
    
    return dp[0][n-1]

# 测试
arr = [10, 12, 20, 35, 46]
print(f"\n数组: {arr}")
print(f"最优二叉搜索树代价: {quadrangle_inequality_dp(arr)}")
```

### 3.5 决策单调性优化

**决策单调性**：如果最优决策点随着状态单调变化，可以利用这个性质优化。

```python
def decision_monotonicity_dp(matrix):
    """
    决策单调性优化
    问题：矩阵链乘法
    """
    n = len(matrix)
    
    # dp[i][j]: 计算矩阵i到j的最小乘法次数
    dp = [[0] * n for _ in range(n)]
    
    # split[i][j]: 最优分割点
    split = [[0] * n for _ in range(n)]
    
    # 区间DP
    for length in range(2, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            dp[i][j] = float('inf')
            
            # 利用决策单调性缩小搜索范围
            start = split[i][j-1] if j > 0 else i
            end = split[i+1][j] if i + 1 < n else j - 1
            
            for k in range(start, min(end + 1, j)):
                cost = dp[i][k] + dp[k+1][j] + matrix[i][0] * matrix[k][1] * matrix[j][1]
                
                if cost < dp[i][j]:
                    dp[i][j] = cost
                    split[i][j] = k
    
    return dp[0][n-1]

# 测试：矩阵维度
matrices = [(30, 35), (35, 15), (15, 5), (5, 10), (10, 20), (20, 25)]
print(f"\n矩阵维度: {matrices}")
print(f"最少乘法次数: {decision_monotonicity_dp(matrices)}")
```

### 3.6 分治DP

**分治DP**结合分治和动态规划，适用于决策点满足单调性的问题。

```python
def divide_conquer_dp(n, k, cost):
    """
    分治DP - O(kn log n)
    问题：将n个元素分成k组，最小化代价
    
    cost[i][j]: 区间[i,j]作为一组的代价
    """
    # dp[t][i]: 前i个元素分成t组的最小代价
    dp = [[float('inf')] * (n + 1) for _ in range(k + 1)]
    dp[0][0] = 0
    
    def solve(t, l, r, opt_l, opt_r):
        """
        分治求解dp[t][l..r]
        opt_l, opt_r: 最优决策点的范围
        """
        if l > r:
            return
        
        mid = (l + r) // 2
        best_k = opt_l
        best_cost = float('inf')
        
        # 在[opt_l, opt_r]范围内找最优决策点
        for k in range(opt_l, min(mid, opt_r) + 1):
            current_cost = dp[t-1][k] + cost[k][mid]
            if current_cost < best_cost:
                best_cost = current_cost
                best_k = k
        
        dp[t][mid] = best_cost
        
        # 递归求解左右两部分
        solve(t, l, mid - 1, opt_l, best_k)
        solve(t, mid + 1, r, best_k, opt_r)
    
    # 逐层计算
    for t in range(1, k + 1):
        solve(t, 1, n, 0, n)
    
    return dp[k][n]

# 测试
n = 10
k = 3

# 构造代价函数（示例：区间和的平方）
arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
cost = [[0] * (n + 1) for _ in range(n + 1)]

for i in range(n + 1):
    for j in range(i, n + 1):
        interval_sum = sum(arr[i:j]) if j > i else 0
        cost[i][j] = interval_sum ** 2

result = divide_conquer_dp(n, k, cost)
print(f"\n将{n}个元素分成{k}组的最小代价: {result}")
```

### 3.7 树形DP

```python
class TreeNode:
    def __init__(self, val=0):
        self.val = val
        self.children = []

def tree_dp_max_independent_set(root):
    """
    树形DP：最大独立集
    选择一些节点，使得没有两个相邻节点被选中，最大化权值和
    """
    def dfs(node):
        if not node:
            return 0, 0
        
        # include: 选择当前节点
        # exclude: 不选择当前节点
        include = node.val
        exclude = 0
        
        for child in node.children:
            child_include, child_exclude = dfs(child)
            
            # 选择当前节点，子节点不能选
            include += child_exclude
            
            # 不选当前节点，子节点可选可不选
            exclude += max(child_include, child_exclude)
        
        return include, exclude
    
    include, exclude = dfs(root)
    return max(include, exclude)

# 构建测试树
root = TreeNode(10)
root.children = [TreeNode(5), TreeNode(8), TreeNode(12)]
root.children[0].children = [TreeNode(3), TreeNode(7)]
root.children[1].children = [TreeNode(6)]

print(f"\n树的最大独立集: {tree_dp_max_independent_set(root)}")
```

### 3.8 数位DP

```python
def digit_dp(n):
    """
    数位DP：统计[0, n]中不含4的数字个数
    """
    s = str(n)
    length = len(s)
    
    # dp[pos][tight]: 
    # pos: 当前处理到第pos位
    # tight: 是否受到n的限制
    memo = {}
    
    def dfs(pos, tight, started):
        """
        pos: 当前位置
        tight: 是否紧贴上界
        started: 是否已经开始（处理前导零）
        """
        if pos == length:
            return 1 if started else 0
        
        if (pos, tight, started) in memo:
            return memo[(pos, tight, started)]
        
        # 确定当前位的上界
        up = int(s[pos]) if tight else 9
        
        result = 0
        for digit in range(0, up + 1):
            if digit == 4:  # 跳过包含4的数字
                continue
            
            new_tight = tight and (digit == up)
            new_started = started or (digit != 0)
            
            result += dfs(pos + 1, new_tight, new_started)
        
        memo[(pos, tight, started)] = result
        return result
    
    return dfs(0, True, False)

# 测试
for n in [10, 100, 1000]:
    count = digit_dp(n)
    print(f"[0, {n}]中不含4的数字个数: {count}")
```

### 3.9 概率DP

```python
def probability_dp(n, k):
    """
    概率DP：抛硬币问题
    抛n次硬币，恰好k次正面朝上的概率
    """
    # dp[i][j]: 前i次抛硬币，j次正面朝上的概率
    dp = [[0.0] * (k + 2) for _ in range(n + 1)]
    dp[0][0] = 1.0
    
    for i in range(1, n + 1):
        for j in range(min(i, k) + 1):
            # 当前次正面朝上
            if j > 0:
                dp[i][j] += dp[i-1][j-1] * 0.5
            
            # 当前次反面朝上
            dp[i][j] += dp[i-1][j] * 0.5
    
    return dp[n][k]

# 测试
n, k = 10, 5
prob = probability_dp(n, k)
print(f"\n抛{n}次硬币，恰好{k}次正面朝上的概率: {prob:.6f}")

# 验证：应该接近C(n,k) / 2^n
import math
expected = math.comb(n, k) / (2 ** n)
print(f"理论值: {expected:.6f}")
```

### 3.10 DP优化技巧总结

```python
def dp_optimization_summary():
    """
    DP优化技巧总结
    """
    print("=" * 60)
    print("动态规划优化技巧总结")
    print("=" * 60)
    
    techniques = [
        ("单调队列优化", "O(n²) → O(n)", "滑动窗口最值"),
        ("斜率优化", "O(n²) → O(n)", "凸包技巧"),
        ("四边形不等式", "O(n³) → O(n²)", "区间DP"),
        ("决策单调性", "O(n³) → O(n²)", "矩阵链乘法"),
        ("分治DP", "O(kn²) → O(kn log n)", "分组问题"),
        ("状态压缩", "O(2ⁿ·n²) → O(2ⁿ·n)", "TSP问题"),
        ("数据结构优化", "O(n²) → O(n log n)", "树状数组/线段树"),
    ]
    
    print(f"\n{'优化技巧':<20} {'复杂度优化':<25} {'典型应用':<20}")
    print("-" * 70)
    
    for technique, complexity, application in techniques:
        print(f"{technique:<20} {complexity:<25} {application:<20}")
    
    print("\n" + "=" * 60)
    print("选择优化技巧的一般原则")
    print("=" * 60)
    print("""
1. 单调队列/栈：
   - 状态转移涉及区间最值
   - 决策点单调移动

2. 斜率优化：
   - 转移方程可以写成斜率形式
   - 决策点在凸包上

3. 四边形不等式：
   - 满足区间包含单调性
   - 代价函数满足四边形不等式

4. 分治DP：
   - 决策点单调
   - 可以分治求解

5. 状态压缩：
   - 状态数较少（≤20）
   - 状态之间有依赖关系

6. 数据结构优化：
   - 需要快速查询/更新
   - 可以用树状数组/线段树维护
    """)

dp_optimization_summary()
```

---

**本章完**
