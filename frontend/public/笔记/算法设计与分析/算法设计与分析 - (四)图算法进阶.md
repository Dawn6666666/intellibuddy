# 算法设计与分析 - (四)图算法进阶

深入研究图论算法。

---

## 4. 图算法进阶

### 4.1 强连通分量（Tarjan算法）

```python
def tarjan_scc(graph):
    """
    Tarjan算法求强连通分量
    """
    n = len(graph)
    dfn = [-1] * n  # DFS序号
    low = [-1] * n  # 能到达的最小dfn
    in_stack = [False] * n
    stack = []
    scc = []
    index = [0]  # 时间戳
    
    def dfs(u):
        dfn[u] = low[u] = index[0]
        index[0] += 1
        stack.append(u)
        in_stack[u] = True
        
        for v in graph[u]:
            if dfn[v] == -1:
                dfs(v)
                low[u] = min(low[u], low[v])
            elif in_stack[v]:
                low[u] = min(low[u], dfn[v])
        
        # u是SCC的根
        if dfn[u] == low[u]:
            component = []
            while True:
                v = stack.pop()
                in_stack[v] = False
                component.append(v)
                if v == u:
                    break
            scc.append(component)
    
    for i in range(n):
        if dfn[i] == -1:
            dfs(i)
    
    return scc

# 示例图
graph = [
    [1],      # 0 → 1
    [2],      # 1 → 2
    [0, 3],   # 2 → 0, 3
    [4],      # 3 → 4
    [5],      # 4 → 5
    [3]       # 5 → 3
]

sccs = tarjan_scc(graph)
print(f"强连通分量: {sccs}")
```

### 4.2 网络流（Dinic算法）

```python
from collections import deque

class Dinic:
    def __init__(self, n):
        self.n = n
        self.graph = [[] for _ in range(n)]
    
    def add_edge(self, u, v, cap):
        """添加边"""
        self.graph[u].append([v, cap, len(self.graph[v])])
        self.graph[v].append([u, 0, len(self.graph[u]) - 1])
    
    def bfs(self, s, t):
        """BFS分层"""
        level = [-1] * self.n
        level[s] = 0
        queue = deque([s])
        
        while queue:
            u = queue.popleft()
            for v, cap, _ in self.graph[u]:
                if cap > 0 and level[v] == -1:
                    level[v] = level[u] + 1
                    queue.append(v)
        
        return level[t] != -1, level
    
    def dfs(self, u, t, flow, level, iter):
        """DFS增广"""
        if u == t:
            return flow
        
        for i in range(iter[u], len(self.graph[u])):
            v, cap, rev = self.graph[u][i]
            if cap > 0 and level[u] < level[v]:
                d = self.dfs(v, t, min(flow, cap), level, iter)
                if d > 0:
                    self.graph[u][i][1] -= d
                    self.graph[v][rev][1] += d
                    return d
            iter[u] += 1
        
        return 0
    
    def max_flow(self, s, t):
        """最大流"""
        flow = 0
        
        while True:
            reachable, level = self.bfs(s, t)
            if not reachable:
                return flow
            
            iter = [0] * self.n
            while True:
                f = self.dfs(s, t, float('inf'), level, iter)
                if f == 0:
                    break
                flow += f

# 示例
dinic = Dinic(6)
dinic.add_edge(0, 1, 16)
dinic.add_edge(0, 2, 13)
dinic.add_edge(1, 3, 12)
dinic.add_edge(2, 4, 14)
dinic.add_edge(3, 5, 20)
dinic.add_edge(4, 5, 4)

print(f"最大流: {dinic.max_flow(0, 5)}")
```

### 4.3 最小生成树

#### 4.3.1 Kruskal算法

```python
class UnionFind:
    """并查集"""
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n
    
    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])  # 路径压缩
        return self.parent[x]
    
    def union(self, x, y):
        px, py = self.find(x), self.find(y)
        if px == py:
            return False
        
        # 按秩合并
        if self.rank[px] < self.rank[py]:
            px, py = py, px
        self.parent[py] = px
        if self.rank[px] == self.rank[py]:
            self.rank[px] += 1
        
        return True

def kruskal(n, edges):
    """
    Kruskal算法求最小生成树
    n: 顶点数
    edges: [(u, v, weight), ...]
    """
    # 按权重排序
    edges.sort(key=lambda e: e[2])
    
    uf = UnionFind(n)
    mst = []
    total_weight = 0
    
    for u, v, w in edges:
        if uf.union(u, v):
            mst.append((u, v, w))
            total_weight += w
            
            if len(mst) == n - 1:
                break
    
    return mst, total_weight

# 测试
edges = [
    (0, 1, 4), (0, 7, 8),
    (1, 2, 8), (1, 7, 11),
    (2, 3, 7), (2, 8, 2), (2, 5, 4),
    (3, 4, 9), (3, 5, 14),
    (4, 5, 10),
    (5, 6, 2),
    (6, 7, 1), (6, 8, 6),
    (7, 8, 7)
]

mst, weight = kruskal(9, edges)
print(f"\n最小生成树边:")
for u, v, w in mst:
    print(f"  {u} -- {v}: {w}")
print(f"总权重: {weight}")
```

#### 4.3.2 Prim算法

```python
import heapq

def prim(n, graph):
    """
    Prim算法求最小生成树
    graph[u] = [(v, weight), ...]
    """
    visited = [False] * n
    mst = []
    total_weight = 0
    
    # 从顶点0开始
    pq = [(0, 0, -1)]  # (weight, vertex, parent)
    
    while pq:
        w, u, parent = heapq.heappop(pq)
        
        if visited[u]:
            continue
        
        visited[u] = True
        total_weight += w
        
        if parent != -1:
            mst.append((parent, u, w))
        
        # 添加相邻边
        for v, edge_weight in graph[u]:
            if not visited[v]:
                heapq.heappush(pq, (edge_weight, v, u))
    
    return mst, total_weight

# 构建图
graph = [[] for _ in range(9)]
for u, v, w in edges:
    graph[u].append((v, w))
    graph[v].append((u, w))

mst, weight = prim(9, graph)
print(f"\nPrim算法最小生成树:")
for u, v, w in mst:
    print(f"  {u} -- {v}: {w}")
print(f"总权重: {weight}")
```

### 4.4 最短路径算法

#### 4.4.1 Dijkstra算法（堆优化）

```python
import heapq

def dijkstra(n, graph, start):
    """
    Dijkstra算法 - O((V+E) log V)
    graph[u] = [(v, weight), ...]
    """
    dist = [float('inf')] * n
    dist[start] = 0
    parent = [-1] * n
    
    pq = [(0, start)]
    
    while pq:
        d, u = heapq.heappop(pq)
        
        if d > dist[u]:
            continue
        
        for v, w in graph[u]:
            if dist[u] + w < dist[v]:
                dist[v] = dist[u] + w
                parent[v] = u
                heapq.heappush(pq, (dist[v], v))
    
    return dist, parent

def get_path(parent, target):
    """重建路径"""
    path = []
    while target != -1:
        path.append(target)
        target = parent[target]
    return path[::-1]

# 测试
graph = [
    [(1, 4), (7, 8)],           # 0
    [(0, 4), (2, 8), (7, 11)],  # 1
    [(1, 8), (3, 7), (5, 4), (8, 2)],  # 2
    [(2, 7), (4, 9), (5, 14)],  # 3
    [(3, 9), (5, 10)],          # 4
    [(2, 4), (3, 14), (4, 10), (6, 2)],  # 5
    [(5, 2), (7, 1), (8, 6)],   # 6
    [(0, 8), (1, 11), (6, 1), (8, 7)],  # 7
    [(2, 2), (6, 6), (7, 7)]    # 8
]

dist, parent = dijkstra(9, graph, 0)

print("\n从顶点0到各顶点的最短距离:")
for i in range(9):
    path = get_path(parent, i)
    print(f"  到顶点{i}: 距离={dist[i]}, 路径={' -> '.join(map(str, path))}")
```

#### 4.4.2 Bellman-Ford算法（负权边）

```python
def bellman_ford(n, edges, start):
    """
    Bellman-Ford算法 - O(VE)
    可处理负权边，可检测负权环
    """
    dist = [float('inf')] * n
    dist[start] = 0
    parent = [-1] * n
    
    # 松弛n-1次
    for _ in range(n - 1):
        updated = False
        for u, v, w in edges:
            if dist[u] != float('inf') and dist[u] + w < dist[v]:
                dist[v] = dist[u] + w
                parent[v] = u
                updated = True
        
        if not updated:
            break
    
    # 检测负权环
    for u, v, w in edges:
        if dist[u] != float('inf') and dist[u] + w < dist[v]:
            return None, None  # 存在负权环
    
    return dist, parent

# 测试（包含负权边）
edges_with_negative = [
    (0, 1, 4), (0, 2, 3),
    (1, 3, 2), (1, 2, -1),
    (2, 3, 1), (2, 4, 5),
    (3, 4, -3)
]

dist, parent = bellman_ford(5, edges_with_negative, 0)

if dist is None:
    print("\n存在负权环！")
else:
    print("\nBellman-Ford算法（支持负权边）:")
    for i in range(5):
        print(f"  到顶点{i}: 距离={dist[i]}")
```

#### 4.4.3 Floyd-Warshall算法（全源最短路径）

```python
def floyd_warshall(n, edges):
    """
    Floyd-Warshall算法 - O(V³)
    计算所有点对之间的最短路径
    """
    # 初始化距离矩阵
    dist = [[float('inf')] * n for _ in range(n)]
    next_node = [[-1] * n for _ in range(n)]
    
    for i in range(n):
        dist[i][i] = 0
    
    for u, v, w in edges:
        dist[u][v] = w
        next_node[u][v] = v
    
    # Floyd-Warshall核心算法
    for k in range(n):
        for i in range(n):
            for j in range(n):
                if dist[i][k] + dist[k][j] < dist[i][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]
                    next_node[i][j] = next_node[i][k]
    
    return dist, next_node

def reconstruct_path(next_node, u, v):
    """重建路径"""
    if next_node[u][v] == -1:
        return []
    
    path = [u]
    while u != v:
        u = next_node[u][v]
        path.append(u)
    
    return path

# 测试
edges_directed = [
    (0, 1, 3), (0, 2, 8), (0, 4, -4),
    (1, 3, 1), (1, 4, 7),
    (2, 1, 4),
    (3, 0, 2), (3, 2, -5),
    (4, 3, 6)
]

dist, next_node = floyd_warshall(5, edges_directed)

print("\nFloyd-Warshall全源最短路径:")
print("\n距离矩阵:")
for i in range(5):
    for j in range(5):
        if dist[i][j] == float('inf'):
            print(f"{'∞':>5}", end=" ")
        else:
            print(f"{dist[i][j]:>5}", end=" ")
    print()

print("\n示例路径 (0 -> 2):")
path = reconstruct_path(next_node, 0, 2)
print(f"  路径: {' -> '.join(map(str, path))}")
print(f"  距离: {dist[0][2]}")
```

### 4.5 二分图匹配

#### 4.5.1 匈牙利算法（最大匹配）

```python
def hungarian_algorithm(n, m, edges):
    """
    匈牙利算法 - O(VE)
    n: 左侧顶点数
    m: 右侧顶点数
    edges: 二分图的边
    """
    graph = [[] for _ in range(n)]
    for u, v in edges:
        graph[u].append(v)
    
    match = [-1] * m  # match[v] = u 表示右侧v匹配到左侧u
    
    def dfs(u, visited):
        """寻找增广路径"""
        for v in graph[u]:
            if visited[v]:
                continue
            
            visited[v] = True
            
            # 如果v未匹配，或者v的匹配可以找到新的匹配
            if match[v] == -1 or dfs(match[v], visited):
                match[v] = u
                return True
        
        return False
    
    # 对每个左侧顶点尝试找增广路径
    matching = 0
    for u in range(n):
        visited = [False] * m
        if dfs(u, visited):
            matching += 1
    
    return matching, match

# 测试：工作分配问题
# 左侧：工人，右侧：工作
edges = [
    (0, 0), (0, 1),        # 工人0可以做工作0,1
    (1, 0), (1, 2),        # 工人1可以做工作0,2
    (2, 1), (2, 3),        # 工人2可以做工作1,3
    (3, 2), (3, 3)         # 工人3可以做工作2,3
]

matching, match = hungarian_algorithm(4, 4, edges)

print(f"\n最大匹配数: {matching}")
print("匹配方案:")
for job, worker in enumerate(match):
    if worker != -1:
        print(f"  工人{worker} -> 工作{job}")
```

#### 4.5.2 Hopcroft-Karp算法（最快的二分图匹配）

```python
from collections import deque

def hopcroft_karp(n, m, edges):
    """
    Hopcroft-Karp算法 - O(E√V)
    最快的二分图最大匹配算法
    """
    graph = [[] for _ in range(n)]
    for u, v in edges:
        graph[u].append(v)
    
    pair_u = [-1] * n  # 左侧匹配
    pair_v = [-1] * m  # 右侧匹配
    dist = [0] * n
    
    def bfs():
        """BFS寻找增广路径"""
        queue = deque()
        
        for u in range(n):
            if pair_u[u] == -1:
                dist[u] = 0
                queue.append(u)
            else:
                dist[u] = float('inf')
        
        dist_nil = float('inf')
        
        while queue:
            u = queue.popleft()
            
            if dist[u] < dist_nil:
                for v in graph[u]:
                    if pair_v[v] == -1:
                        dist_nil = dist[u] + 1
                    elif dist[pair_v[v]] == float('inf'):
                        dist[pair_v[v]] = dist[u] + 1
                        queue.append(pair_v[v])
        
        return dist_nil != float('inf')
    
    def dfs(u):
        """DFS寻找增广路径"""
        if u == -1:
            return True
        
        for v in graph[u]:
            if pair_v[v] == -1 or (dist[pair_v[v]] == dist[u] + 1 and dfs(pair_v[v])):
                pair_v[v] = u
                pair_u[u] = v
                return True
        
        dist[u] = float('inf')
        return False
    
    matching = 0
    
    while bfs():
        for u in range(n):
            if pair_u[u] == -1 and dfs(u):
                matching += 1
    
    return matching, pair_u, pair_v

# 测试
matching, pair_u, pair_v = hopcroft_karp(4, 4, edges)

print(f"\nHopcroft-Karp算法:")
print(f"最大匹配数: {matching}")
print("匹配方案:")
for u, v in enumerate(pair_u):
    if v != -1:
        print(f"  工人{u} -> 工作{v}")
```

### 4.6 拓扑排序

```python
from collections import deque

def topological_sort_bfs(n, edges):
    """
    拓扑排序 - Kahn算法（BFS）
    """
    graph = [[] for _ in range(n)]
    in_degree = [0] * n
    
    for u, v in edges:
        graph[u].append(v)
        in_degree[v] += 1
    
    # 所有入度为0的顶点入队
    queue = deque([i for i in range(n) if in_degree[i] == 0])
    result = []
    
    while queue:
        u = queue.popleft()
        result.append(u)
        
        for v in graph[u]:
            in_degree[v] -= 1
            if in_degree[v] == 0:
                queue.append(v)
    
    # 如果结果长度不等于n，说明有环
    if len(result) != n:
        return None
    
    return result

def topological_sort_dfs(n, edges):
    """
    拓扑排序 - DFS
    """
    graph = [[] for _ in range(n)]
    for u, v in edges:
        graph[u].append(v)
    
    visited = [0] * n  # 0:未访问 1:访问中 2:已完成
    result = []
    
    def dfs(u):
        visited[u] = 1
        
        for v in graph[u]:
            if visited[v] == 1:  # 检测到环
                return False
            if visited[v] == 0 and not dfs(v):
                return False
        
        visited[u] = 2
        result.append(u)
        return True
    
    for i in range(n):
        if visited[i] == 0:
            if not dfs(i):
                return None
    
    return result[::-1]

# 测试：课程依赖关系
# 顶点：课程编号，边：先修关系
course_edges = [
    (0, 1), (0, 2),  # 课程0是1,2的先修课
    (1, 3),          # 课程1是3的先修课
    (2, 3),          # 课程2是3的先修课
    (3, 4),          # 课程3是4的先修课
    (2, 4)           # 课程2是4的先修课
]

print("\n拓扑排序（BFS - Kahn算法）:")
order_bfs = topological_sort_bfs(5, course_edges)
if order_bfs:
    print(f"  课程学习顺序: {' -> '.join(map(str, order_bfs))}")
else:
    print("  存在环！无法完成所有课程")

print("\n拓扑排序（DFS）:")
order_dfs = topological_sort_dfs(5, course_edges)
if order_dfs:
    print(f"  课程学习顺序: {' -> '.join(map(str, order_dfs))}")
else:
    print("  存在环！无法完成所有课程")
```

### 4.7 欧拉路径与哈密顿路径

```python
def find_eulerian_path(n, edges):
    """
    Hierholzer算法求欧拉路径
    """
    from collections import defaultdict
    
    graph = defaultdict(list)
    in_degree = [0] * n
    out_degree = [0] * n
    
    for u, v in edges:
        graph[u].append(v)
        out_degree[u] += 1
        in_degree[v] += 1
    
    # 检查欧拉路径存在性
    start = 0
    end = 0
    
    for i in range(n):
        if abs(out_degree[i] - in_degree[i]) > 1:
            return None  # 不存在欧拉路径
        
        if out_degree[i] - in_degree[i] == 1:
            start = i
        elif in_degree[i] - out_degree[i] == 1:
            end = i
    
    # Hierholzer算法
    stack = [start]
    path = []
    current_graph = {u: list(v) for u, v in graph.items()}
    
    while stack:
        u = stack[-1]
        
        if u in current_graph and current_graph[u]:
            v = current_graph[u].pop()
            stack.append(v)
        else:
            path.append(stack.pop())
    
    return path[::-1]

# 测试
euler_edges = [
    (0, 1), (1, 2), (2, 3), (3, 1), (1, 4), (4, 0)
]

print("\n欧拉路径:")
euler_path = find_eulerian_path(5, euler_edges)
if euler_path:
    print(f"  路径: {' -> '.join(map(str, euler_path))}")
else:
    print("  不存在欧拉路径")
```

---

**本章完**
