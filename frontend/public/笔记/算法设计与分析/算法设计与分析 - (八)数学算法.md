# 算法设计与分析 - (八)数学算法

掌握数论与组合算法。

---

## 8. 数学算法

### 8.1 快速幂

```python
def quick_pow(base, exp, mod):
    """
    快速幂算法 O(log n)
    计算 base^exp % mod
    """
    result = 1
    base %= mod
    
    while exp > 0:
        if exp & 1:  # 指数为奇数
            result = (result * base) % mod
        base = (base * base) % mod
        exp >>= 1
    
    return result

# 示例
print(quick_pow(2, 10, 1000))  # 2^10 % 1000 = 24
print(quick_pow(3, 100, 10**9+7))  # 大数取模
```

### 8.2 扩展欧几里得算法

```python
def extended_gcd(a, b):
    """
    扩展欧几里得算法
    求 ax + by = gcd(a, b) 的整数解
    """
    if b == 0:
        return a, 1, 0  # gcd, x, y
    
    gcd, x1, y1 = extended_gcd(b, a % b)
    x = y1
    y = x1 - (a // b) * y1
    
    return gcd, x, y

def mod_inverse(a, m):
    """
    求 a 模 m 的乘法逆元
    条件：gcd(a, m) = 1
    """
    gcd, x, _ = extended_gcd(a, m)
    if gcd != 1:
        return None  # 逆元不存在
    return (x % m + m) % m

# 示例
a, m = 3, 11
inv = mod_inverse(a, m)
print(f"{a}在模{m}下的逆元: {inv}")  # 4
print(f"验证: {a} * {inv} % {m} = {(a * inv) % m}")  # 1
```

### 8.3 中国剩余定理（CRT）

```python
def chinese_remainder(remainders, moduli):
    """
    中国剩余定理
    求解同余方程组：
    x ≡ r₁ (mod m₁)
    x ≡ r₂ (mod m₂)
    ...
    x ≡ rₙ (mod mₙ)
    """
    from functools import reduce
    
    def mul_inv(a, b):
        """扩展欧几里得求逆元"""
        b0 = b
        x0, x1 = 0, 1
        while a > 1:
            q = a // b
            a, b = b, a % b
            x0, x1 = x1 - q * x0, x0
        return x1 + b0 if x1 < 0 else x1
    
    total = 0
    prod = reduce(lambda a, b: a * b, moduli)
    
    for r, m in zip(remainders, moduli):
        p = prod // m
        total += r * mul_inv(p, m) * p
    
    return total % prod

# 示例：求x满足
# x ≡ 2 (mod 3)
# x ≡ 3 (mod 5)
# x ≡ 2 (mod 7)
remainders = [2, 3, 2]
moduli = [3, 5, 7]
x = chinese_remainder(remainders, moduli)
print(f"解: x = {x}")  # 23
```

### 8.4 Miller-Rabin素性测试

```python
def miller_rabin(n, k=5):
    """
    Miller-Rabin素性测试
    k: 测试轮数（越大越准确）
    """
    if n < 2:
        return False
    if n == 2 or n == 3:
        return True
    if n % 2 == 0:
        return False
    
    # 写n-1为2^r * d的形式
    r, d = 0, n - 1
    while d % 2 == 0:
        r += 1
        d //= 2
    
    import random
    
    def witness(a):
        x = pow(a, d, n)
        if x == 1 or x == n - 1:
            return True
        
        for _ in range(r - 1):
            x = pow(x, 2, n)
            if x == n - 1:
                return True
        
        return False
    
    # k轮测试
    for _ in range(k):
        a = random.randint(2, n - 2)
        if not witness(a):
            return False
    
    return True

# 示例
for n in [2, 17, 100, 561, 1000000007]:
    print(f"{n}: {'素数' if miller_rabin(n) else '合数'}")
```

---

**本章完**
