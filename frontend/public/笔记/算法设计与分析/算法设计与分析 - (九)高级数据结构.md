# 算法设计与分析 - (九)高级数据结构

学习高级数据结构。

---

## 9. 高级数据结构

### 9.1 线段树（Segment Tree）

```python
class SegmentTree:
    def __init__(self, arr):
        """区间查询与单点修改"""
        self.n = len(arr)
        self.tree = [0] * (4 * self.n)
        self.build(arr, 0, 0, self.n - 1)
    
    def build(self, arr, node, start, end):
        """构建线段树"""
        if start == end:
            self.tree[node] = arr[start]
            return
        
        mid = (start + end) // 2
        left = 2 * node + 1
        right = 2 * node + 2
        
        self.build(arr, left, start, mid)
        self.build(arr, right, mid + 1, end)
        
        self.tree[node] = self.tree[left] + self.tree[right]
    
    def update(self, idx, val, node=0, start=None, end=None):
        """单点更新"""
        if start is None:
            start, end = 0, self.n - 1
        
        if start == end:
            self.tree[node] = val
            return
        
        mid = (start + end) // 2
        left = 2 * node + 1
        right = 2 * node + 2
        
        if idx <= mid:
            self.update(idx, val, left, start, mid)
        else:
            self.update(idx, val, right, mid + 1, end)
        
        self.tree[node] = self.tree[left] + self.tree[right]
    
    def query(self, L, R, node=0, start=None, end=None):
        """区间查询"""
        if start is None:
            start, end = 0, self.n - 1
        
        if R < start or end < L:
            return 0
        
        if L <= start and end <= R:
            return self.tree[node]
        
        mid = (start + end) // 2
        left = 2 * node + 1
        right = 2 * node + 2
        
        return self.query(L, R, left, start, mid) + \
               self.query(L, R, right, mid + 1, end)

# 示例
arr = [1, 3, 5, 7, 9, 11]
seg_tree = SegmentTree(arr)
print(f"区间[1, 3]和: {seg_tree.query(1, 3)}")  # 3+5+7=15
seg_tree.update(1, 10)
print(f"更新后区间[1, 3]和: {seg_tree.query(1, 3)}")  # 10+5+7=22
```

### 9.2 树状数组（Fenwick Tree）

```python
class FenwickTree:
    def __init__(self, n):
        """Binary Indexed Tree"""
        self.n = n
        self.tree = [0] * (n + 1)
    
    def update(self, i, delta):
        """单点更新 O(log n)"""
        while i <= self.n:
            self.tree[i] += delta
            i += i & (-i)  # 加上lowbit
    
    def query(self, i):
        """前缀和查询 O(log n)"""
        s = 0
        while i > 0:
            s += self.tree[i]
            i -= i & (-i)  # 减去lowbit
        return s
    
    def range_query(self, l, r):
        """区间查询"""
        return self.query(r) - self.query(l - 1)

# 示例
bit = FenwickTree(10)
for i in range(1, 11):
    bit.update(i, i)  # [1,2,3,...,10]

print(f"前5项和: {bit.query(5)}")  # 1+2+3+4+5=15
print(f"区间[3,7]和: {bit.range_query(3, 7)}")  # 3+4+5+6+7=25
```

### 9.3 Trie树（字典树）

```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end = False
        self.count = 0

class Trie:
    def __init__(self):
        self.root = TrieNode()
    
    def insert(self, word):
        """插入单词 O(m)"""
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
            node.count += 1
        node.is_end = True
    
    def search(self, word):
        """搜索单词 O(m)"""
        node = self.root
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        return node.is_end
    
    def starts_with(self, prefix):
        """查找前缀 O(m)"""
        node = self.root
        for char in prefix:
            if char not in node.children:
                return False
            node = node.children[char]
        return True
    
    def count_prefix(self, prefix):
        """统计前缀数量"""
        node = self.root
        for char in prefix:
            if char not in node.children:
                return 0
            node = node.children[char]
        return node.count

# 示例
trie = Trie()
words = ["apple", "app", "application", "apply", "banana"]
for word in words:
    trie.insert(word)

print(trie.search("app"))  # True
print(trie.search("appl"))  # False
print(trie.starts_with("app"))  # True
print(f"'app'前缀数量: {trie.count_prefix('app')}")  # 4
```

### 9.4 并查集（Union-Find）

```python
class UnionFind:
    def __init__(self, n):
        """路径压缩 + 按秩合并"""
        self.parent = list(range(n))
        self.rank = [0] * n
        self.count = n  # 连通分量数
    
    def find(self, x):
        """查找根节点（路径压缩）"""
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def union(self, x, y):
        """合并集合（按秩合并）"""
        root_x = self.find(x)
        root_y = self.find(y)
        
        if root_x == root_y:
            return False
        
        # 按秩合并
        if self.rank[root_x] < self.rank[root_y]:
            self.parent[root_x] = root_y
        elif self.rank[root_x] > self.rank[root_y]:
            self.parent[root_y] = root_x
        else:
            self.parent[root_y] = root_x
            self.rank[root_x] += 1
        
        self.count -= 1
        return True
    
    def connected(self, x, y):
        """判断是否连通"""
        return self.find(x) == self.find(y)

# 应用：Kruskal最小生成树
def kruskal(n, edges):
    """
    n: 节点数
    edges: [(u, v, weight), ...]
    """
    uf = UnionFind(n)
    edges.sort(key=lambda x: x[2])  # 按权重排序
    
    mst = []
    total_weight = 0
    
    for u, v, w in edges:
        if uf.union(u, v):
            mst.append((u, v, w))
            total_weight += w
    
    return mst, total_weight

# 示例
edges = [
    (0, 1, 4), (0, 2, 1), (1, 2, 2),
    (1, 3, 5), (2, 3, 8), (2, 4, 10),
    (3, 4, 2)
]
mst, weight = kruskal(5, edges)
print(f"最小生成树: {mst}")
print(f"总权重: {weight}")
```

---

**本章完**
