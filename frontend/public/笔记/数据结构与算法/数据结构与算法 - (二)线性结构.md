# 数据结构与算法 - (二)线性结构

掌握数组、链表、栈、队列等线性数据结构。

---

## 2. 线性结构

### 2.1 数组

#### 动态数组实现

```python
class DynamicArray:
    def __init__(self):
        self._capacity = 1
        self._size = 0
        self._data = [None] * self._capacity
    
    def append(self, item):
        if self._size == self._capacity:
            self._resize(2 * self._capacity)  # 扩容
        self._data[self._size] = item
        self._size += 1
    
    def _resize(self, new_capacity):
        new_data = [None] * new_capacity
        for i in range(self._size):
            new_data[i] = self._data[i]
        self._data = new_data
        self._capacity = new_capacity
    
    def __getitem__(self, index):
        if not 0 <= index < self._size:
            raise IndexError("Index out of range")
        return self._data[index]
```

**均摊分析：**
- 单次 `append`：O(1)（大部分情况）
- 扩容时：O(n)
- **均摊复杂度**：O(1)

#### 双指针技巧

**示例：两数之和（有序数组）**

```python
def two_sum(arr, target):
    """O(n) 时间，O(1) 空间"""
    left, right = 0, len(arr) - 1
    while left < right:
        current_sum = arr[left] + arr[right]
        if current_sum == target:
            return [left, right]
        elif current_sum < target:
            left += 1
        else:
            right -= 1
    return []
```

#### 滑动窗口

**示例：最长无重复子串**

```python
def length_of_longest_substring(s):
    """滑动窗口 O(n)"""
    char_set = set()
    left = 0
    max_len = 0
    
    for right in range(len(s)):
        while s[right] in char_set:
            char_set.remove(s[left])
            left += 1
        char_set.add(s[right])
        max_len = max(max_len, right - left + 1)
    
    return max_len
```

### 2.2 链表

#### 单链表实现

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class LinkedList:
    def __init__(self):
        self.head = None
    
    def append(self, val):
        """在尾部添加节点"""
        if not self.head:
            self.head = ListNode(val)
            return
        
        current = self.head
        while current.next:
            current = current.next
        current.next = ListNode(val)
    
    def insert(self, index, val):
        """在指定位置插入"""
        if index == 0:
            self.head = ListNode(val, self.head)
            return
        
        current = self.head
        for _ in range(index - 1):
            if not current:
                raise IndexError("Index out of range")
            current = current.next
        current.next = ListNode(val, current.next)
    
    def delete(self, val):
        """删除第一个值为val的节点"""
        if not self.head:
            return
        
        if self.head.val == val:
            self.head = self.head.next
            return
        
        current = self.head
        while current.next and current.next.val != val:
            current = current.next
        
        if current.next:
            current.next = current.next.next
```

#### 反转链表

```python
def reverse_list(head):
    """迭代法 O(n)"""
    prev = None
    current = head
    
    while current:
        next_node = current.next
        current.next = prev
        prev = current
        current = next_node
    
    return prev

def reverse_list_recursive(head):
    """递归法"""
    if not head or not head.next:
        return head
    
    new_head = reverse_list_recursive(head.next)
    head.next.next = head
    head.next = None
    return new_head
```

#### 快慢指针

**检测环：**

```python
def has_cycle(head):
    """Floyd判圈算法"""
    slow = fast = head
    
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
    
    return False

def detect_cycle(head):
    """找到环的起点"""
    slow = fast = head
    
    # 找到相遇点
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            break
    else:
        return None
    
    # 从头和相遇点同时走，再次相遇即为起点
    slow = head
    while slow != fast:
        slow = slow.next
        fast = fast.next
    
    return slow
```

### 2.3 栈

#### 栈的实现

```python
class Stack:
    def __init__(self):
        self._items = []
    
    def push(self, item):
        self._items.append(item)
    
    def pop(self):
        if self.is_empty():
            raise IndexError("Pop from empty stack")
        return self._items.pop()
    
    def peek(self):
        if self.is_empty():
            raise IndexError("Peek from empty stack")
        return self._items[-1]
    
    def is_empty(self):
        return len(self._items) == 0
    
    def size(self):
        return len(self._items)
```

#### 应用：表达式求值

**中缀转后缀（调度场算法）：**

```python
def infix_to_postfix(expression):
    """中缀转后缀"""
    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}
    stack = []
    output = []
    
    for char in expression:
        if char.isalnum():
            output.append(char)
        elif char == '(':
            stack.append(char)
        elif char == ')':
            while stack and stack[-1] != '(':
                output.append(stack.pop())
            stack.pop()  # 弹出 '('
        else:  # 运算符
            while (stack and stack[-1] != '(' and
                   precedence.get(stack[-1], 0) >= precedence[char]):
                output.append(stack.pop())
            stack.append(char)
    
    while stack:
        output.append(stack.pop())
    
    return ''.join(output)

def evaluate_postfix(expression):
    """计算后缀表达式"""
    stack = []
    
    for char in expression:
        if char.isdigit():
            stack.append(int(char))
        else:
            b = stack.pop()
            a = stack.pop()
            if char == '+':
                stack.append(a + b)
            elif char == '-':
                stack.append(a - b)
            elif char == '*':
                stack.append(a * b)
            elif char == '/':
                stack.append(a // b)
    
    return stack[0]
```

#### 单调栈

**下一个更大元素：**

```python
def next_greater_element(nums):
    """单调栈 O(n)"""
    stack = []
    result = [-1] * len(nums)
    
    for i in range(len(nums) - 1, -1, -1):
        while stack and stack[-1] <= nums[i]:
            stack.pop()
        
        if stack:
            result[i] = stack[-1]
        
        stack.append(nums[i])
    
    return result

# 示例
nums = [2, 1, 2, 4, 3]
print(next_greater_element(nums))  # [4, 2, 4, -1, -1]
```

### 2.4 队列

#### 循环队列实现

```python
class CircularQueue:
    def __init__(self, k):
        self.size = k
        self.queue = [None] * k
        self.head = -1
        self.tail = -1
    
    def enqueue(self, value):
        if self.is_full():
            return False
        
        if self.is_empty():
            self.head = 0
        
        self.tail = (self.tail + 1) % self.size
        self.queue[self.tail] = value
        return True
    
    def dequeue(self):
        if self.is_empty():
            return False
        
        if self.head == self.tail:
            self.head = -1
            self.tail = -1
        else:
            self.head = (self.head + 1) % self.size
        
        return True
    
    def is_empty(self):
        return self.head == -1
    
    def is_full(self):
        return (self.tail + 1) % self.size == self.head
```

#### 优先队列（堆）

```python
import heapq

class PriorityQueue:
    def __init__(self):
        self._queue = []
        self._index = 0
    
    def push(self, item, priority):
        heapq.heappush(self._queue, (priority, self._index, item))
        self._index += 1
    
    def pop(self):
        return heapq.heappop(self._queue)[-1]
    
    def is_empty(self):
        return len(self._queue) == 0

# 使用
pq = PriorityQueue()
pq.push("task1", 3)
pq.push("task2", 1)
pq.push("task3", 2)

while not pq.is_empty():
    print(pq.pop())  # task2, task3, task1
```

### 2.5 哈希表

#### 2.5.1 哈希表实现

```python
class HashTable:
    """
    哈希表实现（链地址法）
    """
    def __init__(self, size=10):
        self.size = size
        self.table = [[] for _ in range(size)]
        self.count = 0
    
    def _hash(self, key):
        """哈希函数"""
        return hash(key) % self.size
    
    def put(self, key, value):
        """插入键值对 O(1) 平均"""
        index = self._hash(key)
        
        # 查找是否已存在
        for i, (k, v) in enumerate(self.table[index]):
            if k == key:
                self.table[index][i] = (key, value)
                return
        
        # 新增键值对
        self.table[index].append((key, value))
        self.count += 1
        
        # 动态扩容
        if self.count / self.size > 0.7:
            self._resize()
    
    def get(self, key):
        """获取值 O(1) 平均"""
        index = self._hash(key)
        
        for k, v in self.table[index]:
            if k == key:
                return v
        
        raise KeyError(f"Key {key} not found")
    
    def delete(self, key):
        """删除键值对 O(1) 平均"""
        index = self._hash(key)
        
        for i, (k, v) in enumerate(self.table[index]):
            if k == key:
                self.table[index].pop(i)
                self.count -= 1
                return
        
        raise KeyError(f"Key {key} not found")
    
    def _resize(self):
        """扩容"""
        old_table = self.table
        self.size *= 2
        self.table = [[] for _ in range(self.size)]
        self.count = 0
        
        for bucket in old_table:
            for key, value in bucket:
                self.put(key, value)

# 测试
ht = HashTable()
ht.put("name", "Alice")
ht.put("age", 25)
ht.put("city", "Beijing")

print(f"name: {ht.get('name')}")
print(f"age: {ht.get('age')}")
```

#### 2.5.2 开放寻址法

```python
class OpenAddressingHashTable:
    """
    开放寻址哈希表
    """
    def __init__(self, size=10):
        self.size = size
        self.keys = [None] * size
        self.values = [None] * size
        self.count = 0
    
    def _hash(self, key, i=0):
        """
        双重哈希
        h(k, i) = (h1(k) + i * h2(k)) mod m
        """
        h1 = hash(key) % self.size
        h2 = 1 + (hash(key) % (self.size - 1))
        return (h1 + i * h2) % self.size
    
    def put(self, key, value):
        """插入"""
        i = 0
        while i < self.size:
            index = self._hash(key, i)
            
            if self.keys[index] is None or self.keys[index] == key:
                self.keys[index] = key
                self.values[index] = value
                if self.count / self.size < 0.5:
                    self.count += 1
                return
            
            i += 1
        
        raise Exception("Hash table is full")
    
    def get(self, key):
        """查找"""
        i = 0
        while i < self.size:
            index = self._hash(key, i)
            
            if self.keys[index] == key:
                return self.values[index]
            
            if self.keys[index] is None:
                raise KeyError(f"Key {key} not found")
            
            i += 1
        
        raise KeyError(f"Key {key} not found")
```

#### 2.5.3 一致性哈希

```python
import bisect
import hashlib

class ConsistentHash:
    """
    一致性哈希
    用于分布式系统负载均衡
    """
    def __init__(self, nodes=None, virtual_nodes=150):
        self.virtual_nodes = virtual_nodes
        self.ring = {}
        self.sorted_keys = []
        
        if nodes:
            for node in nodes:
                self.add_node(node)
    
    def _hash(self, key):
        """生成哈希值"""
        return int(hashlib.md5(key.encode()).hexdigest(), 16)
    
    def add_node(self, node):
        """添加节点"""
        for i in range(self.virtual_nodes):
            virtual_key = f"{node}:{i}"
            hash_val = self._hash(virtual_key)
            self.ring[hash_val] = node
            bisect.insort(self.sorted_keys, hash_val)
    
    def remove_node(self, node):
        """移除节点"""
        for i in range(self.virtual_nodes):
            virtual_key = f"{node}:{i}"
            hash_val = self._hash(virtual_key)
            del self.ring[hash_val]
            self.sorted_keys.remove(hash_val)
    
    def get_node(self, key):
        """获取key对应的节点"""
        if not self.ring:
            return None
        
        hash_val = self._hash(key)
        idx = bisect.bisect(self.sorted_keys, hash_val)
        
        if idx == len(self.sorted_keys):
            idx = 0
        
        return self.ring[self.sorted_keys[idx]]

# 测试
ch = ConsistentHash(['server1', 'server2', 'server3'])
keys = ['user1', 'user2', 'user3', 'user4', 'user5']

for key in keys:
    print(f"{key} -> {ch.get_node(key)}")
```

### 2.6 跳表（Skip List）

```python
import random

class SkipNode:
    def __init__(self, key, value, level):
        self.key = key
        self.value = value
        self.forward = [None] * (level + 1)

class SkipList:
    """
    跳表实现
    O(log n) 查找、插入、删除
    """
    def __init__(self, max_level=16, p=0.5):
        self.max_level = max_level
        self.p = p
        self.level = 0
        self.header = SkipNode(None, None, max_level)
    
    def random_level(self):
        """随机生成层级"""
        level = 0
        while random.random() < self.p and level < self.max_level:
            level += 1
        return level
    
    def search(self, key):
        """查找 O(log n)"""
        current = self.header
        
        for i in range(self.level, -1, -1):
            while current.forward[i] and current.forward[i].key < key:
                current = current.forward[i]
        
        current = current.forward[0]
        
        if current and current.key == key:
            return current.value
        
        return None
    
    def insert(self, key, value):
        """插入 O(log n)"""
        update = [None] * (self.max_level + 1)
        current = self.header
        
        # 找到每一层的插入位置
        for i in range(self.level, -1, -1):
            while current.forward[i] and current.forward[i].key < key:
                current = current.forward[i]
            update[i] = current
        
        current = current.forward[0]
        
        # 更新已存在的key
        if current and current.key == key:
            current.value = value
            return
        
        # 插入新节点
        new_level = self.random_level()
        
        if new_level > self.level:
            for i in range(self.level + 1, new_level + 1):
                update[i] = self.header
            self.level = new_level
        
        new_node = SkipNode(key, value, new_level)
        
        for i in range(new_level + 1):
            new_node.forward[i] = update[i].forward[i]
            update[i].forward[i] = new_node
    
    def delete(self, key):
        """删除 O(log n)"""
        update = [None] * (self.max_level + 1)
        current = self.header
        
        for i in range(self.level, -1, -1):
            while current.forward[i] and current.forward[i].key < key:
                current = current.forward[i]
            update[i] = current
        
        current = current.forward[0]
        
        if current and current.key == key:
            for i in range(self.level + 1):
                if update[i].forward[i] != current:
                    break
                update[i].forward[i] = current.forward[i]
            
            while self.level > 0 and self.header.forward[self.level] is None:
                self.level -= 1
    
    def display(self):
        """显示跳表结构"""
        for level in range(self.level, -1, -1):
            print(f"Level {level}: ", end="")
            node = self.header.forward[level]
            while node:
                print(f"{node.key}:{node.value} ", end="")
                node = node.forward[level]
            print()

# 测试
sl = SkipList()
data = [(3, 'C'), (1, 'A'), (4, 'D'), (2, 'B'), (5, 'E')]

for key, value in data:
    sl.insert(key, value)

print("跳表结构:")
sl.display()

print(f"\n查找key=3: {sl.search(3)}")
sl.delete(3)
print("\n删除key=3后:")
sl.display()
```

### 2.7 布隆过滤器（Bloom Filter）

```python
import hashlib
from bitarray import bitarray

class BloomFilter:
    """
    布隆过滤器
    特点：
    - 判断元素一定不存在：100%准确
    - 判断元素可能存在：有误判率
    """
    def __init__(self, size=1000, hash_count=3):
        self.size = size
        self.hash_count = hash_count
        self.bit_array = bitarray(size)
        self.bit_array.setall(0)
    
    def _hashes(self, item):
        """生成多个哈希值"""
        hashes = []
        for i in range(self.hash_count):
            hash_input = f"{item}{i}".encode()
            hash_val = int(hashlib.md5(hash_input).hexdigest(), 16)
            hashes.append(hash_val % self.size)
        return hashes
    
    def add(self, item):
        """添加元素"""
        for hash_val in self._hashes(item):
            self.bit_array[hash_val] = 1
    
    def contains(self, item):
        """检查元素是否可能存在"""
        return all(self.bit_array[hash_val] for hash_val in self._hashes(item))
    
    def false_positive_rate(self):
        """计算误判率"""
        m = self.size
        n = self.bit_array.count(1)
        k = self.hash_count
        
        # (1 - e^(-kn/m))^k
        import math
        return (1 - math.exp(-k * n / m)) ** k

# 简化版（不依赖bitarray）
class SimpleBloomFilter:
    def __init__(self, size=1000, hash_count=3):
        self.size = size
        self.hash_count = hash_count
        self.bits = [0] * size
    
    def _hash(self, item, seed):
        """哈希函数"""
        h = hash(f"{item}{seed}")
        return h % self.size
    
    def add(self, item):
        """添加元素"""
        for i in range(self.hash_count):
            index = self._hash(item, i)
            self.bits[index] = 1
    
    def contains(self, item):
        """检查元素"""
        for i in range(self.hash_count):
            index = self._hash(item, i)
            if self.bits[index] == 0:
                return False
        return True

# 测试
bf = SimpleBloomFilter(size=1000, hash_count=5)

# 添加元素
words = ["apple", "banana", "cherry", "date"]
for word in words:
    bf.add(word)

# 测试
test_words = ["apple", "banana", "grape", "watermelon"]
for word in test_words:
    result = "可能存在" if bf.contains(word) else "一定不存在"
    print(f"{word}: {result}")
```

### 2.8 LRU缓存

```python
class LRUCache:
    """
    LRU (Least Recently Used) 缓存
    使用哈希表 + 双向链表实现 O(1) 操作
    """
    class Node:
        def __init__(self, key=0, value=0):
            self.key = key
            self.value = value
            self.prev = None
            self.next = None
    
    def __init__(self, capacity):
        self.capacity = capacity
        self.cache = {}
        self.head = self.Node()
        self.tail = self.Node()
        self.head.next = self.tail
        self.tail.prev = self.head
    
    def _add_to_head(self, node):
        """添加节点到头部"""
        node.prev = self.head
        node.next = self.head.next
        self.head.next.prev = node
        self.head.next = node
    
    def _remove_node(self, node):
        """移除节点"""
        node.prev.next = node.next
        node.next.prev = node.prev
    
    def _move_to_head(self, node):
        """移动节点到头部"""
        self._remove_node(node)
        self._add_to_head(node)
    
    def _remove_tail(self):
        """移除尾部节点"""
        node = self.tail.prev
        self._remove_node(node)
        return node
    
    def get(self, key):
        """获取值 O(1)"""
        if key not in self.cache:
            return -1
        
        node = self.cache[key]
        self._move_to_head(node)
        return node.value
    
    def put(self, key, value):
        """放入键值对 O(1)"""
        if key in self.cache:
            node = self.cache[key]
            node.value = value
            self._move_to_head(node)
        else:
            node = self.Node(key, value)
            self.cache[key] = node
            self._add_to_head(node)
            
            if len(self.cache) > self.capacity:
                removed = self._remove_tail()
                del self.cache[removed.key]

# 测试
lru = LRUCache(2)
lru.put(1, 1)
lru.put(2, 2)
print(lru.get(1))  # 1
lru.put(3, 3)      # 移除key=2
print(lru.get(2))  # -1 (未找到)
lru.put(4, 4)      # 移除key=1
print(lru.get(1))  # -1 (未找到)
print(lru.get(3))  # 3
print(lru.get(4))  # 4
```

### 2.9 线性结构总结

```python
def linear_structures_summary():
    """
    线性数据结构总结
    """
    print("=" * 90)
    print("线性数据结构性能对比")
    print("=" * 90)
    
    structures = [
        ("数组", "O(1)", "O(n)", "O(n)", "O(n)", "连续内存，随机访问快"),
        ("链表", "O(n)", "O(1)*", "O(1)*", "O(n)", "非连续内存，插入删除快"),
        ("栈", "N/A", "O(1)", "O(1)", "N/A", "LIFO，后进先出"),
        ("队列", "N/A", "O(1)", "O(1)", "N/A", "FIFO，先进先出"),
        ("哈希表", "O(1)", "O(1)", "O(1)", "O(1)", "快速查找，无序"),
        ("跳表", "O(log n)", "O(log n)", "O(log n)", "O(log n)", "有序，概率平衡"),
    ]
    
    print(f"\n{'数据结构':<12} {'访问':<10} {'插入':<10} {'删除':<10} {'查找':<10} {'特点':<30}")
    print("-" * 90)
    
    for name, access, insert, delete, search, feature in structures:
        print(f"{name:<12} {access:<10} {insert:<10} {delete:<10} {search:<10} {feature:<30}")
    
    print("\n*表示在已知位置的情况下")
    
    print("\n" + "=" * 90)
    print("使用场景建议")
    print("=" * 90)
    
    use_cases = [
        ("需要频繁随机访问", "数组"),
        ("频繁插入删除，很少随机访问", "链表"),
        ("函数调用、表达式求值、括号匹配", "栈"),
        ("任务调度、BFS、消息队列", "队列"),
        ("快速查找、缓存", "哈希表"),
        ("有序数据，需要快速插入删除", "跳表"),
        ("大数据去重、判断存在性", "布隆过滤器"),
        ("缓存淘汰策略", "LRU缓存"),
    ]
    
    print(f"\n{'场景':<40} {'推荐数据结构':<20}")
    print("-" * 60)
    
    for scenario, structure in use_cases:
        print(f"{scenario:<40} {structure:<20}")

linear_structures_summary()
```

---

**本章完**
