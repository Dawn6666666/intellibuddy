# 数据结构与算法 - (三)树形结构

学习二叉树、平衡树、堆等树形结构。

---

## 3. 树形结构

### 3.1 二叉树遍历

#### 递归实现

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def preorder(root):
    """前序遍历：根-左-右"""
    if not root:
        return []
    return [root.val] + preorder(root.left) + preorder(root.right)

def inorder(root):
    """中序遍历：左-根-右"""
    if not root:
        return []
    return inorder(root.left) + [root.val] + inorder(root.right)

def postorder(root):
    """后序遍历：左-右-根"""
    if not root:
        return []
    return postorder(root.left) + postorder(root.right) + [root.val]
```

#### 迭代实现（用栈）

```python
def preorder_iterative(root):
    """前序遍历（迭代）"""
    if not root:
        return []
    
    stack = [root]
    result = []
    
    while stack:
        node = stack.pop()
        result.append(node.val)
        
        if node.right:
            stack.append(node.right)
        if node.left:
            stack.append(node.left)
    
    return result

def inorder_iterative(root):
    """中序遍历（迭代）"""
    stack = []
    result = []
    current = root
    
    while current or stack:
        while current:
            stack.append(current)
            current = current.left
        
        current = stack.pop()
        result.append(current.val)
        current = current.right
    
    return result
```

#### 层序遍历（BFS）

```python
from collections import deque

def level_order(root):
    """层序遍历"""
    if not root:
        return []
    
    queue = deque([root])
    result = []
    
    while queue:
        level_size = len(queue)
        current_level = []
        
        for _ in range(level_size):
            node = queue.popleft()
            current_level.append(node.val)
            
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        result.append(current_level)
    
    return result
```

### 3.2 二叉搜索树（BST）

**性质**：左子树 < 根 < 右子树

```python
class BST:
    def __init__(self):
        self.root = None
    
    def insert(self, val):
        """插入节点"""
        if not self.root:
            self.root = TreeNode(val)
        else:
            self._insert_recursive(self.root, val)
    
    def _insert_recursive(self, node, val):
        if val < node.val:
            if node.left:
                self._insert_recursive(node.left, val)
            else:
                node.left = TreeNode(val)
        else:
            if node.right:
                self._insert_recursive(node.right, val)
            else:
                node.right = TreeNode(val)
    
    def search(self, val):
        """查找节点"""
        return self._search_recursive(self.root, val)
    
    def _search_recursive(self, node, val):
        if not node or node.val == val:
            return node
        
        if val < node.val:
            return self._search_recursive(node.left, val)
        else:
            return self._search_recursive(node.right, val)
    
    def delete(self, val):
        """删除节点"""
        self.root = self._delete_recursive(self.root, val)
    
    def _delete_recursive(self, node, val):
        if not node:
            return None
        
        if val < node.val:
            node.left = self._delete_recursive(node.left, val)
        elif val > node.val:
            node.right = self._delete_recursive(node.right, val)
        else:
            # 找到要删除的节点
            if not node.left:
                return node.right
            elif not node.right:
                return node.left
            else:
                # 两个子节点：找右子树最小值替换
                min_node = self._find_min(node.right)
                node.val = min_node.val
                node.right = self._delete_recursive(node.right, min_node.val)
        
        return node
    
    def _find_min(self, node):
        while node.left:
            node = node.left
        return node
```

### 3.3 AVL树（平衡二叉树）

**平衡因子**：左子树高度 - 右子树高度，范围：$[-1, 1]$

```python
class AVLNode:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None
        self.height = 1

class AVLTree:
    def _height(self, node):
        return node.height if node else 0
    
    def _balance_factor(self, node):
        return self._height(node.left) - self._height(node.right)
    
    def _update_height(self, node):
        node.height = 1 + max(self._height(node.left), 
                              self._height(node.right))
    
    def _rotate_left(self, z):
        """左旋"""
        y = z.right
        T2 = y.left
        
        y.left = z
        z.right = T2
        
        self._update_height(z)
        self._update_height(y)
        
        return y
    
    def _rotate_right(self, z):
        """右旋"""
        y = z.left
        T3 = y.right
        
        y.right = z
        z.left = T3
        
        self._update_height(z)
        self._update_height(y)
        
        return y
    
    def insert(self, root, val):
        """插入并保持平衡"""
        if not root:
            return AVLNode(val)
        
        if val < root.val:
            root.left = self.insert(root.left, val)
        else:
            root.right = self.insert(root.right, val)
        
        self._update_height(root)
        balance = self._balance_factor(root)
        
        # LL情况
        if balance > 1 and val < root.left.val:
            return self._rotate_right(root)
        
        # RR情况
        if balance < -1 and val > root.right.val:
            return self._rotate_left(root)
        
        # LR情况
        if balance > 1 and val > root.left.val:
            root.left = self._rotate_left(root.left)
            return self._rotate_right(root)
        
        # RL情况
        if balance < -1 and val < root.right.val:
            root.right = self._rotate_right(root.right)
            return self._rotate_left(root)
        
        return root
```

### 3.4 堆（Heap）

**最小堆实现**：

```python
class MinHeap:
    def __init__(self):
        self.heap = []
    
    def parent(self, i):
        return (i - 1) // 2
    
    def left_child(self, i):
        return 2 * i + 1
    
    def right_child(self, i):
        return 2 * i + 2
    
    def swap(self, i, j):
        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]
    
    def insert(self, val):
        """插入元素 O(log n)"""
        self.heap.append(val)
        self._heapify_up(len(self.heap) - 1)
    
    def _heapify_up(self, i):
        parent = self.parent(i)
        if i > 0 and self.heap[i] < self.heap[parent]:
            self.swap(i, parent)
            self._heapify_up(parent)
    
    def extract_min(self):
        """弹出最小值 O(log n)"""
        if not self.heap:
            return None
        
        if len(self.heap) == 1:
            return self.heap.pop()
        
        min_val = self.heap[0]
        self.heap[0] = self.heap.pop()
        self._heapify_down(0)
        
        return min_val
    
    def _heapify_down(self, i):
        min_index = i
        left = self.left_child(i)
        right = self.right_child(i)
        
        if left < len(self.heap) and self.heap[left] < self.heap[min_index]:
            min_index = left
        
        if right < len(self.heap) and self.heap[right] < self.heap[min_index]:
            min_index = right
        
        if min_index != i:
            self.swap(i, min_index)
            self._heapify_down(min_index)
    
    def heapify(self, arr):
        """建堆 O(n)"""
        self.heap = arr[:]
        for i in range(len(self.heap) // 2 - 1, -1, -1):
            self._heapify_down(i)
```

**堆排序**：

```python
def heap_sort(arr):
    """堆排序 O(n log n)"""
    heap = MinHeap()
    heap.heapify(arr)
    
    result = []
    while heap.heap:
        result.append(heap.extract_min())
    
    return result
```

---

**本章完**
