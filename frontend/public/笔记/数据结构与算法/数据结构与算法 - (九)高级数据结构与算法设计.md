# æ•°æ®ç»“æ„ä¸ç®—æ³• - (ä¹)é«˜çº§æ•°æ®ç»“æ„ä¸ç®—æ³•è®¾è®¡

å­¦ä¹ é«˜çº§æ•°æ®ç»“æ„å’Œç®—æ³•è®¾è®¡æŠ€å·§ã€‚

---

## 9. é«˜çº§æ•°æ®ç»“æ„ä¸ç®—æ³•è®¾è®¡

### 9.1 çº¿æ®µæ ‘ï¼ˆSegment Treeï¼‰

```cpp
class SegmentTree {
private:
    vector<int> tree;
    int n;
    
    void build(vector<int>& arr, int node, int start, int end) {
        if (start == end) {
            tree[node] = arr[start];
        } else {
            int mid = (start + end) / 2;
            int leftNode = 2 * node + 1;
            int rightNode = 2 * node + 2;
            
            build(arr, leftNode, start, mid);
            build(arr, rightNode, mid + 1, end);
            
            tree[node] = tree[leftNode] + tree[rightNode];
        }
    }
    
    void updateHelper(int node, int start, int end, int idx, int val) {
        if (start == end) {
            tree[node] = val;
        } else {
            int mid = (start + end) / 2;
            int leftNode = 2 * node + 1;
            int rightNode = 2 * node + 2;
            
            if (idx <= mid) {
                updateHelper(leftNode, start, mid, idx, val);
            } else {
                updateHelper(rightNode, mid + 1, end, idx, val);
            }
            
            tree[node] = tree[leftNode] + tree[rightNode];
        }
    }
    
    int queryHelper(int node, int start, int end, int L, int R) {
        if (R < start || L > end) {
            return 0;
        }
        
        if (L <= start && end <= R) {
            return tree[node];
        }
        
        int mid = (start + end) / 2;
        int leftNode = 2 * node + 1;
        int rightNode = 2 * node + 2;
        
        int leftSum = queryHelper(leftNode, start, mid, L, R);
        int rightSum = queryHelper(rightNode, mid + 1, end, L, R);
        
        return leftSum + rightSum;
    }
    
public:
    SegmentTree(vector<int>& arr) {
        n = arr.size();
        tree.resize(4 * n);
        build(arr, 0, 0, n - 1);
    }
    
    void update(int idx, int val) {
        updateHelper(0, 0, n - 1, idx, val);
    }
    
    int query(int L, int R) {
        return queryHelper(0, 0, n - 1, L, R);
    }
};

// ä½¿ç”¨ç¤ºä¾‹
void segmentTreeDemo() {
    vector<int> arr = {1, 3, 5, 7, 9, 11};
    SegmentTree st(arr);
    
    cout << "Sum of [1, 3]: " << st.query(1, 3) << endl;  // 3+5+7=15
    
    st.update(1, 10);
    cout << "After update, sum of [1, 3]: " << st.query(1, 3) << endl;  // 10+5+7=22
}
```

### 11.2 æ ‘çŠ¶æ•°ç»„ï¼ˆFenwick Tree / Binary Indexed Treeï¼‰

```cpp
class FenwickTree {
private:
    vector<int> tree;
    int n;
    
    int lowbit(int x) {
        return x & (-x);
    }
    
public:
    FenwickTree(int size) : n(size) {
        tree.resize(n + 1, 0);
    }
    
    // å•ç‚¹æ›´æ–°ï¼šå°†ä½ç½®idxçš„å€¼å¢åŠ delta
    void update(int idx, int delta) {
        while (idx <= n) {
            tree[idx] += delta;
            idx += lowbit(idx);
        }
    }
    
    // å‰ç¼€å’ŒæŸ¥è¯¢ï¼š[1, idx]
    int query(int idx) {
        int sum = 0;
        while (idx > 0) {
            sum += tree[idx];
            idx -= lowbit(idx);
        }
        return sum;
    }
    
    // åŒºé—´å’ŒæŸ¥è¯¢ï¼š[left, right]
    int rangeQuery(int left, int right) {
        return query(right) - query(left - 1);
    }
};

// ä½¿ç”¨ç¤ºä¾‹
void fenwickTreeDemo() {
    FenwickTree ft(10);
    
    // æ„å»ºæ•°ç»„ [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    for (int i = 1; i <= 10; i++) {
        ft.update(i, i);
    }
    
    cout << "Sum [1, 5]: " << ft.query(5) << endl;        // 15
    cout << "Sum [3, 7]: " << ft.rangeQuery(3, 7) << endl;  // 25
    
    ft.update(5, 10);  // å°†ä½ç½®5çš„å€¼å¢åŠ 10
    cout << "After update, sum [1, 5]: " << ft.query(5) << endl;  // 25
}
```

### 11.3 å­—å…¸æ ‘ï¼ˆTrieï¼‰

```cpp
class Trie {
private:
    struct TrieNode {
        unordered_map<char, TrieNode*> children;
        bool isEnd = false;
    };
    
    TrieNode* root;
    
public:
    Trie() {
        root = new TrieNode();
    }
    
    void insert(string word) {
        TrieNode* node = root;
        for (char c : word) {
            if (!node->children.count(c)) {
                node->children[c] = new TrieNode();
            }
            node = node->children[c];
        }
        node->isEnd = true;
    }
    
    bool search(string word) {
        TrieNode* node = root;
        for (char c : word) {
            if (!node->children.count(c)) {
                return false;
            }
            node = node->children[c];
        }
        return node->isEnd;
    }
    
    bool startsWith(string prefix) {
        TrieNode* node = root;
        for (char c : prefix) {
            if (!node->children.count(c)) {
                return false;
            }
            node = node->children[c];
        }
        return true;
    }
    
    // è‡ªåŠ¨è¡¥å…¨
    vector<string> autoComplete(string prefix) {
        vector<string> results;
        TrieNode* node = root;
        
        // æ‰¾åˆ°å‰ç¼€èŠ‚ç‚¹
        for (char c : prefix) {
            if (!node->children.count(c)) {
                return results;
            }
            node = node->children[c];
        }
        
        // DFSæ”¶é›†æ‰€æœ‰å•è¯
        dfs(node, prefix, results);
        return results;
    }
    
private:
    void dfs(TrieNode* node, string current, vector<string>& results) {
        if (node->isEnd) {
            results.push_back(current);
        }
        
        for (auto& [c, child] : node->children) {
            dfs(child, current + c, results);
        }
    }
};
```

### 11.4 å¹¶æŸ¥é›†ï¼ˆUnion-Findï¼‰

```cpp
class UnionFind {
private:
    vector<int> parent;
    vector<int> rank;
    int count;  // è¿é€šåˆ†é‡æ•°é‡
    
public:
    UnionFind(int n) {
        parent.resize(n);
        rank.resize(n, 0);
        count = n;
        
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }
    
    // æŸ¥æ‰¾ï¼ˆè·¯å¾„å‹ç¼©ï¼‰
    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);  // è·¯å¾„å‹ç¼©
        }
        return parent[x];
    }
    
    // åˆå¹¶ï¼ˆæŒ‰ç§©åˆå¹¶ï¼‰
    void unite(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        
        if (rootX == rootY) return;
        
        if (rank[rootX] < rank[rootY]) {
            parent[rootX] = rootY;
        } else if (rank[rootX] > rank[rootY]) {
            parent[rootY] = rootX;
        } else {
            parent[rootY] = rootX;
            rank[rootX]++;
        }
        
        count--;
    }
    
    bool connected(int x, int y) {
        return find(x) == find(y);
    }
    
    int getCount() {
        return count;
    }
};

// åº”ç”¨ï¼šæœ‹å‹åœˆé—®é¢˜ï¼ˆLeetCode 547ï¼‰
int findCircleNum(vector<vector<int>>& isConnected) {
    int n = isConnected.size();
    UnionFind uf(n);
    
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (isConnected[i][j] == 1) {
                uf.unite(i, j);
            }
        }
    }
    
    return uf.getCount();
}
```

---

## 12. ç®—æ³•è®¾è®¡æŠ€å·§

### 12.1 æ»‘åŠ¨çª—å£

```cpp
// æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²ï¼ˆLeetCode 3ï¼‰
int lengthOfLongestSubstring(string s) {
    unordered_map<char, int> window;
    int left = 0, right = 0;
    int maxLen = 0;
    
    while (right < s.length()) {
        char c = s[right];
        right++;
        window[c]++;
        
        // æ”¶ç¼©çª—å£
        while (window[c] > 1) {
            char d = s[left];
            left++;
            window[d]--;
        }
        
        maxLen = max(maxLen, right - left);
    }
    
    return maxLen;
}

// æœ€å°è¦†ç›–å­ä¸²ï¼ˆLeetCode 76ï¼‰
string minWindow(string s, string t) {
    unordered_map<char, int> need, window;
    for (char c : t) need[c]++;
    
    int left = 0, right = 0;
    int valid = 0;
    int start = 0, len = INT_MAX;
    
    while (right < s.length()) {
        char c = s[right];
        right++;
        
        if (need.count(c)) {
            window[c]++;
            if (window[c] == need[c]) {
                valid++;
            }
        }
        
        // æ”¶ç¼©çª—å£
        while (valid == need.size()) {
            if (right - left < len) {
                start = left;
                len = right - left;
            }
            
            char d = s[left];
            left++;
            
            if (need.count(d)) {
                if (window[d] == need[d]) {
                    valid--;
                }
                window[d]--;
            }
        }
    }
    
    return len == INT_MAX ? "" : s.substr(start, len);
}
```

### 12.2 åŒæŒ‡é’ˆæŠ€å·§

```cpp
// ç››æœ€å¤šæ°´çš„å®¹å™¨ï¼ˆLeetCode 11ï¼‰
int maxArea(vector<int>& height) {
    int left = 0, right = height.size() - 1;
    int maxWater = 0;
    
    while (left < right) {
        int area = min(height[left], height[right]) * (right - left);
        maxWater = max(maxWater, area);
        
        // ç§»åŠ¨è¾ƒçŸ­çš„è¾¹
        if (height[left] < height[right]) {
            left++;
        } else {
            right--;
        }
    }
    
    return maxWater;
}

// æ¥é›¨æ°´ï¼ˆLeetCode 42ï¼‰
int trap(vector<int>& height) {
    int left = 0, right = height.size() - 1;
    int leftMax = 0, rightMax = 0;
    int water = 0;
    
    while (left < right) {
        if (height[left] < height[right]) {
            if (height[left] >= leftMax) {
                leftMax = height[left];
            } else {
                water += leftMax - height[left];
            }
            left++;
        } else {
            if (height[right] >= rightMax) {
                rightMax = height[right];
            } else {
                water += rightMax - height[right];
            }
            right--;
        }
    }
    
    return water;
}
```

### 12.3 å›æº¯ç®—æ³•

```cpp
// å…¨æ’åˆ—ï¼ˆLeetCode 46ï¼‰
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>> result;
        vector<int> path;
        vector<bool> used(nums.size(), false);
        backtrack(nums, path, used, result);
        return result;
    }
    
private:
    void backtrack(vector<int>& nums, vector<int>& path, 
                   vector<bool>& used, vector<vector<int>>& result) {
        if (path.size() == nums.size()) {
            result.push_back(path);
            return;
        }
        
        for (int i = 0; i < nums.size(); i++) {
            if (used[i]) continue;
            
            path.push_back(nums[i]);
            used[i] = true;
            
            backtrack(nums, path, used, result);
            
            path.pop_back();
            used[i] = false;
        }
    }
};

// Nçš‡åï¼ˆLeetCode 51ï¼‰
class NQueens {
public:
    vector<vector<string>> solveNQueens(int n) {
        vector<vector<string>> result;
        vector<string> board(n, string(n, '.'));
        backtrack(board, 0, result);
        return result;
    }
    
private:
    void backtrack(vector<string>& board, int row, 
                   vector<vector<string>>& result) {
        int n = board.size();
        
        if (row == n) {
            result.push_back(board);
            return;
        }
        
        for (int col = 0; col < n; col++) {
            if (!isValid(board, row, col)) continue;
            
            board[row][col] = 'Q';
            backtrack(board, row + 1, result);
            board[row][col] = '.';
        }
    }
    
    bool isValid(vector<string>& board, int row, int col) {
        int n = board.size();
        
        // æ£€æŸ¥åˆ—
        for (int i = 0; i < row; i++) {
            if (board[i][col] == 'Q') return false;
        }
        
        // æ£€æŸ¥å·¦ä¸Šå¯¹è§’çº¿
        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
            if (board[i][j] == 'Q') return false;
        }
        
        // æ£€æŸ¥å³ä¸Šå¯¹è§’çº¿
        for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
            if (board[i][j] == 'Q') return false;
        }
        
        return true;
    }
};
```

---

## ğŸ“š å­¦ä¹ å»ºè®®

### åˆ·é¢˜è·¯çº¿

**LeetCodeæ¨èé¡ºåºï¼š**

1. **æ•°ç»„/å­—ç¬¦ä¸²**ï¼ˆ50é¢˜ï¼‰
   - åŒæŒ‡é’ˆã€æ»‘åŠ¨çª—å£
   
2. **é“¾è¡¨**ï¼ˆ30é¢˜ï¼‰
   - å¿«æ…¢æŒ‡é’ˆã€åè½¬

3. **æ ˆ/é˜Ÿåˆ—**ï¼ˆ20é¢˜ï¼‰
   - å•è°ƒæ ˆã€BFS

4. **æ ‘**ï¼ˆ60é¢˜ï¼‰
   - éå†ã€BSTã€è·¯å¾„é—®é¢˜

5. **å›¾**ï¼ˆ30é¢˜ï¼‰
   - DFS/BFSã€æœ€çŸ­è·¯å¾„

6. **åŠ¨æ€è§„åˆ’**ï¼ˆ80é¢˜ï¼‰
   - èƒŒåŒ…ã€LCSã€è‚¡ç¥¨é—®é¢˜

7. **é«˜çº§ç®—æ³•**ï¼ˆ30é¢˜ï¼‰
   - è´ªå¿ƒã€åˆ†æ²»ã€å›æº¯

### å¤ä¹ ç­–ç•¥

**è‰¾å®¾æµ©æ–¯é—å¿˜æ›²çº¿å¤ä¹ æ³•ï¼š**
- Day 1: å­¦ä¹ æ–°çŸ¥è¯†
- Day 2: å¤ä¹ 
- Day 4: å¤ä¹ 
- Day 7: å¤ä¹ 
- Day 15: å¤ä¹ 
- Day 30: å¤ä¹ 

### æ¨èèµ„æº

ğŸ“– **æ•™æï¼š**
- ã€Šç®—æ³•å¯¼è®ºã€‹ï¼ˆCLRSï¼‰
- ã€Šç®—æ³•ç¬¬4ç‰ˆã€‹ï¼ˆSedgewickï¼‰
- ã€Šå‰‘æŒ‡Offerã€‹
- ã€Šç¼–ç¨‹ç ç‘ã€‹

ğŸ¥ **è§†é¢‘ï¼š**
- MIT 6.006 ç®—æ³•å¯¼è®º
- å·¦ç¨‹äº‘ç®—æ³•è¯¾ç¨‹
- èŠ±èŠ±é…±LeetCodeé¢˜è§£

ğŸ’» **å·¥å…·ï¼š**
- [VisuAlgo](https://visualgo.net/) - ç®—æ³•å¯è§†åŒ–
- [Algorithm Visualizer](https://algorithm-visualizer.org/)
- [LeetCode](https://leetcode.com/) - åœ¨çº¿åˆ·é¢˜

### é¢è¯•å‡†å¤‡

**é«˜é¢‘ç®—æ³•é¢˜Top 50ï¼š**
1. ä¸¤æ•°ä¹‹å’Œ
2. ä¸‰æ•°ä¹‹å’Œ
3. åè½¬é“¾è¡¨
4. ç¯å½¢é“¾è¡¨
5. åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨
6. äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦
7. å¯¹ç§°äºŒå‰æ ‘
8. äºŒå‰æ ‘çš„å±‚åºéå†
9. æœ€é•¿å›æ–‡å­ä¸²
10. æœ€å¤§å­æ•°ç»„å’Œ
... ï¼ˆå®Œæ•´åˆ—è¡¨è§LeetCode Hot 100ï¼‰

**æ—¶é—´å¤æ‚åº¦æ€»ç»“ï¼š**

| å¤æ‚åº¦ | åç§° | å…¸å‹ç®—æ³• |
|-------|-----|---------|
| O(1) | å¸¸æ•° | å“ˆå¸Œè¡¨æŸ¥æ‰¾ |
| O(log n) | å¯¹æ•° | äºŒåˆ†æŸ¥æ‰¾ |
| O(n) | çº¿æ€§ | éå†æ•°ç»„ |
| O(n log n) | çº¿æ€§å¯¹æ•° | å½’å¹¶æ’åº |
| O(nÂ²) | å¹³æ–¹ | å†’æ³¡æ’åº |
| O(2â¿) | æŒ‡æ•° | æš´åŠ›é€’å½’ |
| O(n!) | é˜¶ä¹˜ | å…¨æ’åˆ— |

---

> **è®°ä½**ï¼šç®—æ³•ä¸æ˜¯èƒŒå‡ºæ¥çš„ï¼Œæ˜¯ç»ƒå‡ºæ¥çš„ï¼åšæŒæ¯å¤©åˆ·é¢˜ï¼Œ3ä¸ªæœˆåä½ å°†è„±èƒæ¢éª¨ï¼ğŸ’ª
> 
> **å­¦ä¹ è·¯å¾„**ï¼šç†è§£åŸç† â†’ æ‰‹å†™å®ç° â†’ åˆ·é¢˜å·©å›º â†’ æ€»ç»“å½’çº³ â†’ ä¸¾ä¸€åä¸‰

---

**æœ¬ç« å®Œ**

