# 数据结构与算法 - (九)高级数据结构与算法设计

学习高级数据结构和算法设计技巧。

---

## 9. 高级数据结构与算法设计

### 9.1 线段树（Segment Tree）

```cpp
class SegmentTree {
private:
    vector<int> tree;
    int n;
    
    void build(vector<int>& arr, int node, int start, int end) {
        if (start == end) {
            tree[node] = arr[start];
        } else {
            int mid = (start + end) / 2;
            int leftNode = 2 * node + 1;
            int rightNode = 2 * node + 2;
            
            build(arr, leftNode, start, mid);
            build(arr, rightNode, mid + 1, end);
            
            tree[node] = tree[leftNode] + tree[rightNode];
        }
    }
    
    void updateHelper(int node, int start, int end, int idx, int val) {
        if (start == end) {
            tree[node] = val;
        } else {
            int mid = (start + end) / 2;
            int leftNode = 2 * node + 1;
            int rightNode = 2 * node + 2;
            
            if (idx <= mid) {
                updateHelper(leftNode, start, mid, idx, val);
            } else {
                updateHelper(rightNode, mid + 1, end, idx, val);
            }
            
            tree[node] = tree[leftNode] + tree[rightNode];
        }
    }
    
    int queryHelper(int node, int start, int end, int L, int R) {
        if (R < start || L > end) {
            return 0;
        }
        
        if (L <= start && end <= R) {
            return tree[node];
        }
        
        int mid = (start + end) / 2;
        int leftNode = 2 * node + 1;
        int rightNode = 2 * node + 2;
        
        int leftSum = queryHelper(leftNode, start, mid, L, R);
        int rightSum = queryHelper(rightNode, mid + 1, end, L, R);
        
        return leftSum + rightSum;
    }
    
public:
    SegmentTree(vector<int>& arr) {
        n = arr.size();
        tree.resize(4 * n);
        build(arr, 0, 0, n - 1);
    }
    
    void update(int idx, int val) {
        updateHelper(0, 0, n - 1, idx, val);
    }
    
    int query(int L, int R) {
        return queryHelper(0, 0, n - 1, L, R);
    }
};

// 使用示例
void segmentTreeDemo() {
    vector<int> arr = {1, 3, 5, 7, 9, 11};
    SegmentTree st(arr);
    
    cout << "Sum of [1, 3]: " << st.query(1, 3) << endl;  // 3+5+7=15
    
    st.update(1, 10);
    cout << "After update, sum of [1, 3]: " << st.query(1, 3) << endl;  // 10+5+7=22
}
```

### 11.2 树状数组（Fenwick Tree / Binary Indexed Tree）

```cpp
class FenwickTree {
private:
    vector<int> tree;
    int n;
    
    int lowbit(int x) {
        return x & (-x);
    }
    
public:
    FenwickTree(int size) : n(size) {
        tree.resize(n + 1, 0);
    }
    
    // 单点更新：将位置idx的值增加delta
    void update(int idx, int delta) {
        while (idx <= n) {
            tree[idx] += delta;
            idx += lowbit(idx);
        }
    }
    
    // 前缀和查询：[1, idx]
    int query(int idx) {
        int sum = 0;
        while (idx > 0) {
            sum += tree[idx];
            idx -= lowbit(idx);
        }
        return sum;
    }
    
    // 区间和查询：[left, right]
    int rangeQuery(int left, int right) {
        return query(right) - query(left - 1);
    }
};

// 使用示例
void fenwickTreeDemo() {
    FenwickTree ft(10);
    
    // 构建数组 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    for (int i = 1; i <= 10; i++) {
        ft.update(i, i);
    }
    
    cout << "Sum [1, 5]: " << ft.query(5) << endl;        // 15
    cout << "Sum [3, 7]: " << ft.rangeQuery(3, 7) << endl;  // 25
    
    ft.update(5, 10);  // 将位置5的值增加10
    cout << "After update, sum [1, 5]: " << ft.query(5) << endl;  // 25
}
```

### 11.3 字典树（Trie）

```cpp
class Trie {
private:
    struct TrieNode {
        unordered_map<char, TrieNode*> children;
        bool isEnd = false;
    };
    
    TrieNode* root;
    
public:
    Trie() {
        root = new TrieNode();
    }
    
    void insert(string word) {
        TrieNode* node = root;
        for (char c : word) {
            if (!node->children.count(c)) {
                node->children[c] = new TrieNode();
            }
            node = node->children[c];
        }
        node->isEnd = true;
    }
    
    bool search(string word) {
        TrieNode* node = root;
        for (char c : word) {
            if (!node->children.count(c)) {
                return false;
            }
            node = node->children[c];
        }
        return node->isEnd;
    }
    
    bool startsWith(string prefix) {
        TrieNode* node = root;
        for (char c : prefix) {
            if (!node->children.count(c)) {
                return false;
            }
            node = node->children[c];
        }
        return true;
    }
    
    // 自动补全
    vector<string> autoComplete(string prefix) {
        vector<string> results;
        TrieNode* node = root;
        
        // 找到前缀节点
        for (char c : prefix) {
            if (!node->children.count(c)) {
                return results;
            }
            node = node->children[c];
        }
        
        // DFS收集所有单词
        dfs(node, prefix, results);
        return results;
    }
    
private:
    void dfs(TrieNode* node, string current, vector<string>& results) {
        if (node->isEnd) {
            results.push_back(current);
        }
        
        for (auto& [c, child] : node->children) {
            dfs(child, current + c, results);
        }
    }
};
```

### 11.4 并查集（Union-Find）

```cpp
class UnionFind {
private:
    vector<int> parent;
    vector<int> rank;
    int count;  // 连通分量数量
    
public:
    UnionFind(int n) {
        parent.resize(n);
        rank.resize(n, 0);
        count = n;
        
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }
    
    // 查找（路径压缩）
    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);  // 路径压缩
        }
        return parent[x];
    }
    
    // 合并（按秩合并）
    void unite(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        
        if (rootX == rootY) return;
        
        if (rank[rootX] < rank[rootY]) {
            parent[rootX] = rootY;
        } else if (rank[rootX] > rank[rootY]) {
            parent[rootY] = rootX;
        } else {
            parent[rootY] = rootX;
            rank[rootX]++;
        }
        
        count--;
    }
    
    bool connected(int x, int y) {
        return find(x) == find(y);
    }
    
    int getCount() {
        return count;
    }
};

// 应用：朋友圈问题（LeetCode 547）
int findCircleNum(vector<vector<int>>& isConnected) {
    int n = isConnected.size();
    UnionFind uf(n);
    
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (isConnected[i][j] == 1) {
                uf.unite(i, j);
            }
        }
    }
    
    return uf.getCount();
}
```

---

## 12. 算法设计技巧

### 12.1 滑动窗口

```cpp
// 无重复字符的最长子串（LeetCode 3）
int lengthOfLongestSubstring(string s) {
    unordered_map<char, int> window;
    int left = 0, right = 0;
    int maxLen = 0;
    
    while (right < s.length()) {
        char c = s[right];
        right++;
        window[c]++;
        
        // 收缩窗口
        while (window[c] > 1) {
            char d = s[left];
            left++;
            window[d]--;
        }
        
        maxLen = max(maxLen, right - left);
    }
    
    return maxLen;
}

// 最小覆盖子串（LeetCode 76）
string minWindow(string s, string t) {
    unordered_map<char, int> need, window;
    for (char c : t) need[c]++;
    
    int left = 0, right = 0;
    int valid = 0;
    int start = 0, len = INT_MAX;
    
    while (right < s.length()) {
        char c = s[right];
        right++;
        
        if (need.count(c)) {
            window[c]++;
            if (window[c] == need[c]) {
                valid++;
            }
        }
        
        // 收缩窗口
        while (valid == need.size()) {
            if (right - left < len) {
                start = left;
                len = right - left;
            }
            
            char d = s[left];
            left++;
            
            if (need.count(d)) {
                if (window[d] == need[d]) {
                    valid--;
                }
                window[d]--;
            }
        }
    }
    
    return len == INT_MAX ? "" : s.substr(start, len);
}
```

### 12.2 双指针技巧

```cpp
// 盛最多水的容器（LeetCode 11）
int maxArea(vector<int>& height) {
    int left = 0, right = height.size() - 1;
    int maxWater = 0;
    
    while (left < right) {
        int area = min(height[left], height[right]) * (right - left);
        maxWater = max(maxWater, area);
        
        // 移动较短的边
        if (height[left] < height[right]) {
            left++;
        } else {
            right--;
        }
    }
    
    return maxWater;
}

// 接雨水（LeetCode 42）
int trap(vector<int>& height) {
    int left = 0, right = height.size() - 1;
    int leftMax = 0, rightMax = 0;
    int water = 0;
    
    while (left < right) {
        if (height[left] < height[right]) {
            if (height[left] >= leftMax) {
                leftMax = height[left];
            } else {
                water += leftMax - height[left];
            }
            left++;
        } else {
            if (height[right] >= rightMax) {
                rightMax = height[right];
            } else {
                water += rightMax - height[right];
            }
            right--;
        }
    }
    
    return water;
}
```

### 12.3 回溯算法

```cpp
// 全排列（LeetCode 46）
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>> result;
        vector<int> path;
        vector<bool> used(nums.size(), false);
        backtrack(nums, path, used, result);
        return result;
    }
    
private:
    void backtrack(vector<int>& nums, vector<int>& path, 
                   vector<bool>& used, vector<vector<int>>& result) {
        if (path.size() == nums.size()) {
            result.push_back(path);
            return;
        }
        
        for (int i = 0; i < nums.size(); i++) {
            if (used[i]) continue;
            
            path.push_back(nums[i]);
            used[i] = true;
            
            backtrack(nums, path, used, result);
            
            path.pop_back();
            used[i] = false;
        }
    }
};

// N皇后（LeetCode 51）
class NQueens {
public:
    vector<vector<string>> solveNQueens(int n) {
        vector<vector<string>> result;
        vector<string> board(n, string(n, '.'));
        backtrack(board, 0, result);
        return result;
    }
    
private:
    void backtrack(vector<string>& board, int row, 
                   vector<vector<string>>& result) {
        int n = board.size();
        
        if (row == n) {
            result.push_back(board);
            return;
        }
        
        for (int col = 0; col < n; col++) {
            if (!isValid(board, row, col)) continue;
            
            board[row][col] = 'Q';
            backtrack(board, row + 1, result);
            board[row][col] = '.';
        }
    }
    
    bool isValid(vector<string>& board, int row, int col) {
        int n = board.size();
        
        // 检查列
        for (int i = 0; i < row; i++) {
            if (board[i][col] == 'Q') return false;
        }
        
        // 检查左上对角线
        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
            if (board[i][j] == 'Q') return false;
        }
        
        // 检查右上对角线
        for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
            if (board[i][j] == 'Q') return false;
        }
        
        return true;
    }
};
```

---

## 📚 学习建议

### 刷题路线

**LeetCode推荐顺序：**

1. **数组/字符串**（50题）
   - 双指针、滑动窗口
   
2. **链表**（30题）
   - 快慢指针、反转

3. **栈/队列**（20题）
   - 单调栈、BFS

4. **树**（60题）
   - 遍历、BST、路径问题

5. **图**（30题）
   - DFS/BFS、最短路径

6. **动态规划**（80题）
   - 背包、LCS、股票问题

7. **高级算法**（30题）
   - 贪心、分治、回溯

### 复习策略

**艾宾浩斯遗忘曲线复习法：**
- Day 1: 学习新知识
- Day 2: 复习
- Day 4: 复习
- Day 7: 复习
- Day 15: 复习
- Day 30: 复习

### 推荐资源

📖 **教材：**
- 《算法导论》（CLRS）
- 《算法第4版》（Sedgewick）
- 《剑指Offer》
- 《编程珠玑》

🎥 **视频：**
- MIT 6.006 算法导论
- 左程云算法课程
- 花花酱LeetCode题解

💻 **工具：**
- [VisuAlgo](https://visualgo.net/) - 算法可视化
- [Algorithm Visualizer](https://algorithm-visualizer.org/)
- [LeetCode](https://leetcode.com/) - 在线刷题

### 面试准备

**高频算法题Top 50：**
1. 两数之和
2. 三数之和
3. 反转链表
4. 环形链表
5. 合并两个有序链表
6. 二叉树的最大深度
7. 对称二叉树
8. 二叉树的层序遍历
9. 最长回文子串
10. 最大子数组和
... （完整列表见LeetCode Hot 100）

**时间复杂度总结：**

| 复杂度 | 名称 | 典型算法 |
|-------|-----|---------|
| O(1) | 常数 | 哈希表查找 |
| O(log n) | 对数 | 二分查找 |
| O(n) | 线性 | 遍历数组 |
| O(n log n) | 线性对数 | 归并排序 |
| O(n²) | 平方 | 冒泡排序 |
| O(2ⁿ) | 指数 | 暴力递归 |
| O(n!) | 阶乘 | 全排列 |

---

> **记住**：算法不是背出来的，是练出来的！坚持每天刷题，3个月后你将脱胎换骨！💪
> 
> **学习路径**：理解原理 → 手写实现 → 刷题巩固 → 总结归纳 → 举一反三

---

**本章完**

