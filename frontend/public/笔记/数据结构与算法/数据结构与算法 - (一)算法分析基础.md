# 数据结构与算法 - (一)算法分析基础

学习时间复杂度和空间复杂度分析。

---

## 1. 算法分析基础

### 1.1 时间复杂度

**渐进符号：**

| 符号 | 含义 | 说明 |
|------|------|------|
| $O(f(n))$ | 上界 | 最坏情况 |
| $\Omega(f(n))$ | 下界 | 最好情况 |
| $\Theta(f(n))$ | 紧确界 | 平均情况 |

**常见复杂度排序：**

$$
O(1) < O(\log n) < O(n) < O(n \log n) < O(n^2) < O(2^n) < O(n!)
$$

**示例：**

```python
# O(1) - 常数时间
def get_first(arr):
    return arr[0]

# O(n) - 线性时间
def linear_search(arr, target):
    for x in arr:
        if x == target:
            return True
    return False

# O(n²) - 平方时间
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]

# O(log n) - 对数时间
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1

# O(n log n) - 线性对数时间
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    return merge(left, right)
```

### 1.2 主定理（Master Theorem）

对于递归式：

$$
T(n) = aT(\frac{n}{b}) + f(n)
$$

**三种情况：**

1. 若 $f(n) = O(n^{\log_b a - \epsilon})$，则 $T(n) = \Theta(n^{\log_b a})$
2. 若 $f(n) = \Theta(n^{\log_b a})$，则 $T(n) = \Theta(n^{\log_b a} \log n)$
3. 若 $f(n) = \Omega(n^{\log_b a + \epsilon})$，则 $T(n) = \Theta(f(n))$

**应用示例：**

```python
# 归并排序：T(n) = 2T(n/2) + O(n)
# a=2, b=2, f(n)=n
# log₂2 = 1, f(n) = Θ(n¹) → 情况2
# T(n) = Θ(n log n)

# 二分查找：T(n) = T(n/2) + O(1)
# a=1, b=2, f(n)=1
# log₂1 = 0, f(n) = Θ(n⁰) → 情况2
# T(n) = Θ(log n)
```

### 1.3 摊还分析（Amortized Analysis）

摊还分析用于分析一系列操作的平均时间复杂度。

#### 1.3.1 聚合分析

**示例：动态数组扩容**

```python
class DynamicArrayAnalysis:
    """
    动态数组扩容分析
    """
    def __init__(self):
        self.capacity = 1
        self.size = 0
        self.data = [None] * self.capacity
        self.operations = 0  # 操作计数
    
    def append(self, item):
        """添加元素"""
        if self.size == self.capacity:
            # 扩容：需要复制所有元素
            self.operations += self.size
            self.capacity *= 2
            new_data = [None] * self.capacity
            for i in range(self.size):
                new_data[i] = self.data[i]
            self.data = new_data
        
        self.data[self.size] = item
        self.size += 1
        self.operations += 1  # 插入操作
    
    def amortized_cost(self):
        """计算摊还代价"""
        return self.operations / self.size if self.size > 0 else 0

# 测试
arr = DynamicArrayAnalysis()
for i in range(16):
    arr.append(i)
    print(f"n={arr.size}, 总操作={arr.operations}, 摊还={arr.amortized_cost():.2f}")
```

**输出分析：**

```plain
n=1, 总操作=1, 摊还=1.00
n=2, 总操作=3, 摊还=1.50
n=3, 总操作=5, 摊还=1.67
n=4, 总操作=8, 摊还=2.00
n=8, 总操作=20, 摊还=2.50
n=16, 总操作=48, 摊还=3.00
```

**结论**：n次操作总代价 $\leq 3n$，摊还代价 $O(1)$

#### 1.3.2 核算法（Accounting Method）

```python
class StackWithMultiPop:
    """
    支持批量弹出的栈
    """
    def __init__(self):
        self.items = []
        self.credit = 0  # 信用额度
    
    def push(self, item):
        """
        PUSH操作：实际代价=1，摊还代价=2
        存入1个信用用于未来的POP
        """
        self.items.append(item)
        self.credit += 1
        return 2  # 摊还代价
    
    def pop(self):
        """
        POP操作：实际代价=1，摊还代价=0
        使用之前存入的信用
        """
        if self.items:
            self.items.pop()
            self.credit -= 1
            return 0  # 摊还代价
        return 0
    
    def multi_pop(self, k):
        """
        MULTIPOP操作：实际代价=min(k, len)，摊还代价=0
        """
        count = min(k, len(self.items))
        for _ in range(count):
            self.pop()
        return 0  # 摊还代价

# 测试
stack = StackWithMultiPop()
total_amortized = 0

# 10次push
for i in range(10):
    total_amortized += stack.push(i)

# 1次multi_pop(5)
total_amortized += stack.multi_pop(5)

print(f"总摊还代价: {total_amortized}")
print(f"信用余额: {stack.credit}")
```

#### 1.3.3 势能法（Potential Method）

```python
def potential_analysis():
    """
    势能法分析二进制计数器
    """
    print("=" * 60)
    print("势能法：二进制计数器分析")
    print("=" * 60)
    
    class BinaryCounter:
        def __init__(self, k):
            self.bits = [0] * k
            self.k = k
        
        def potential(self):
            """势能函数 = 1的个数"""
            return sum(self.bits)
        
        def increment(self):
            """递增操作"""
            flips = 0
            i = 0
            
            # 找到第一个0，翻转所有1
            while i < self.k and self.bits[i] == 1:
                self.bits[i] = 0
                flips += 1
                i += 1
            
            # 将第一个0翻转为1
            if i < self.k:
                self.bits[i] = 1
                flips += 1
            
            return flips
        
        def amortized_cost(self, actual_cost, delta_potential):
            """摊还代价 = 实际代价 + 势能变化"""
            return actual_cost + delta_potential
    
    counter = BinaryCounter(8)
    
    print(f"\n{'操作':<10} {'实际代价':<10} {'势能变化':<10} {'摊还代价':<10} {'计数器':<20}")
    print("-" * 60)
    
    for i in range(10):
        prev_potential = counter.potential()
        actual = counter.increment()
        curr_potential = counter.potential()
        delta = curr_potential - prev_potential
        amortized = counter.amortized_cost(actual, delta)
        
        bits_str = ''.join(map(str, reversed(counter.bits)))
        print(f"{i+1:<10} {actual:<10} {delta:<10} {amortized:<10} {bits_str:<20}")

potential_analysis()
```

### 1.4 递推关系求解

#### 1.4.1 递推树方法

```python
def recursion_tree_analysis():
    """
    递推树分析
    """
    print("=" * 70)
    print("递推树分析：T(n) = 3T(n/4) + cn²")
    print("=" * 70)
    
    import math
    
    def tree_cost(n, c=1, level=0, max_level=4):
        """计算递推树的代价"""
        if level >= max_level or n <= 1:
            return 0
        
        # 当前层的代价
        nodes_at_level = 3 ** level
        size_at_level = n / (4 ** level)
        cost_per_node = c * (size_at_level ** 2)
        level_cost = nodes_at_level * cost_per_node
        
        indent = "  " * level
        print(f"{indent}Level {level}: {nodes_at_level} nodes, "
              f"size={size_at_level:.2f}, cost={level_cost:.2f}")
        
        return level_cost + tree_cost(n, c, level + 1, max_level)
    
    n = 64
    total = tree_cost(n)
    print(f"\n总代价 ≈ {total:.2f}")
    print(f"理论值: O(n²) = O({n**2})")

recursion_tree_analysis()
```

#### 1.4.2 生成函数

```python
def generating_function_example():
    """
    生成函数求解斐波那契数列
    """
    print("\n" + "=" * 70)
    print("生成函数：斐波那契数列通项公式推导")
    print("=" * 70)
    
    import math
    
    def fibonacci_formula(n):
        """
        通项公式: F(n) = (φⁿ - ψⁿ) / √5
        其中 φ = (1+√5)/2, ψ = (1-√5)/2
        """
        phi = (1 + math.sqrt(5)) / 2
        psi = (1 - math.sqrt(5)) / 2
        
        return int((phi ** n - psi ** n) / math.sqrt(5))
    
    print("\n通项公式验证：")
    print(f"{'n':<5} {'递推':<15} {'公式':<15} {'匹配':<10}")
    print("-" * 45)
    
    # 递推计算
    fib = [0, 1]
    for i in range(2, 15):
        fib.append(fib[-1] + fib[-2])
    
    # 对比
    for i in range(15):
        formula_result = fibonacci_formula(i)
        match = "✓" if fib[i] == formula_result else "✗"
        print(f"{i:<5} {fib[i]:<15} {formula_result:<15} {match:<10}")

generating_function_example()
```

### 1.5 算法设计范式

#### 1.5.1 分治法（Divide and Conquer）

```python
class DivideAndConquer:
    """分治法示例"""
    
    @staticmethod
    def find_maximum_subarray(arr):
        """
        最大子数组和（Kadane改进版）
        使用分治：O(n log n)
        """
        def cross_sum(arr, left, mid, right):
            """计算跨越中点的最大和"""
            # 左半部分
            left_sum = float('-inf')
            curr_sum = 0
            for i in range(mid, left - 1, -1):
                curr_sum += arr[i]
                left_sum = max(left_sum, curr_sum)
            
            # 右半部分
            right_sum = float('-inf')
            curr_sum = 0
            for i in range(mid + 1, right + 1):
                curr_sum += arr[i]
                right_sum = max(right_sum, curr_sum)
            
            return left_sum + right_sum
        
        def helper(arr, left, right):
            if left == right:
                return arr[left]
            
            mid = (left + right) // 2
            
            left_sum = helper(arr, left, mid)
            right_sum = helper(arr, mid + 1, right)
            cross = cross_sum(arr, left, mid, right)
            
            return max(left_sum, right_sum, cross)
        
        return helper(arr, 0, len(arr) - 1)
    
    @staticmethod
    def count_inversions(arr):
        """
        计算逆序对数量
        T(n) = 2T(n/2) + O(n) = O(n log n)
        """
        def merge_and_count(arr, temp, left, mid, right):
            i = left
            j = mid + 1
            k = left
            inv_count = 0
            
            while i <= mid and j <= right:
                if arr[i] <= arr[j]:
                    temp[k] = arr[i]
                    i += 1
                else:
                    temp[k] = arr[j]
                    inv_count += (mid - i + 1)
                    j += 1
                k += 1
            
            while i <= mid:
                temp[k] = arr[i]
                i += 1
                k += 1
            
            while j <= right:
                temp[k] = arr[j]
                j += 1
                k += 1
            
            for i in range(left, right + 1):
                arr[i] = temp[i]
            
            return inv_count
        
        def helper(arr, temp, left, right):
            inv_count = 0
            if left < right:
                mid = (left + right) // 2
                inv_count += helper(arr, temp, left, mid)
                inv_count += helper(arr, temp, mid + 1, right)
                inv_count += merge_and_count(arr, temp, left, mid, right)
            return inv_count
        
        n = len(arr)
        temp = [0] * n
        return helper(arr[:], temp, 0, n - 1)

# 测试
dc = DivideAndConquer()
arr1 = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
print(f"\n最大子数组和: {dc.find_maximum_subarray(arr1)}")

arr2 = [5, 3, 2, 4, 1]
print(f"逆序对数量: {dc.count_inversions(arr2)}")
```

#### 1.5.2 贪心法（Greedy）

```python
class GreedyAlgorithms:
    """贪心算法示例"""
    
    @staticmethod
    def activity_selection(start, finish):
        """
        活动选择问题
        选择最多不重叠的活动
        """
        n = len(start)
        activities = sorted(zip(start, finish), key=lambda x: x[1])
        
        selected = [activities[0]]
        last_finish = activities[0][1]
        
        for i in range(1, n):
            if activities[i][0] >= last_finish:
                selected.append(activities[i])
                last_finish = activities[i][1]
        
        return selected
    
    @staticmethod
    def huffman_coding(freq):
        """
        霍夫曼编码
        构建最优前缀编码
        """
        import heapq
        
        class Node:
            def __init__(self, freq, char=None, left=None, right=None):
                self.freq = freq
                self.char = char
                self.left = left
                self.right = right
            
            def __lt__(self, other):
                return self.freq < other.freq
        
        # 构建优先队列
        heap = [Node(f, c) for c, f in freq.items()]
        heapq.heapify(heap)
        
        # 构建霍夫曼树
        while len(heap) > 1:
            left = heapq.heappop(heap)
            right = heapq.heappop(heap)
            parent = Node(left.freq + right.freq, left=left, right=right)
            heapq.heappush(heap, parent)
        
        # 生成编码
        codes = {}
        
        def generate_codes(node, code=""):
            if node.char:
                codes[node.char] = code
            else:
                if node.left:
                    generate_codes(node.left, code + "0")
                if node.right:
                    generate_codes(node.right, code + "1")
        
        generate_codes(heap[0])
        return codes

# 测试
greedy = GreedyAlgorithms()

start = [1, 3, 0, 5, 8, 5]
finish = [2, 4, 6, 7, 9, 9]
print(f"\n活动选择: {greedy.activity_selection(start, finish)}")

freq = {'a': 5, 'b': 9, 'c': 12, 'd': 13, 'e': 16, 'f': 45}
print(f"霍夫曼编码: {greedy.huffman_coding(freq)}")
```

### 1.6 空间复杂度分析

```python
def space_complexity_examples():
    """
    空间复杂度分析示例
    """
    print("\n" + "=" * 70)
    print("空间复杂度分析")
    print("=" * 70)
    
    import sys
    
    examples = [
        ("O(1) 常数空间", "只使用固定变量", "快速排序（原地）"),
        ("O(log n) 对数空间", "递归深度为log n", "二分查找递归"),
        ("O(n) 线性空间", "额外数组", "归并排序"),
        ("O(n²) 平方空间", "二维数组", "动态规划（Floyd）"),
    ]
    
    print(f"\n{'复杂度':<20} {'说明':<25} {'典型算法':<20}")
    print("-" * 70)
    
    for complexity, desc, example in examples:
        print(f"{complexity:<20} {desc:<25} {example:<20}")
    
    # 实际测量
    print("\n" + "=" * 70)
    print("实际空间占用测量")
    print("=" * 70)
    
    n = 1000
    
    # 测试不同数据结构的空间
    arr = list(range(n))
    set_data = set(range(n))
    dict_data = {i: i for i in range(n)}
    
    print(f"\n数组 ({n}个int): {sys.getsizeof(arr)} bytes")
    print(f"集合 ({n}个int): {sys.getsizeof(set_data)} bytes")
    print(f"字典 ({n}个键值对): {sys.getsizeof(dict_data)} bytes")

space_complexity_examples()
```

### 1.7 算法正确性证明

```python
def algorithm_correctness():
    """
    算法正确性证明方法
    """
    print("\n" + "=" * 70)
    print("算法正确性证明：循环不变式")
    print("=" * 70)
    
    def insertion_sort_with_invariant(arr):
        """
        插入排序 + 循环不变式证明
        
        循环不变式：
        在每次迭代开始时，子数组 arr[0:i] 已经排好序
        
        证明：
        1. 初始化：i=1时，arr[0:1]只有一个元素，已排序 ✓
        2. 保持：假设arr[0:i]已排序，插入arr[i]后arr[0:i+1]仍排序 ✓
        3. 终止：循环结束时i=n，arr[0:n]已排序 ✓
        """
        n = len(arr)
        
        for i in range(1, n):
            key = arr[i]
            j = i - 1
            
            # 不变式检查（仅用于演示）
            print(f"迭代 {i}: arr[0:{i}] = {arr[:i]} (已排序)")
            
            while j >= 0 and arr[j] > key:
                arr[j + 1] = arr[j]
                j -= 1
            
            arr[j + 1] = key
        
        return arr
    
    arr = [5, 2, 4, 6, 1, 3]
    print(f"\n原数组: {arr}")
    result = insertion_sort_with_invariant(arr)
    print(f"排序后: {result}\n")

algorithm_correctness()
```

### 1.8 复杂度分析总结

```python
def complexity_summary():
    """
    复杂度分析总结
    """
    print("=" * 80)
    print("算法复杂度分析总结")
    print("=" * 80)
    
    # 时间复杂度增长率
    import math
    
    n_values = [10, 100, 1000, 10000]
    complexities = [
        ("O(1)", lambda n: 1),
        ("O(log n)", lambda n: math.log2(n)),
        ("O(n)", lambda n: n),
        ("O(n log n)", lambda n: n * math.log2(n)),
        ("O(n²)", lambda n: n ** 2),
        ("O(2ⁿ)", lambda n: 2 ** n if n <= 20 else float('inf')),
    ]
    
    print("\n复杂度增长率对比：")
    print(f"{'复杂度':<15} " + " ".join([f"{n:<15}" for n in n_values]))
    print("-" * 80)
    
    for name, func in complexities:
        values = []
        for n in n_values:
            try:
                val = func(n)
                if val == float('inf'):
                    values.append("∞")
                elif val > 1e10:
                    values.append(f"{val:.2e}")
                else:
                    values.append(f"{int(val):,}")
            except:
                values.append("N/A")
        
        print(f"{name:<15} " + " ".join([f"{v:<15}" for v in values]))
    
    print("\n" + "=" * 80)
    print("常见算法复杂度速查")
    print("=" * 80)
    
    algorithms = [
        ("排序", "快速排序", "O(n log n)", "O(log n)"),
        ("排序", "归并排序", "O(n log n)", "O(n)"),
        ("排序", "堆排序", "O(n log n)", "O(1)"),
        ("搜索", "二分查找", "O(log n)", "O(1)"),
        ("搜索", "深度优先搜索", "O(V+E)", "O(V)"),
        ("搜索", "广度优先搜索", "O(V+E)", "O(V)"),
        ("图", "Dijkstra", "O(V²) / O(E log V)", "O(V)"),
        ("图", "Floyd-Warshall", "O(V³)", "O(V²)"),
        ("树", "AVL插入/删除", "O(log n)", "O(log n)"),
        ("动态规划", "0-1背包", "O(nW)", "O(nW)"),
    ]
    
    print(f"\n{'类别':<10} {'算法':<20} {'时间':<20} {'空间':<15}")
    print("-" * 80)
    
    for category, name, time, space in algorithms:
        print(f"{category:<10} {name:<20} {time:<20} {space:<15}")

complexity_summary()
```

---

**本章完**
