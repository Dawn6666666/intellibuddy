# 离散数学 - (一)数理逻辑

学习命题逻辑和谓词逻辑的基本概念。

---

## 1. 数理逻辑

### 1.1 命题逻辑

#### 命题的概念

**定义**：能判断真假的陈述句称为命题。

**示例：**

| 陈述 | 是否命题 | 真值 |
|------|---------|------|
| "2 + 2 = 4" | ✅ 是 | 真 |
| "今天下雨了" | ✅ 是 | 取决于事实 |
| "请关门" | ❌ 否 | 无真值 |
| "x > 0" | ❌ 否 | 含变量 |

#### 逻辑运算符

| 符号 | 名称 | 读作 | 真值表 |
|------|------|------|--------|
| $\neg$ | 否定 | 非 | $\neg T = F, \neg F = T$ |
| $\land$ | 合取 | 与 | $T \land T = T$，其余为$F$ |
| $\lor$ | 析取 | 或 | $F \lor F = F$，其余为$T$ |
| $\to$ | 蕴含 | 如果...则... | $T \to F = F$，其余为$T$ |
| $\leftrightarrow$ | 等价 | 当且仅当 | 相同为$T$，不同为$F$ |

**真值表示例**：$p \to q$

| $p$ | $q$ | $p \to q$ |
|-----|-----|-----------|
| T | T | T |
| T | F | F |
| F | T | T |
| F | F | T |

#### 逻辑等价式

**重要等价式：**

**1. 双重否定律**

$$
\neg \neg p \equiv p
$$

**2. 德摩根律（De Morgan's Laws）**

$$
\neg (p \land q) \equiv \neg p \lor \neg q
$$

$$
\neg (p \lor q) \equiv \neg p \land \neg q
$$

**3. 分配律**

$$
p \land (q \lor r) \equiv (p \land q) \lor (p \land r)
$$

$$
p \lor (q \land r) \equiv (p \lor q) \land (p \lor r)
$$

**4. 吸收律**

$$
p \lor (p \land q) \equiv p
$$

$$
p \land (p \lor q) \equiv p
$$

**5. 蕴含等价式**

$$
p \to q \equiv \neg p \lor q
$$

**编程应用示例**（C语言）：

```c
// 德摩根律在条件判断中的应用
// !(a && b) 等价于 (!a || !b)

if (!(age >= 18 && hasLicense)) {
    // 等价于
    if (age < 18 || !hasLicense) {
        printf("不能驾驶\n");
    }
}
```

### 1.2 谓词逻辑

#### 量词

**1. 全称量词** $\forall$（For all）

$$
\forall x P(x) \text{ 表示：对所有 } x, P(x) \text{ 为真}
$$

**示例**：$\forall x \in \mathbb{N}, x \geq 0$（所有自然数非负）

**2. 存在量词** $\exists$（There exists）

$$
\exists x P(x) \text{ 表示：存在某个 } x \text{ 使得 } P(x) \text{ 为真}
$$

**示例**：$\exists x \in \mathbb{R}, x^2 = 2$（存在实数的平方等于2）

#### 量词否定

**规则：**

$$
\neg \forall x P(x) \equiv \exists x \neg P(x)
$$

$$
\neg \exists x P(x) \equiv \forall x \neg P(x)
$$

**示例：**

"并非所有人都喜欢编程" 
$$
\neg \forall x \text{ Likes}(x, \text{Programming}) \equiv \exists x \neg \text{Likes}(x, \text{Programming})
$$

等价于 "存在某人不喜欢编程"

**编程应用**（Python）：

```python
# 全称量词：检查所有元素是否满足条件
arr = [2, 4, 6, 8]
all_even = all(x % 2 == 0 for x in arr)  # True

# 存在量词：检查是否存在元素满足条件
any_greater_5 = any(x > 5 for x in arr)  # True
```

### 1.3 推理规则

**基本推理规则：**

**1. 假言推理（Modus Ponens）**

$$
\frac{p \to q, \quad p}{\therefore q}
$$

**2. 拒取式（Modus Tollens）**

$$
\frac{p \to q, \quad \neg q}{\therefore \neg p}
$$

**3. 假言三段论**

$$
\frac{p \to q, \quad q \to r}{\therefore p \to r}
$$

**4. 析取三段论**

$$
\frac{p \lor q, \quad \neg p}{\therefore q}
$$

**5. 合取引入**

$$
\frac{p, \quad q}{\therefore p \land q}
$$

**6. 析取引入**

$$
\frac{p}{\therefore p \lor q}
$$

**应用示例：**

```plain
前提1：如果下雨，则地面湿润（p → q）
前提2：下雨了（p）
结论：地面湿润（q）  [假言推理]
```

**推理链示例：**

```plain
前提1：如果学习努力，则成绩好（p → q）
前提2：如果成绩好，则能毕业（q → r）
前提3：学习努力（p）
---
步骤1：p → r  [假言三段论：前提1, 前提2]
步骤2：r      [假言推理：步骤1, 前提3]
结论：能毕业
```

### 1.4 范式理论

#### 合取范式（CNF）与析取范式（DNF）

**析取范式（DNF - Disjunctive Normal Form）**：

$$
(p_1 \land q_1) \lor (p_2 \land q_2) \lor \cdots \lor (p_n \land q_n)
$$

**合取范式（CNF - Conjunctive Normal Form）**：

$$
(p_1 \lor q_1) \land (p_2 \lor q_2) \land \cdots \land (p_n \land q_n)
$$

**主析取范式（PDNF）**：每个合取项包含所有变量的析取范式。

**示例**：将 $p \to q$ 转换为主析取范式

**步骤1**：化简为基本运算符

$$
p \to q \equiv \neg p \lor q
$$

**步骤2**：展开为包含所有变量

$$
\neg p \lor q \equiv (\neg p \land \neg q) \lor (\neg p \land q) \lor (p \land q)
$$

**真值表验证：**

| $p$ | $q$ | $p \to q$ | 对应项 |
|-----|-----|-----------|--------|
| T | T | T | $p \land q$ |
| T | F | F | - |
| F | T | T | $\neg p \land q$ |
| F | F | T | $\neg p \land \neg q$ |

因此主析取范式为：

$$
(\neg p \land \neg q) \lor (\neg p \land q) \lor (p \land q)
$$

#### 范式的编程应用

```python
class LogicFormula:
    """逻辑公式处理器"""
    
    @staticmethod
    def to_dnf(formula_dict):
        """
        将真值表转换为析取范式
        formula_dict: {(p, q): result, ...}
        """
        dnf_terms = []
        
        for (p, q), result in formula_dict.items():
            if result:  # 只取真值为True的行
                term = []
                term.append('p' if p else '¬p')
                term.append('q' if q else '¬q')
                dnf_terms.append(f"({' ∧ '.join(term)})")
        
        return ' ∨ '.join(dnf_terms)
    
    @staticmethod
    def to_cnf(formula_dict):
        """将真值表转换为合取范式"""
        cnf_clauses = []
        
        for (p, q), result in formula_dict.items():
            if not result:  # 取假值行
                clause = []
                clause.append('¬p' if p else 'p')
                clause.append('¬q' if q else 'q')
                cnf_clauses.append(f"({' ∨ '.join(clause)})")
        
        return ' ∧ '.join(cnf_clauses) if cnf_clauses else "True"

# 示例：p → q 的真值表
implication = {
    (True, True): True,
    (True, False): False,
    (False, True): True,
    (False, False): True
}

processor = LogicFormula()
dnf = processor.to_dnf(implication)
cnf = processor.to_cnf(implication)

print(f"DNF: {dnf}")
# 输出: (p ∧ q) ∨ (¬p ∧ q) ∨ (¬p ∧ ¬q)

print(f"CNF: {cnf}")
# 输出: (¬p ∨ q)
```

### 1.5 布尔代数

#### 布尔代数的公理

布尔代数是集合 $B$ 上定义了两个二元运算（$+$, $\cdot$）和一个一元运算（$'$）的代数系统。

**基本定律：**

| 定律 | 加法形式 | 乘法形式 |
|------|---------|---------|
| 同一律 | $a + 0 = a$ | $a \cdot 1 = a$ |
| 零律 | $a + 1 = 1$ | $a \cdot 0 = 0$ |
| 幂等律 | $a + a = a$ | $a \cdot a = a$ |
| 互补律 | $a + a' = 1$ | $a \cdot a' = 0$ |
| 交换律 | $a + b = b + a$ | $a \cdot b = b \cdot a$ |
| 结合律 | $(a+b)+c = a+(b+c)$ | $(ab)c = a(bc)$ |
| 分配律 | $a(b+c) = ab+ac$ | $a+bc = (a+b)(a+c)$ |
| 吸收律 | $a + ab = a$ | $a(a+b) = a$ |
| 德摩根律 | $(a+b)' = a'b'$ | $(ab)' = a'+b'$ |

#### 布尔表达式化简

**示例1**：化简 $F = ab + ab' + a'b$

**步骤：**

$$
\begin{aligned}
F &= ab + ab' + a'b \\
&= a(b + b') + a'b  \quad \text{[分配律]} \\
&= a \cdot 1 + a'b  \quad \text{[互补律]} \\
&= a + a'b  \quad \text{[同一律]} \\
&= (a + a')(a + b)  \quad \text{[分配律]} \\
&= 1 \cdot (a + b)  \quad \text{[互补律]} \\
&= a + b  \quad \text{[同一律]}
\end{aligned}
$$

**示例2**：化简 $(a + b)(a' + c)(b + c)$

使用**卡诺图（Karnaugh Map）**或**奎因-麦克拉斯基算法**。

```python
class BooleanSimplifier:
    """布尔表达式化简器"""
    
    @staticmethod
    def simplify_by_absorption(expr_terms):
        """
        使用吸收律化简
        expr_terms: 积之和形式，如 ['ab', "ab'", "a'b"]
        """
        simplified = set(expr_terms)
        changed = True
        
        while changed:
            changed = False
            new_terms = set()
            
            for term in simplified:
                absorbed = False
                for other in simplified:
                    if term != other and set(term).issubset(set(other)):
                        absorbed = True
                        break
                
                if not absorbed:
                    new_terms.add(term)
            
            if len(new_terms) < len(simplified):
                simplified = new_terms
                changed = True
        
        return list(simplified)

# 示例
terms = ['ab', 'abc', 'a']
simplified = BooleanSimplifier.simplify_by_absorption(terms)
print(simplified)  # ['a'] (ab和abc被a吸收)
```

#### 数字电路应用

布尔代数是数字电路设计的理论基础。

**逻辑门对应：**

| 逻辑运算 | 逻辑门 | 符号 | 真值表 |
|---------|-------|------|--------|
| $a \land b$ | AND门 | & | 全1为1 |
| $a \lor b$ | OR门 | \| | 有1为1 |
| $\neg a$ | NOT门 | ~ | 取反 |
| $a \oplus b$ | XOR门 | ^ | 不同为1 |
| $\neg (a \land b)$ | NAND门 | ~& | 全1为0 |
| $\neg (a \lor b)$ | NOR门 | ~\| | 全0为1 |

**半加器设计**：

```python
def half_adder(a, b):
    """
    半加器：两个1位二进制数相加
    返回：(sum, carry)
    """
    sum_bit = a ^ b      # XOR：异或得和
    carry = a & b        # AND：与得进位
    return sum_bit, carry

# 真值表验证
print("a b | sum carry")
print("----|----------")
for a in [0, 1]:
    for b in [0, 1]:
        s, c = half_adder(a, b)
        print(f"{a} {b} |  {s}    {c}")
```

**输出：**
```plain
a b | sum carry
----|----------
0 0 |  0    0
0 1 |  1    0
1 0 |  1    0
1 1 |  0    1
```

**全加器设计**：

```python
def full_adder(a, b, cin):
    """
    全加器：三个1位二进制数相加
    a, b: 输入位
    cin: 进位输入
    返回：(sum, cout)
    """
    # 第一级半加器
    s1, c1 = half_adder(a, b)
    # 第二级半加器
    sum_bit, c2 = half_adder(s1, cin)
    # 进位输出
    carry_out = c1 | c2
    
    return sum_bit, carry_out

# 测试：计算 1 + 1 + 1 = 11 (binary)
result_sum, result_carry = full_adder(1, 1, 1)
print(f"Sum: {result_sum}, Carry: {result_carry}")
# 输出: Sum: 1, Carry: 1 (即二进制11)
```

### 1.6 逻辑推理实战

#### 问题1：谁是凶手？

**题目**：三个嫌疑人A、B、C，已知：
+ A说："B是凶手"
+ B说："C是凶手"
+ C说："我不是凶手"
+ 已知三人中只有一人说真话，求凶手是谁？

**分析：**

设命题：
+ $p_A$: A是凶手
+ $p_B$: B是凶手
+ $p_C$: C是凶手

陈述转换：
+ A说的：$p_B$
+ B说的：$p_C$
+ C说的：$\neg p_C$

**情况1**：A说真话（$p_B$为真，$p_C$和$\neg p_C$都为假）

$$
p_B = T, \quad p_C = F, \quad \neg p_C = T
$$

矛盾！（$p_C$和$\neg p_C$不能同时为假）

**情况2**：B说真话（$p_C$为真，$p_B$和$\neg p_C$都为假）

$$
p_C = T, \quad p_B = F, \quad \neg p_C = F
$$

一致！C是凶手。

**情况3**：C说真话（$\neg p_C$为真，$p_B$和$p_C$都为假）

$$
\neg p_C = T \Rightarrow p_C = F, \quad p_B = F, \quad p_C = F
$$

一致，但没有凶手（矛盾）。

**结论**：C是凶手。

**Python实现：**

```python
def solve_logic_puzzle():
    """逻辑推理求解器"""
    
    # 枚举所有可能
    suspects = ['A', 'B', 'C']
    
    for culprit in suspects:
        # 各人的陈述
        a_says = (culprit == 'B')  # A说：B是凶手
        b_says = (culprit == 'C')  # B说：C是凶手
        c_says = (culprit != 'C')  # C说：我不是凶手
        
        statements = [a_says, b_says, c_says]
        
        # 只有一人说真话
        if sum(statements) == 1:
            print(f"凶手是: {culprit}")
            print(f"A说的: {a_says}, B说的: {b_says}, C说的: {c_says}")
            return culprit
    
    return None

solve_logic_puzzle()
```

#### 问题2：骑士与无赖

**题目**：岛上有两类人：
+ **骑士**：总是说真话
+ **无赖**：总是说假话

遇到A、B两人：
+ A说："我们都是无赖"
+ 问A、B分别是什么人？

**分析：**

**假设A是骑士**：
+ A说真话 → "我们都是无赖" 为真
+ → A是无赖（矛盾！）

**假设A是无赖**：
+ A说假话 → "我们都是无赖" 为假
+ → 至少一人不是无赖
+ → A是无赖，则B必须是骑士

**结论**：A是无赖，B是骑士。

**通用求解器：**

```python
def knights_and_knaves(statement_func):
    """
    骑士与无赖问题求解器
    statement_func: 函数，输入(a_is_knight, b_is_knight)，返回陈述是否为真
    """
    for a_is_knight in [True, False]:
        for b_is_knight in [True, False]:
            statement_true = statement_func(a_is_knight, b_is_knight)
            
            # 骑士说真话，无赖说假话
            if a_is_knight == statement_true:
                print(f"A是{'骑士' if a_is_knight else '无赖'}, "
                      f"B是{'骑士' if b_is_knight else '无赖'}")
                return

# 问题："我们都是无赖"
def both_knaves(a_is_knight, b_is_knight):
    return (not a_is_knight) and (not b_is_knight)

knights_and_knaves(both_knaves)
# 输出: A是无赖, B是骑士
```

### 1.7 谓词逻辑的应用

#### 数据库查询与谓词逻辑

SQL查询可以用谓词逻辑表示：

**SQL查询：**
```sql
SELECT name FROM students WHERE age > 18 AND score >= 60
```

**谓词逻辑表示：**

$$
\{x | \text{Student}(x) \land \text{Age}(x) > 18 \land \text{Score}(x) \geq 60\}
$$

**复杂查询示例：**

```sql
SELECT * FROM users WHERE age > 20 OR (city = 'Beijing' AND status = 'active')
```

**谓词逻辑：**

$$
\{x | \text{User}(x) \land (\text{Age}(x) > 20 \lor (\text{City}(x) = \text{Beijing} \land \text{Status}(x) = \text{active}))\}
$$

#### 程序验证与霍尔逻辑

**霍尔三元组**：$\{P\} \, C \, \{Q\}$

+ $P$: 前置条件（Precondition）
+ $C$: 程序语句
+ $Q$: 后置条件（Postcondition）

**示例**：证明赋值语句的正确性

```python
# 程序：x = x + 1
# 前置条件：x = 5
# 后置条件：x = 6
```

**霍尔三元组：**

$$
\{x = 5\} \quad x := x + 1 \quad \{x = 6\}
$$

**赋值公理：**

$$
\{Q[x \to E]\} \quad x := E \quad \{Q\}
$$

其中 $Q[x \to E]$ 表示将 $Q$ 中的 $x$ 替换为 $E$。

**验证：**

$$
Q: x = 6 \\
Q[x \to x+1]: x+1 = 6 \Rightarrow x = 5 \\
\therefore \{x = 5\} \quad x := x + 1 \quad \{x = 6\} \quad \text{正确}
$$

**Python验证框架：**

```python
class HoareLogic:
    """霍尔逻辑验证器（简化版）"""
    
    @staticmethod
    def verify_assignment(precondition, variable, expression, postcondition):
        """
        验证赋值语句
        {P} var := expr {Q}
        """
        # 在后置条件中用表达式替换变量
        # 简化实现：使用字符串替换
        substituted = postcondition.replace(variable, f"({expression})")
        
        print(f"前置条件: {precondition}")
        print(f"赋值: {variable} := {expression}")
        print(f"后置条件: {postcondition}")
        print(f"替换后: {substituted}")
        print(f"验证: {precondition} 应该推出 {substituted}")
        
        return precondition == substituted

# 示例
HoareLogic.verify_assignment(
    precondition="x = 5",
    variable="x",
    expression="x + 1",
    postcondition="x = 6"
)
```

---

**本章完**
