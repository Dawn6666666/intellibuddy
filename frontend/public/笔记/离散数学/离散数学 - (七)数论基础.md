# 离散数学 - (七)数论基础

学习整除、同余等数论基础知识。

---

## 7. 数论基础

### 7.1 整除与同余

**整除**：若存在整数 $k$ 使得 $a = kb$，则称 $b$ 整除 $a$，记作 $b | a$

**性质：**
1. 传递性：$a|b \land b|c \Rightarrow a|c$
2. 线性组合：$a|b \land a|c \Rightarrow a|(mb + nc)$

**同余**：若 $a - b$ 被 $m$ 整除，则称 $a$ 与 $b$ 模 $m$ 同余

$$
a \equiv b \pmod{m} \Leftrightarrow m | (a - b)
$$

**示例：**

$$
17 \equiv 5 \pmod{12} \quad \text{(因为 } 17 - 5 = 12 \text{)}
$$

**同余性质：**

$$
a \equiv b \pmod{m} \land c \equiv d \pmod{m} \Rightarrow
\begin{cases}
a + c \equiv b + d \pmod{m} \\
ac \equiv bd \pmod{m}
\end{cases}
$$

```python
def gcd(a, b):
    """欧几里得算法求最大公约数"""
    while b:
        a, b = b, a % b
    return a

def lcm(a, b):
    """最小公倍数"""
    return a * b // gcd(a, b)

def extended_gcd(a, b):
    """扩展欧几里得算法：求 ax + by = gcd(a,b) 的解"""
    if b == 0:
        return a, 1, 0
    gcd_val, x1, y1 = extended_gcd(b, a % b)
    x = y1
    y = x1 - (a // b) * y1
    return gcd_val, x, y

print(gcd(48, 18))  # 6
print(lcm(48, 18))  # 144

g, x, y = extended_gcd(35, 15)
print(f"35*{x} + 15*{y} = {g}")  # 35*1 + 15*-2 = 5
```

### 7.2 素数与因数分解

**素数判定（试除法）：**

```python
def is_prime(n):
    """判断n是否为素数"""
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

# 埃拉托斯特尼筛法（Sieve of Eratosthenes）
def sieve_of_eratosthenes(n):
    """求 [2, n] 内所有素数"""
    is_prime = [True] * (n + 1)
    is_prime[0] = is_prime[1] = False
    
    for i in range(2, int(n**0.5) + 1):
        if is_prime[i]:
            for j in range(i*i, n + 1, i):
                is_prime[j] = False
    
    return [i for i in range(n + 1) if is_prime[i]]

primes = sieve_of_eratosthenes(100)
print(f"100以内素数: {primes}")
```

**唯一分解定理**：每个大于1的整数都可以唯一地表示为素数的乘积

$$
n = p_1^{e_1} \cdot p_2^{e_2} \cdot \cdots \cdot p_k^{e_k}
$$

```python
def prime_factorization(n):
    """素因数分解"""
    factors = []
    d = 2
    while d * d <= n:
        while n % d == 0:
            factors.append(d)
            n //= d
        d += 1
    if n > 1:
        factors.append(n)
    return factors

print(prime_factorization(84))  # [2, 2, 3, 7]
```

### 7.3 模运算与RSA

**费马小定理**：若 $p$ 是素数，$a$ 不被 $p$ 整除，则

$$
a^{p-1} \equiv 1 \pmod{p}
$$

**欧拉定理**：若 $\gcd(a, m) = 1$，则

$$
a^{\phi(m)} \equiv 1 \pmod{m}
$$

其中 $\phi(m)$ 是欧拉函数（小于 $m$ 且与 $m$ 互质的正整数个数）

**RSA加密基础：**

```python
def mod_exp(base, exp, mod):
    """快速模幂运算 base^exp % mod"""
    result = 1
    base = base % mod
    while exp > 0:
        if exp % 2 == 1:
            result = (result * base) % mod
        exp = exp >> 1
        base = (base * base) % mod
    return result

def euler_phi(n):
    """欧拉函数"""
    result = n
    p = 2
    while p * p <= n:
        if n % p == 0:
            while n % p == 0:
                n //= p
            result -= result // p
        p += 1
    if n > 1:
        result -= result // n
    return result

# RSA简化示例
def simple_rsa():
    # 选择两个素数
    p, q = 61, 53
    n = p * q  # 3233
    phi_n = (p - 1) * (q - 1)  # 3120
    
    # 公钥e（与phi_n互质）
    e = 17
    
    # 私钥d（e*d ≡ 1 mod phi_n）
    _, d, _ = extended_gcd(e, phi_n)
    d = d % phi_n
    
    # 加密消息m
    m = 123
    c = mod_exp(m, e, n)  # 密文
    print(f"明文: {m}, 密文: {c}")
    
    # 解密
    m_decrypted = mod_exp(c, d, n)
    print(f"解密: {m_decrypted}")

simple_rsa()
```

---

**本章完**
