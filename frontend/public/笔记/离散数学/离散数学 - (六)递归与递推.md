# 离散数学 - (六)递归与递推

理解递归关系和递推方法。

---

## 6. 递归与递推

### 6.1 递归关系

**定义**：用自身定义自身的数学关系。

**示例1：斐波那契数列**

$$
F(n) = \begin{cases}
0 & n = 0 \\
1 & n = 1 \\
F(n-1) + F(n-2) & n \geq 2
\end{cases}
$$

**示例2：汉诺塔**

$$
T(n) = \begin{cases}
1 & n = 1 \\
2T(n-1) + 1 & n > 1
\end{cases}
$$

解得：$T(n) = 2^n - 1$

### 6.2 递推方程求解

**特征方程法**（针对线性递推）：

对于递推关系

$$
a_n = c_1 a_{n-1} + c_2 a_{n-2}
$$

特征方程为

$$
r^2 = c_1 r + c_2
$$

**示例**：斐波那契数列

$$
F(n) = F(n-1) + F(n-2)
$$

特征方程：$r^2 = r + 1$

$$
r_{1,2} = \frac{1 \pm \sqrt{5}}{2}
$$

通解：

$$
F(n) = A \cdot \left(\frac{1 + \sqrt{5}}{2}\right)^n + B \cdot \left(\frac{1 - \sqrt{5}}{2}\right)^n
$$

由初值 $F(0) = 0, F(1) = 1$ 确定 $A, B$。

**Python求解递推关系：**

```python
def solve_recurrence(coeffs, initial_values, n):
    """
    求解线性递推关系
    
    参数:
        coeffs: 系数列表 [c1, c2, ...] 对应 a_n = c1*a_{n-1} + c2*a_{n-2} + ...
        initial_values: 初值列表
        n: 要计算的项数
    """
    import numpy as np
    
    k = len(coeffs)
    result = list(initial_values)
    
    for i in range(len(initial_values), n):
        next_val = sum(coeffs[j] * result[i-1-j] for j in range(k))
        result.append(next_val)
    
    return result

# 斐波那契数列 F(n) = F(n-1) + F(n-2)
fib = solve_recurrence([1, 1], [0, 1], 15)
print("斐波那契数列:", fib)  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...]

# 汉诺塔 T(n) = 2T(n-1) + 1
hanoi = solve_recurrence([2, 1], [0, 1], 10)
print("汉诺塔移动次数:", hanoi)  # [0, 1, 3, 7, 15, 31, 63, 127, ...]
```

**生成函数法**（高级）：

对于递推 $a_n = a_{n-1} + a_{n-2}$，引入生成函数

$$
G(x) = \sum_{n=0}^{\infty} a_n x^n
$$

通过代数运算求出 $G(x)$ 的闭形式，然后展开得到 $a_n$。

### 6.3 递归算法分析

**主定理（Master Theorem）**：

对于递推关系 $T(n) = aT(n/b) + f(n)$

**情况1**：若 $f(n) = O(n^{\log_b a - \epsilon})$，则 $T(n) = \Theta(n^{\log_b a})$

**情况2**：若 $f(n) = \Theta(n^{\log_b a})$，则 $T(n) = \Theta(n^{\log_b a} \log n)$

**情况3**：若 $f(n) = \Omega(n^{\log_b a + \epsilon})$ 且满足正则条件，则 $T(n) = \Theta(f(n))$

**示例：**

1. **归并排序**：$T(n) = 2T(n/2) + n$
   - $a = 2, b = 2, f(n) = n$
   - $\log_b a = 1$，$f(n) = \Theta(n^1)$ → 情况2
   - $T(n) = \Theta(n \log n)$

2. **二分查找**：$T(n) = T(n/2) + 1$
   - $a = 1, b = 2, f(n) = 1$
   - $\log_b a = 0$，$f(n) = \Theta(n^0)$ → 情况2
   - $T(n) = \Theta(\log n)$

3. **Strassen矩阵乘法**：$T(n) = 7T(n/2) + n^2$
   - $a = 7, b = 2, f(n) = n^2$
   - $\log_b a \approx 2.81$，$f(n) = O(n^{2.81 - \epsilon})$ → 情况1
   - $T(n) = \Theta(n^{2.81})$

```python
import math

def master_theorem(a, b, d):
    """
    应用主定理分析复杂度
    T(n) = a*T(n/b) + n^d
    
    返回: 复杂度的大O表示
    """
    log_b_a = math.log(a, b)
    
    if d < log_b_a:
        return f"O(n^{log_b_a:.2f})"
    elif d == log_b_a:
        return f"O(n^{d} log n)"
    else:  # d > log_b_a
        return f"O(n^{d})"

print("归并排序:", master_theorem(2, 2, 1))  # O(n^1 log n)
print("二分查找:", master_theorem(1, 2, 0))  # O(n^0 log n) = O(log n)
print("Strassen:", master_theorem(7, 2, 2))  # O(n^2.81)
```

---

## 📚 学习建议

### 学习策略

**1. 理论与实践结合**

每学一个概念，立即用代码实现：
- 集合运算 → Python set
- 图算法 → 实现DFS/BFS
- 组合计数 → 编写计算器

**2. 可视化理解**

- 使用图形工具（Graphviz）绘制图
- 用矩阵表示关系
- 画真值表理解逻辑

**3. 算法应用**

- 逻辑 → 程序正确性证明
- 图论 → 社交网络分析
- 组合 → 算法复杂度分析

### 重点难点

| 章节 | 重点 | 难点 |
|------|------|------|
| 逻辑 | 真值表、等价式 | 量词否定、推理证明 |
| 集合 | 运算律 | 集合的集合 |
| 关系 | 等价关系、偏序 | 关系的复合 |
| 组合 | 排列组合 | 递推方程求解 |
| 图论 | DFS/BFS | 最短路径、MST |

### 实践项目

1. **逻辑表达式求值器**
   - 输入：命题公式
   - 输出：真值表

2. **图算法可视化**
   - 实现Dijkstra、Kruskal
   - 动态显示执行过程

3. **组合数学计算器**
   - 排列组合计算
   - 二项式展开
   - 递推数列求值

### 推荐资源

📖 **教材：**
- 《离散数学及其应用》- Rosen
- 《具体数学》- Knuth

🎥 **视频：**
- MIT 6.042J Mathematics for Computer Science
- Coursera: Discrete Mathematics

💻 **编程练习：**
- LeetCode 图论专题
- Project Euler 组合题

---

## 附录：Python实现集锦

### 集合运算库

```python
class DiscreteSet:
    def __init__(self, elements):
        self.elements = set(elements)
    
    def union(self, other):
        return DiscreteSet(self.elements | other.elements)
    
    def intersection(self, other):
        return DiscreteSet(self.elements & other.elements)
    
    def difference(self, other):
        return DiscreteSet(self.elements - other.elements)
    
    def symmetric_difference(self, other):
        return DiscreteSet(self.elements ^ other.elements)
    
    def power_set(self):
        from itertools import combinations
        result = []
        for i in range(len(self.elements) + 1):
            result.extend(combinations(self.elements, i))
        return [set(s) for s in result]
```

### 图算法库

```python
class Graph:
    def __init__(self):
        self.graph = {}
    
    def add_edge(self, u, v, weight=1):
        if u not in self.graph:
            self.graph[u] = []
        self.graph[u].append((v, weight))
    
    def dfs(self, start):
        visited = set()
        result = []
        
        def helper(node):
            visited.add(node)
            result.append(node)
            for neighbor, _ in self.graph.get(node, []):
                if neighbor not in visited:
                    helper(neighbor)
        
        helper(start)
        return result
```

---

**本章完**
