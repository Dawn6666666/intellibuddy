# 编译原理 - (四)中间代码生成

学习中间代码生成。

---

## 4. 中间代码生成

### 4.1 三地址码

```python
class ThreeAddressCode:
    def __init__(self):
        self.code = []
        self.temp_count = 0
    
    def new_temp(self):
        """生成临时变量"""
        self.temp_count += 1
        return f't{self.temp_count}'
    
    def emit(self, op, arg1, arg2, result):
        """生成三地址码"""
        self.code.append((op, arg1, arg2, result))
    
    def generate(self, node):
        """为AST生成三地址码"""
        if isinstance(node, Num):
            return str(node.value)
        
        elif isinstance(node, BinOp):
            left = self.generate(node.left)
            right = self.generate(node.right)
            temp = self.new_temp()
            
            op_map = {
                'PLUS': '+',
                'MINUS': '-',
                'MUL': '*',
                'DIV': '/'
            }
            
            self.emit(op_map[node.op[0]], left, right, temp)
            return temp
    
    def print_code(self):
        """打印三地址码"""
        for i, (op, arg1, arg2, result) in enumerate(self.code):
            print(f'{i}: {result} = {arg1} {op} {arg2}')

# 测试
lexer = Lexer('2 + 3 * 4')
parser = ASTParser(lexer)
tree = parser.expr()

tac = ThreeAddressCode()
tac.generate(tree)
tac.print_code()
```

---

**本章完**
