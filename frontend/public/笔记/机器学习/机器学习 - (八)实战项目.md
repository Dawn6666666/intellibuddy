# 机器学习 - (八)实战项目

机器学习实战应用。

---

## 8. 实战项目

### 8.1 房价预测（回归）

```python
"""
项目：波士顿房价预测
任务：使用多种回归模型预测房价
数据：sklearn内置数据集
"""

from sklearn.datasets import load_boston
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import mean_squared_error, r2_score

class LinearRegression:
    """线性回归（正规方程）"""
    def __init__(self):
        self.weights = None
    
    def fit(self, X, y):
        """训练"""
        # 添加偏置项
        X_b = np.c_[np.ones((len(X), 1)), X]
        
        # 正规方程：θ = (X^T X)^(-1) X^T y
        self.weights = np.linalg.inv(X_b.T.dot(X_b)).dot(X_b.T).dot(y)
    
    def predict(self, X):
        """预测"""
        X_b = np.c_[np.ones((len(X), 1)), X]
        return X_b.dot(self.weights)

# 加载数据
boston = load_boston()
X, y = boston.data, boston.target

# 数据预处理
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

# 划分数据集
X_train, X_test, y_train, y_test = train_test_split(
    X_scaled, y, test_size=0.2, random_state=42
)

# 训练模型
lr = LinearRegression()
lr.fit(X_train, y_train)

# 预测
y_pred = lr.predict(X_test)

# 评估
mse = mean_squared_error(y_test, y_pred)
rmse = np.sqrt(mse)
r2 = r2_score(y_test, y_pred)

print("=== 房价预测结果 ===")
print(f"RMSE: {rmse:.2f}")
print(f"R²分数: {r2:.4f}")
print(f"\n前5个预测:")
for i in range(5):
    print(f"实际: ${y_test[i]:.2f}k, 预测: ${y_pred[i]:.2f}k")
```

### 8.2 信用卡欺诈检测（分类）

```python
"""
项目：信用卡欺诈检测
任务：不平衡分类问题
技术：SMOTE过采样 + 随机森林
"""

class SMOTE:
    """合成少数类过采样技术"""
    def __init__(self, k_neighbors=5, sampling_rate=1.0):
        self.k_neighbors = k_neighbors
        self.sampling_rate = sampling_rate
    
    def fit_resample(self, X, y):
        """过采样"""
        # 分离多数类和少数类
        minority_class = np.argmin(np.bincount(y))
        majority_class = 1 - minority_class
        
        X_minority = X[y == minority_class]
        X_majority = X[y == majority_class]
        
        # 计算需要合成的样本数
        n_minority = len(X_minority)
        n_majority = len(X_majority)
        n_synthetic = int((n_majority - n_minority) * self.sampling_rate)
        
        # 合成新样本
        synthetic_samples = []
        
        for _ in range(n_synthetic):
            # 随机选择一个少数类样本
            idx = np.random.randint(0, n_minority)
            sample = X_minority[idx]
            
            # 找到k个最近邻
            distances = np.sqrt(np.sum((X_minority - sample) ** 2, axis=1))
            k_nearest = np.argsort(distances)[1:self.k_neighbors+1]
            
            # 随机选择一个邻居
            neighbor_idx = np.random.choice(k_nearest)
            neighbor = X_minority[neighbor_idx]
            
            # 线性插值生成新样本
            alpha = np.random.random()
            synthetic = sample + alpha * (neighbor - sample)
            synthetic_samples.append(synthetic)
        
        # 合并数据
        X_resampled = np.vstack([X, np.array(synthetic_samples)])
        y_resampled = np.hstack([y, np.full(n_synthetic, minority_class)])
        
        return X_resampled, y_resampled

# 模拟不平衡数据
X_imbalanced, y_imbalanced = make_classification(
    n_samples=1000,
    n_features=20,
    weights=[0.95, 0.05],  # 95%正常，5%欺诈
    random_state=42
)

print(f"原始数据分布: {Counter(y_imbalanced)}")

# SMOTE过采样
smote = SMOTE(k_neighbors=5)
X_balanced, y_balanced = smote.fit_resample(X_imbalanced, y_imbalanced)

print(f"过采样后分布: {Counter(y_balanced)}")

# 训练随机森林
rf = RandomForest(n_trees=10, max_depth=10)
rf.fit(X_balanced, y_balanced)

# 评估
y_pred = rf.predict(X_balanced[:100])
print(f"\n前100个样本预测准确率: {np.mean(y_pred == y_balanced[:100]):.4f}")
```

### 8.3 客户细分（聚类）

```python
"""
项目：客户细分（RFM分析）
任务：基于RFM指标进行客户聚类
方法：K-Means聚类
"""

class KMeans:
    """K-Means聚类（改进版）"""
    def __init__(self, k=3, max_iters=100, init='kmeans++'):
        self.k = k
        self.max_iters = max_iters
        self.init = init
        self.centroids = None
        self.labels = None
    
    def kmeans_plus_plus(self, X):
        """K-Means++初始化"""
        n_samples = len(X)
        centroids = []
        
        # 随机选择第一个中心
        centroids.append(X[np.random.randint(n_samples)])
        
        for _ in range(1, self.k):
            # 计算每个点到最近中心的距离
            distances = np.array([
                min([np.linalg.norm(x - c) for c in centroids])
                for x in X
            ])
            
            # 距离越大，被选中的概率越大
            probs = distances / distances.sum()
            cumprobs = np.cumsum(probs)
            r = np.random.random()
            
            for idx, cumprob in enumerate(cumprobs):
                if r < cumprob:
                    centroids.append(X[idx])
                    break
        
        return np.array(centroids)
    
    def fit(self, X):
        """训练"""
        # 初始化中心点
        if self.init == 'kmeans++':
            self.centroids = self.kmeans_plus_plus(X)
        else:
            indices = np.random.choice(len(X), self.k, replace=False)
            self.centroids = X[indices]
        
        for iteration in range(self.max_iters):
            # 分配样本到最近的聚类中心
            distances = np.sqrt(((X - self.centroids[:, np.newaxis])**2).sum(axis=2))
            self.labels = np.argmin(distances, axis=0)
            
            # 更新聚类中心
            new_centroids = np.array([
                X[self.labels == i].mean(axis=0) if np.sum(self.labels == i) > 0 
                else self.centroids[i]
                for i in range(self.k)
            ])
            
            # 检查收敛
            if np.allclose(self.centroids, new_centroids):
                print(f"收敛于第 {iteration} 轮")
                break
            
            self.centroids = new_centroids
        
        return self
    
    def predict(self, X):
        """预测"""
        distances = np.sqrt(((X - self.centroids[:, np.newaxis])**2).sum(axis=2))
        return np.argmin(distances, axis=0)
    
    def inertia(self, X):
        """计算簇内平方和（用于肘部法则）"""
        distances = np.sqrt(((X - self.centroids[:, np.newaxis])**2).sum(axis=2))
        min_distances = np.min(distances, axis=0)
        return np.sum(min_distances ** 2)

# 生成客户RFM数据
np.random.seed(42)
n_customers = 300

# RFM特征
recency = np.random.exponential(30, n_customers)  # 最近一次购买距今天数
frequency = np.random.poisson(5, n_customers)     # 购买频率
monetary = np.random.gamma(2, 50, n_customers)    # 消费金额

X_rfm = np.column_stack([recency, frequency, monetary])

# 标准化
X_rfm_scaled = (X_rfm - X_rfm.mean(axis=0)) / X_rfm.std(axis=0)

# 肘部法则选择k
print("=== 肘部法则 ===")
inertias = []
for k in range(2, 8):
    kmeans = KMeans(k=k, init='kmeans++')
    kmeans.fit(X_rfm_scaled)
    inertia = kmeans.inertia(X_rfm_scaled)
    inertias.append(inertia)
    print(f"k={k}, 簇内平方和: {inertia:.2f}")

# 使用k=4进行聚类
kmeans = KMeans(k=4, init='kmeans++')
kmeans.fit(X_rfm_scaled)

# 分析每个客户群
print("\n=== 客户细分结果 ===")
for i in range(4):
    cluster_data = X_rfm[kmeans.labels == i]
    print(f"\n客户群 {i+1} (样本数: {len(cluster_data)}):")
    print(f"  平均Recency: {cluster_data[:, 0].mean():.1f} 天")
    print(f"  平均Frequency: {cluster_data[:, 1].mean():.1f} 次")
    print(f"  平均Monetary: ${cluster_data[:, 2].mean():.2f}")
```

### 8.4 时间序列预测（ARIMA）

```python
"""
项目：股票价格预测
任务：时间序列分析与预测
方法：移动平均、指数平滑
"""

class ExponentialSmoothing:
    """指数平滑"""
    def __init__(self, alpha=0.3):
        self.alpha = alpha
        self.fitted_values = None
    
    def fit(self, series):
        """拟合"""
        self.fitted_values = [series[0]]
        
        for i in range(1, len(series)):
            smoothed = self.alpha * series[i] + (1 - self.alpha) * self.fitted_values[-1]
            self.fitted_values.append(smoothed)
        
        return self
    
    def predict(self, steps=1):
        """预测"""
        predictions = []
        last_value = self.fitted_values[-1]
        
        for _ in range(steps):
            predictions.append(last_value)
        
        return predictions

class MovingAverage:
    """移动平均"""
    def __init__(self, window=5):
        self.window = window
    
    def fit_predict(self, series):
        """滑动窗口预测"""
        ma = []
        
        for i in range(len(series)):
            if i < self.window:
                ma.append(np.mean(series[:i+1]))
            else:
                ma.append(np.mean(series[i-self.window:i]))
        
        return np.array(ma)

# 生成模拟股票数据
np.random.seed(42)
days = 100
trend = np.linspace(100, 150, days)
seasonal = 10 * np.sin(np.linspace(0, 4*np.pi, days))
noise = np.random.normal(0, 5, days)
stock_price = trend + seasonal + noise

# 训练集和测试集
train_size = 80
train = stock_price[:train_size]
test = stock_price[train_size:]

# 指数平滑
es = ExponentialSmoothing(alpha=0.3)
es.fit(train)
es_pred = es.predict(steps=len(test))

# 移动平均
ma = MovingAverage(window=7)
ma_pred = ma.fit_predict(stock_price)

print("=== 时间序列预测 ===")
print(f"指数平滑预测值: {es_pred}")
print(f"实际值: {test[:5]}")

# 计算误差
mae = np.mean(np.abs(np.array(es_pred) - test))
print(f"\n平均绝对误差（MAE）: {mae:.2f}")
```

---

**本章完**
