# 计算机导论 - (五)算法与数据结构基础

初步了解算法和数据结构的基本概念。

---


### 5.1 算法的概念

**定义**：解决问题的步骤和方法。

**特性：**
1. **有穷性**：有限步骤内完成
2. **确定性**：每步含义明确
3. **输入**：零个或多个输入
4. **输出**：一个或多个输出
5. **可行性**：每步都可实现

### 5.2 算法复杂度

#### 时间复杂度

**常见复杂度：**

| 复杂度 | 名称 | 示例 |
|--------|------|------|
| $O(1)$ | 常数 | 数组访问 |
| $O(\log n)$ | 对数 | 二分查找 |
| $O(n)$ | 线性 | 遍历数组 |
| $O(n \log n)$ | 线性对数 | 归并排序 |
| $O(n^2)$ | 平方 | 冒泡排序 |
| $O(2^n)$ | 指数 | 递归斐波那契 |
| $O(n!)$ | 阶乘 | 全排列 |

**增长趋势：**

$$
O(1) < O(\log n) < O(n) < O(n \log n) < O(n^2) < O(2^n) < O(n!)
$$

#### 空间复杂度

表示算法占用的额外存储空间。

### 5.3 基本数据结构

#### 线性结构

**数组（Array）：**
- 连续存储
- 随机访问 $O(1)$
- 插入删除 $O(n)$

**链表（Linked List）：**
- 非连续存储
- 随机访问 $O(n)$
- 插入删除 $O(1)$

**栈（Stack）：**
- 后进先出（LIFO）
- 操作：push、pop、peek

**队列（Queue）：**
- 先进先出（FIFO）
- 操作：enqueue、dequeue

#### 非线性结构

**树（Tree）：**
- 二叉树
- 二叉搜索树
- 平衡树（AVL、红黑树）

**图（Graph）：**
- 有向图、无向图
- 加权图

**哈希表（Hash Table）：**
- 键值对存储
- 平均 $O(1)$ 访问

### 5.4 经典算法

#### 排序算法

| 算法 | 时间复杂度（平均） | 空间复杂度 | 稳定性 |
|------|-------------------|-----------|--------|
| 冒泡排序 | $O(n^2)$ | $O(1)$ | 稳定 |
| 选择排序 | $O(n^2)$ | $O(1)$ | 不稳定 |
| 插入排序 | $O(n^2)$ | $O(1)$ | 稳定 |
| 快速排序 | $O(n \log n)$ | $O(\log n)$ | 不稳定 |
| 归并排序 | $O(n \log n)$ | $O(n)$ | 稳定 |
| 堆排序 | $O(n \log n)$ | $O(1)$ | 不稳定 |

#### 查找算法

**线性查找：** $O(n)$

**二分查找：** $O(\log n)$（要求有序）

```python
mid = (left + right) // 2
if arr[mid] == target:  # 找到
    return mid
elif arr[mid] < target:  # 搜索右半部分
    left = mid + 1
else:  # 搜索左半部分
    right = mid - 1
```

### 5.5 算法实战案例

#### 案例1：冒泡排序实现

**伪代码：**

```python
def BubbleSort(arr, n):
    for i in range(n):
        for j in range(n - i - 1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
```

**可视化示例：**

对数组 `[5, 2, 8, 1, 9]` 排序：

```plain
初始: [5, 2, 8, 1, 9]

第1轮:
[2, 5, 8, 1, 9]  → 比较5和2，交换
[2, 5, 8, 1, 9]  → 5和8不换
[2, 5, 1, 8, 9]  → 8和1交换
[2, 5, 1, 8, 9]  → 8和9不换

第2轮:
[2, 5, 1, 8, 9]  → 2和5不换
[2, 1, 5, 8, 9]  → 5和1交换
[2, 1, 5, 8, 9]  → 5和8不换

第3轮:
[1, 2, 5, 8, 9]  → 2和1交换
[1, 2, 5, 8, 9]  → 2和5不换

第4轮:
[1, 2, 5, 8, 9]  → 已排序

结果: [1, 2, 5, 8, 9]
```

**复杂度分析：**
- 外层循环：$n-1$ 次
- 内层循环：$(n-1) + (n-2) + ... + 1 = \frac{n(n-1)}{2}$
- 时间复杂度：$O(n^2)$

#### 案例2：二分查找实现

**问题：** 在有序数组 `[1, 3, 5, 7, 9, 11, 13, 15]` 中查找 `7`

**步骤：**

```plain
数组: [1, 3, 5, 7, 9, 11, 13, 15]
索引:  0  1  2  3  4   5   6   7

第1次: left=0, right=7
      mid = (0+7)//2 = 3
      arr[3] = 7 = target ✓ 找到！
```

**另一个例子：** 查找 `11`

```plain
第1次: left=0, right=7
      mid = 3, arr[3] = 7 < 11
      → 搜索右半部分 [9, 11, 13, 15]

第2次: left=4, right=7
      mid = 5, arr[5] = 11 = target ✓ 找到！
```

**复杂度：** $O(\log n)$，最多比较 $\log_2 8 = 3$ 次

#### 案例3：递归算法 - 斐波那契数列

**递归实现：**

```python
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)
```

**调用树（计算 fib(5)）：**

```plain
                    fib(5)
                  /        \
            fib(4)          fib(3)
           /      \        /      \
      fib(3)    fib(2)  fib(2)  fib(1)
      /   \     /   \   /   \
  fib(2) fib(1) f(1) f(0) f(1) f(0)
  /   \
f(1) f(0)
```

**问题：** 大量重复计算，时间复杂度 $O(2^n)$

**优化：** 动态规划

```python
def fibonacci_dp(n):
    if n <= 1:
        return n
    dp = [0] * (n+1)
    dp[1] = 1
    for i in range(2, n+1):
        dp[i] = dp[i-1] + dp[i-2]
    return dp[n]
```

**优化后复杂度：** $O(n)$

#### 案例4：哈希表应用 - 查重

**问题：** 判断数组中是否有重复元素

**方法1：暴力法** $O(n^2)$

```python
for i in range(n):
    for j in range(i+1, n):
        if arr[i] == arr[j]:
            return True
return False
```

**方法2：哈希表** $O(n)$

```python
seen = {}
for num in arr:
    if num in seen:
        return True
    seen[num] = True
return False
```

**示例：**

```plain
数组: [1, 3, 5, 3, 7]

num=1: seen={1}
num=3: seen={1, 3}
num=5: seen={1, 3, 5}
num=3: 已在seen中！返回True
```

### 5.6 算法设计策略

#### 1. 分治法（Divide and Conquer）

**思想：** 将问题分解为子问题，递归求解。

**示例：** 归并排序

```python
def MergeSort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = MergeSort(arr[0:mid])
    right = MergeSort(arr[mid:])
    return Merge(left, right)
```

#### 2. 贪心算法（Greedy）

**思想：** 每步选择当前最优解。

**示例：** 找零钱问题

```plain
硬币：25¢, 10¢, 5¢, 1¢
找67¢：2×25¢ + 1×10¢ + 1×5¢ + 2×1¢
```

#### 3. 动态规划（Dynamic Programming）

**思想：** 保存子问题解，避免重复计算。

**示例：** 背包问题、最长公共子序列

#### 4. 回溯法（Backtracking）

**思想：** 尝试所有可能，不满足则回退。

**示例：** N皇后问题、数独求解

### 5.7 高级数据结构

#### 树结构进阶

**二叉搜索树（BST）：**

**性质：**
- 左子树所有节点 < 根节点
- 右子树所有节点 > 根节点
- 左右子树也是BST

**操作复杂度：**

| 操作 | 平均 | 最坏 |
|------|------|------|
| 查找 | $O(\log n)$ | $O(n)$ |
| 插入 | $O(\log n)$ | $O(n)$ |
| 删除 | $O(\log n)$ | $O(n)$ |

**平衡二叉树（AVL）：**

**平衡因子：** 左右子树高度差 $\leq 1$

**旋转操作：**
- LL旋转（右旋）
- RR旋转（左旋）
- LR旋转（先左后右）
- RL旋转（先右后左）

**红黑树：**

**性质：**
1. 节点是红色或黑色
2. 根节点是黑色
3. 叶节点（NIL）是黑色
4. 红节点的子节点必须是黑色
5. 从任一节点到叶节点的所有路径包含相同数量的黑节点

**应用：**
- C++ STL的 `map`, `set`
- Java的 `TreeMap`, `TreeSet`
- Linux内核的进程调度

**B树/B+树：**

| 特性 | B树 | B+树 |
|------|-----|------|
| 数据存储 | 所有节点 | 仅叶节点 |
| 叶节点连接 | 无 | 有链表 |
| 范围查询 | 较慢 | 快 |
| 应用 | 文件系统 | 数据库索引 |

#### 堆（Heap）

**最大堆性质：** 父节点 ≥ 子节点

**操作：**

| 操作 | 复杂度 |
|------|--------|
| 插入 | $O(\log n)$ |
| 删除最大值 | $O(\log n)$ |
| 构建堆 | $O(n)$ |

**应用：**
- 优先队列
- 堆排序
- TopK问题

```python
import heapq

class PriorityQueue:
    """优先队列实现"""
    
    def __init__(self):
        self.heap = []
    
    def push(self, item, priority):
        """插入元素（优先级越小越优先）"""
        heapq.heappush(self.heap, (priority, item))
    
    def pop(self):
        """弹出最高优先级元素"""
        return heapq.heappop(self.heap)[1]
    
    def empty(self):
        """是否为空"""
        return len(self.heap) == 0

# 示例：任务调度
pq = PriorityQueue()
pq.push("低优先级任务", 10)
pq.push("高优先级任务", 1)
pq.push("中优先级任务", 5)

while not pq.empty():
    print(pq.pop())
# 输出：高优先级任务 → 中优先级任务 → 低优先级任务
```

#### 并查集（Union-Find）

**应用：** 动态连通性、最小生成树

```python
class UnionFind:
    """并查集（路径压缩 + 按秩合并）"""
    
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n
    
    def find(self, x):
        """查找根节点（路径压缩）"""
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def union(self, x, y):
        """合并两个集合（按秩合并）"""
        root_x = self.find(x)
        root_y = self.find(y)
        
        if root_x == root_y:
            return False
        
        if self.rank[root_x] < self.rank[root_y]:
            self.parent[root_x] = root_y
        elif self.rank[root_x] > self.rank[root_y]:
            self.parent[root_y] = root_x
        else:
            self.parent[root_y] = root_x
            self.rank[root_x] += 1
        
        return True
    
    def connected(self, x, y):
        """判断是否连通"""
        return self.find(x) == self.find(y)

# 示例：判断图中是否有环
edges = [(0, 1), (1, 2), (2, 3), (3, 1)]  # 最后一条边形成环
uf = UnionFind(4)

for u, v in edges:
    if uf.connected(u, v):
        print(f"发现环：{u} - {v}")
        break
    uf.union(u, v)
```

### 5.8 图算法

#### 图的表示

**邻接矩阵：**

$$
\text{matrix}[i][j] = \begin{cases}
1 & \text{若存在边 } (i, j) \\
0 & \text{否则}
\end{cases}
$$

**邻接表：**

```python
graph = {
    0: [1, 2],
    1: [0, 3],
    2: [0, 3],
    3: [1, 2]
}
```

**对比：**

| 特性 | 邻接矩阵 | 邻接表 |
|------|----------|--------|
| 空间复杂度 | $O(V^2)$ | $O(V + E)$ |
| 查找边 | $O(1)$ | $O(V)$ |
| 遍历邻居 | $O(V)$ | $O(degree)$ |
| 适用场景 | 稠密图 | 稀疏图 |

#### 图遍历算法

**深度优先搜索（DFS）：**

```python
def dfs(graph, start, visited=None):
    """深度优先搜索"""
    if visited is None:
        visited = set()
    
    visited.add(start)
    print(start, end=' ')
    
    for neighbor in graph[start]:
        if neighbor not in visited:
            dfs(graph, neighbor, visited)

# 示例
graph = {
    0: [1, 2],
    1: [0, 3, 4],
    2: [0, 5],
    3: [1],
    4: [1],
    5: [2]
}

dfs(graph, 0)  # 输出：0 1 3 4 2 5
```

**广度优先搜索（BFS）：**

```python
from collections import deque

def bfs(graph, start):
    """广度优先搜索"""
    visited = set([start])
    queue = deque([start])
    
    while queue:
        node = queue.popleft()
        print(node, end=' ')
        
        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)

bfs(graph, 0)  # 输出：0 1 2 3 4 5
```

#### 最短路径算法

**Dijkstra算法（单源最短路径）：**

```python
import heapq

def dijkstra(graph, start):
    """Dijkstra最短路径算法"""
    dist = {node: float('inf') for node in graph}
    dist[start] = 0
    pq = [(0, start)]
    
    while pq:
        d, u = heapq.heappop(pq)
        
        if d > dist[u]:
            continue
        
        for v, weight in graph[u]:
            if dist[u] + weight < dist[v]:
                dist[v] = dist[u] + weight
                heapq.heappush(pq, (dist[v], v))
    
    return dist

# 示例：带权图
graph = {
    'A': [('B', 4), ('C', 2)],
    'B': [('A', 4), ('C', 1), ('D', 5)],
    'C': [('A', 2), ('B', 1), ('D', 8)],
    'D': [('B', 5), ('C', 8)]
}

distances = dijkstra(graph, 'A')
print(distances)  # {'A': 0, 'B': 3, 'C': 2, 'D': 8}
```

**Floyd-Warshall算法（全源最短路径）：**

```python
def floyd_warshall(graph, n):
    """Floyd-Warshall全源最短路径"""
    # 初始化距离矩阵
    dist = [[float('inf')] * n for _ in range(n)]
    
    for i in range(n):
        dist[i][i] = 0
    
    for u, v, w in graph:
        dist[u][v] = w
    
    # 动态规划
    for k in range(n):
        for i in range(n):
            for j in range(n):
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
    
    return dist

# 示例
edges = [(0, 1, 3), (0, 2, 8), (1, 2, 1), (2, 3, 5)]
dist = floyd_warshall(edges, 4)
```

#### 最小生成树

**Kruskal算法：**

```python
def kruskal(n, edges):
    """Kruskal最小生成树（贪心 + 并查集）"""
    # 按权重排序
    edges.sort(key=lambda x: x[2])
    
    uf = UnionFind(n)
    mst = []
    total_weight = 0
    
    for u, v, weight in edges:
        if uf.union(u, v):
            mst.append((u, v, weight))
            total_weight += weight
    
    return mst, total_weight

# 示例
edges = [(0, 1, 4), (0, 2, 3), (1, 2, 1), (1, 3, 2), (2, 3, 4)]
mst, weight = kruskal(4, edges)
print(f"MST: {mst}, 总权重: {weight}")
```

### 5.9 动态规划实战

#### 经典DP问题

**1. 0-1背包问题**

```python
def knapsack(weights, values, capacity):
    """0-1背包（物品只能选一次）"""
    n = len(weights)
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]
    
    for i in range(1, n + 1):
        for w in range(capacity + 1):
            if weights[i-1] <= w:
                dp[i][w] = max(
                    dp[i-1][w],  # 不选
                    dp[i-1][w - weights[i-1]] + values[i-1]  # 选
                )
            else:
                dp[i][w] = dp[i-1][w]
    
    return dp[n][capacity]

# 示例
weights = [2, 3, 4, 5]
values = [3, 4, 5, 6]
capacity = 8

max_value = knapsack(weights, values, capacity)
print(f"最大价值: {max_value}")  # 输出：10
```

**2. 最长公共子序列（LCS）**

```python
def lcs(s1, s2):
    """最长公共子序列"""
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    
    return dp[m][n]

# 示例
s1 = "ABCDGH"
s2 = "AEDFHR"
print(f"LCS长度: {lcs(s1, s2)}")  # 输出：3 (ADH)
```

**3. 编辑距离**

```python
def edit_distance(word1, word2):
    """编辑距离（Levenshtein距离）"""
    m, n = len(word1), len(word2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    # 初始化
    for i in range(m + 1):
        dp[i][0] = i
    for j in range(n + 1):
        dp[0][j] = j
    
    # 动态规划
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if word1[i-1] == word2[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = min(
                    dp[i-1][j] + 1,    # 删除
                    dp[i][j-1] + 1,    # 插入
                    dp[i-1][j-1] + 1   # 替换
                )
    
    return dp[m][n]

# 示例
print(edit_distance("horse", "ros"))  # 输出：3
```

**4. 最大子数组和（Kadane算法）**

```python
def max_subarray(nums):
    """最大子数组和"""
    max_sum = nums[0]
    current_sum = nums[0]
    
    for i in range(1, len(nums)):
        current_sum = max(nums[i], current_sum + nums[i])
        max_sum = max(max_sum, current_sum)
    
    return max_sum

# 示例
nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
print(f"最大子数组和: {max_subarray(nums)}")  # 输出：6 ([4,-1,2,1])
```

### 5.10 算法复杂度总结

#### 常见算法复杂度

| 算法 | 最好 | 平均 | 最坏 | 空间 |
|------|------|------|------|------|
| **排序** | | | | |
| 冒泡排序 | $O(n)$ | $O(n^2)$ | $O(n^2)$ | $O(1)$ |
| 快速排序 | $O(n \log n)$ | $O(n \log n)$ | $O(n^2)$ | $O(\log n)$ |
| 归并排序 | $O(n \log n)$ | $O(n \log n)$ | $O(n \log n)$ | $O(n)$ |
| 堆排序 | $O(n \log n)$ | $O(n \log n)$ | $O(n \log n)$ | $O(1)$ |
| **查找** | | | | |
| 线性查找 | $O(1)$ | $O(n)$ | $O(n)$ | $O(1)$ |
| 二分查找 | $O(1)$ | $O(\log n)$ | $O(\log n)$ | $O(1)$ |
| **图算法** | | | | |
| DFS | $O(V + E)$ | $O(V + E)$ | $O(V + E)$ | $O(V)$ |
| BFS | $O(V + E)$ | $O(V + E)$ | $O(V + E)$ | $O(V)$ |
| Dijkstra | $O((V+E) \log V)$ | $O((V+E) \log V)$ | $O((V+E) \log V)$ | $O(V)$ |
| Floyd-Warshall | $O(V^3)$ | $O(V^3)$ | $O(V^3)$ | $O(V^2)$ |

#### 复杂度比较

**不同输入规模的可行性：**

| 复杂度 | n=10 | n=100 | n=1000 | n=10000 | n=100000 |
|--------|------|-------|--------|---------|----------|
| $O(1)$ | 1 | 1 | 1 | 1 | 1 |
| $O(\log n)$ | 3 | 7 | 10 | 13 | 17 |
| $O(n)$ | 10 | 100 | 1K | 10K | 100K |
| $O(n \log n)$ | 30 | 700 | 10K | 130K | 1.7M |
| $O(n^2)$ | 100 | 10K | 1M | 100M | 10B |
| $O(2^n)$ | 1K | 1.3e30 | ∞ | ∞ | ∞ |

---

**本章完**