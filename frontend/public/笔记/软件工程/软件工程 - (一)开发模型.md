# 软件工程 - (一)开发模型

理解软件开发生命周期。

---

## 1. 开发模型

### 1.1 瀑布模型

```plain
需求 ↓
设计 ↓
实现 ↓
测试 ↓
维护
```

### 1.2 敏捷开发（Scrum）

**Sprint流程：**

```plain
产品待办 → Sprint计划 → 每日站会 → Sprint评审 → Sprint回顾
```

```python
class Scrum:
    def __init__(self, sprint_days=14):
        self.backlog = []
        self.sprint_backlog = []
        self.sprint_days = sprint_days
    
    def add_user_story(self, story, points):
        """添加用户故事"""
        self.backlog.append({'story': story, 'points': points})
    
    def start_sprint(self, capacity):
        """开始Sprint"""
        total_points = 0
        for item in self.backlog:
            if total_points + item['points'] <= capacity:
                self.sprint_backlog.append(item)
                total_points += item['points']
        
        print(f"Sprint开始，包含{len(self.sprint_backlog)}个故事，{total_points}点")
```

### 1.3 V模型

V模型是瀑布模型的变种，强调测试与开发的对应关系。

```plain
需求分析 ←→ 验收测试
  ↓           ↑
系统设计 ←→ 系统测试
  ↓           ↑
详细设计 ←→ 集成测试
  ↓           ↑
编码实现 ←→ 单元测试
```

**特点：**

+ 每个开发阶段都有对应的测试阶段
+ 强调测试计划要在开发早期制定
+ 适合需求明确、变更少的项目

```python
class VModel:
    """V模型开发流程"""
    
    def __init__(self):
        self.phases = {
            '需求分析': {'产物': '需求规格说明', '测试': '验收测试计划'},
            '系统设计': {'产物': '系统设计文档', '测试': '系统测试计划'},
            '详细设计': {'产物': '详细设计文档', '测试': '集成测试计划'},
            '编码实现': {'产物': '源代码', '测试': '单元测试用例'},
        }
    
    def execute_phase(self, phase_name):
        """执行开发阶段"""
        if phase_name in self.phases:
            phase = self.phases[phase_name]
            print(f"\n=== {phase_name} ===")
            print(f"产出: {phase['产物']}")
            print(f"同步: {phase['测试']}")
            return True
        return False
    
    def run_full_cycle(self):
        """完整V模型流程"""
        print("V模型开发流程启动\n")
        
        # 左侧：开发阶段
        for phase in ['需求分析', '系统设计', '详细设计', '编码实现']:
            self.execute_phase(phase)
        
        # 右侧：测试阶段
        print("\n" + "="*50)
        print("测试验证阶段")
        print("="*50)
        
        for test in ['单元测试', '集成测试', '系统测试', '验收测试']:
            print(f"\n执行: {test}")

# 演示
v_model = VModel()
v_model.run_full_cycle()
```

### 1.4 螺旋模型

螺旋模型结合了瀑布模型和原型开发的优点，强调风险分析。

```plain
第一圈:
  1.制定计划 → 2.风险分析 → 3.开发原型 → 4.客户评估
第二圈:
  1.细化需求 → 2.风险分析 → 3.增量开发 → 4.客户评审
第三圈:
  1.完善功能 → 2.风险分析 → 3.完整开发 → 4.最终测试
...循环迭代
```

**四个象限：**

1. **制定计划**：确定目标、备选方案、约束条件
2. **风险分析**：评估备选方案、识别和解决风险
3. **工程开发**：开发和验证下一级产品
4. **客户评估**：评审结果、计划下一阶段

```python
class SpiralModel:
    """螺旋模型"""
    
    def __init__(self):
        self.iteration = 0
        self.risks = []
    
    def plan(self, objectives):
        """象限1: 制定计划"""
        print(f"\n迭代 {self.iteration + 1} - 制定计划")
        print(f"目标: {objectives}")
        return objectives
    
    def risk_analysis(self, risks):
        """象限2: 风险分析"""
        print(f"风险分析:")
        for risk in risks:
            severity = risk.get('severity', 'medium')
            print(f"  - {risk['name']} [严重性: {severity}]")
            if severity == 'high':
                print(f"    缓解措施: {risk.get('mitigation', '待定')}")
        self.risks.extend(risks)
    
    def engineering(self, deliverable):
        """象限3: 工程开发"""
        print(f"工程开发: {deliverable}")
        return deliverable
    
    def customer_evaluation(self, feedback):
        """象限4: 客户评估"""
        print(f"客户评估: {feedback}")
        self.iteration += 1
        return feedback
    
    def run_iteration(self, objectives, risks, deliverable):
        """运行一次螺旋迭代"""
        print("="*60)
        self.plan(objectives)
        self.risk_analysis(risks)
        result = self.engineering(deliverable)
        self.customer_evaluation(f"{deliverable}已交付")
        return result

# 演示
spiral = SpiralModel()

# 第一次迭代：原型
spiral.run_iteration(
    objectives="开发核心功能原型",
    risks=[
        {'name': '技术可行性未验证', 'severity': 'high', 
         'mitigation': '开发技术原型验证'},
        {'name': '用户需求不明确', 'severity': 'medium'}
    ],
    deliverable="功能原型"
)

# 第二次迭代：增量开发
spiral.run_iteration(
    objectives="完成第一版MVP",
    risks=[
        {'name': '性能瓶颈', 'severity': 'medium'},
        {'name': '集成问题', 'severity': 'low'}
    ],
    deliverable="MVP v1.0"
)
```

### 1.5 DevOps模型

DevOps融合开发(Development)和运维(Operations)，强调自动化和持续交付。

```plain
计划 → 编码 → 构建 → 测试 → 发布 → 部署 → 运维 → 监控
  ↑                                                    ↓
  └────────────────── 反馈循环 ──────────────────────┘
```

**核心实践：**

+ **持续集成(CI)**：频繁合并代码到主分支
+ **持续交付(CD)**：代码随时可发布到生产环境
+ **持续部署**：自动部署到生产环境
+ **基础设施即代码(IaC)**：用代码管理基础设施
+ **监控和日志**：实时监控系统健康状态

```python
class DevOpsPipeline:
    """DevOps流水线"""
    
    def __init__(self):
        self.stages = []
        self.metrics = {
            'build_time': 0,
            'test_coverage': 0,
            'deployment_frequency': 0,
            'mean_time_to_recovery': 0
        }
    
    def plan(self, features):
        """计划阶段"""
        print(f"📋 计划: {len(features)}个新功能")
        self.stages.append('plan')
    
    def code(self, commits):
        """编码阶段"""
        print(f"💻 编码: {commits}次提交")
        self.stages.append('code')
    
    def build(self):
        """构建阶段"""
        print(f"🔨 构建: 编译和打包")
        self.metrics['build_time'] = 5  # 分钟
        self.stages.append('build')
        return True
    
    def test(self, test_suites):
        """测试阶段"""
        print(f"🧪 测试: 运行{test_suites}个测试套件")
        self.metrics['test_coverage'] = 85  # 百分比
        self.stages.append('test')
        return True
    
    def release(self, version):
        """发布阶段"""
        print(f"📦 发布: 版本 {version}")
        self.stages.append('release')
    
    def deploy(self, environment):
        """部署阶段"""
        print(f"🚀 部署: 部署到 {environment}")
        self.metrics['deployment_frequency'] += 1
        self.stages.append('deploy')
    
    def operate(self):
        """运维阶段"""
        print(f"⚙️  运维: 系统监控中...")
        self.stages.append('operate')
    
    def monitor(self):
        """监控阶段"""
        print(f"📊 监控: 收集指标和日志")
        print(f"   - 构建时间: {self.metrics['build_time']} 分钟")
        print(f"   - 测试覆盖率: {self.metrics['test_coverage']}%")
        print(f"   - 部署频率: {self.metrics['deployment_frequency']} 次")
        self.stages.append('monitor')
    
    def run_pipeline(self, features, version, environment='production'):
        """运行完整流水线"""
        print("\n" + "="*60)
        print("DevOps Pipeline 启动")
        print("="*60)
        
        self.plan(features)
        self.code(len(features) * 3)
        
        if self.build():
            if self.test(['unit', 'integration', 'e2e']):
                self.release(version)
                self.deploy(environment)
                self.operate()
                self.monitor()
                
                print(f"\n✅ Pipeline 成功完成!")
                return True
        
        print(f"\n❌ Pipeline 失败")
        return False

# 演示
devops = DevOpsPipeline()
devops.run_pipeline(
    features=['用户登录', '订单管理', '支付集成'],
    version='v2.1.0',
    environment='production'
)
```

### 1.6 开发模型对比

```python
def compare_development_models():
    """开发模型对比分析"""
    
    models = [
        {
            'name': '瀑布模型',
            'flexibility': '低',
            'risk_management': '后期发现',
            'customer_involvement': '需求阶段',
            '适用场景': '需求稳定、技术成熟的项目',
            '优点': '结构清晰、文档完整、易于管理',
            '缺点': '不适应变化、风险发现晚'
        },
        {
            'name': 'V模型',
            'flexibility': '低',
            'risk_management': '测试驱动',
            'customer_involvement': '需求和验收',
            '适用场景': '安全关键型系统（航空、医疗）',
            '优点': '强调测试、质量保证好',
            '缺点': '灵活性差、成本较高'
        },
        {
            'name': '螺旋模型',
            'flexibility': '中',
            'risk_management': '每轮分析',
            'customer_involvement': '每轮评审',
            '适用场景': '大型复杂、风险高的项目',
            '优点': '风险管理好、支持原型',
            '缺点': '复杂度高、需要专业知识'
        },
        {
            'name': '敏捷/Scrum',
            'flexibility': '高',
            'risk_management': '持续反馈',
            'customer_involvement': '全程参与',
            '适用场景': '需求变化快、创新型项目',
            '优点': '快速响应变化、持续交付价值',
            '缺点': '文档较少、需要团队成熟度'
        },
        {
            'name': 'DevOps',
            'flexibility': '高',
            'risk_management': '持续监控',
            'customer_involvement': '持续反馈',
            '适用场景': 'Web应用、SaaS产品',
            '优点': '快速部署、自动化程度高',
            '缺点': '需要文化变革、工具投入大'
        }
    ]
    
    print("软件开发模型对比")
    print("="*100)
    print(f"{'模型':<12} {'灵活性':<8} {'风险管理':<12} {'客户参与':<15} {'适用场景':<25}")
    print("-"*100)
    
    for model in models:
        print(f"{model['name']:<12} {model['flexibility']:<8} "
              f"{model['risk_management']:<12} {model['customer_involvement']:<15} "
              f"{model['适用场景']:<25}")
    
    print("\n" + "="*100)
    print("详细分析")
    print("="*100)
    
    for model in models:
        print(f"\n【{model['name']}】")
        print(f"✅ 优点: {model['优点']}")
        print(f"❌ 缺点: {model['缺点']}")

compare_development_models()
```

**运行结果:**

```plain
软件开发模型对比
====================================================================================================
模型          灵活性    风险管理        客户参与          适用场景                    
----------------------------------------------------------------------------------------------------
瀑布模型        低       后期发现        需求阶段          需求稳定、技术成熟的项目           
V模型          低       测试驱动        需求和验收         安全关键型系统（航空、医疗）        
螺旋模型        中       每轮分析        每轮评审          大型复杂、风险高的项目            
敏捷/Scrum     高       持续反馈        全程参与          需求变化快、创新型项目            
DevOps        高       持续监控        持续反馈          Web应用、SaaS产品              

====================================================================================================
详细分析
====================================================================================================

【瀑布模型】
✅ 优点: 结构清晰、文档完整、易于管理
❌ 缺点: 不适应变化、风险发现晚

【V模型】
✅ 优点: 强调测试、质量保证好
❌ 缺点: 灵活性差、成本较高

【螺旋模型】
✅ 优点: 风险管理好、支持原型
❌ 缺点: 复杂度高、需要专业知识

【敏捷/Scrum】
✅ 优点: 快速响应变化、持续交付价值
❌ 缺点: 文档较少、需要团队成熟度

【DevOps】
✅ 优点: 快速部署、自动化程度高
❌ 缺点: 需要文化变革、工具投入大
```

### 1.7 选择开发模型的决策树

```python
class ModelSelector:
    """开发模型选择器"""
    
    @staticmethod
    def select_model(project_characteristics):
        """
        根据项目特征选择合适的开发模型
        
        参数:
            project_characteristics: dict，包含以下键:
                - requirements_stable: bool, 需求是否稳定
                - team_size: int, 团队规模
                - risk_level: str, 风险级别 (low/medium/high)
                - deployment_frequency: str, 部署频率 (rare/monthly/weekly/daily)
                - safety_critical: bool, 是否安全关键型
        """
        req_stable = project_characteristics.get('requirements_stable', False)
        team_size = project_characteristics.get('team_size', 5)
        risk_level = project_characteristics.get('risk_level', 'medium')
        deploy_freq = project_characteristics.get('deployment_frequency', 'monthly')
        safety_critical = project_characteristics.get('safety_critical', False)
        
        print("项目特征分析:")
        print(f"  需求稳定性: {'稳定' if req_stable else '变化频繁'}")
        print(f"  团队规模: {team_size}人")
        print(f"  风险级别: {risk_level}")
        print(f"  部署频率: {deploy_freq}")
        print(f"  安全关键: {'是' if safety_critical else '否'}")
        print()
        
        # 决策逻辑
        if safety_critical and req_stable:
            return "V模型", "安全关键型系统需要严格的测试验证"
        
        elif risk_level == 'high':
            return "螺旋模型", "高风险项目需要每轮进行风险分析"
        
        elif deploy_freq in ['daily', 'weekly'] and team_size >= 3:
            return "DevOps", "高频部署需要自动化流水线"
        
        elif not req_stable and team_size <= 10:
            return "敏捷/Scrum", "需求变化频繁适合迭代开发"
        
        elif req_stable and team_size > 20:
            return "瀑布模型", "大型团队、稳定需求适合传统流程"
        
        else:
            return "敏捷/Scrum", "默认推荐敏捷模型（适应性强）"

# 测试不同场景
scenarios = [
    {
        'name': '电商网站',
        'requirements_stable': False,
        'team_size': 8,
        'risk_level': 'medium',
        'deployment_frequency': 'daily',
        'safety_critical': False
    },
    {
        'name': '医疗设备软件',
        'requirements_stable': True,
        'team_size': 15,
        'risk_level': 'high',
        'deployment_frequency': 'rare',
        'safety_critical': True
    },
    {
        'name': '企业ERP系统',
        'requirements_stable': True,
        'team_size': 50,
        'risk_level': 'medium',
        'deployment_frequency': 'monthly',
        'safety_critical': False
    },
    {
        'name': '创业MVP产品',
        'requirements_stable': False,
        'team_size': 5,
        'risk_level': 'high',
        'deployment_frequency': 'weekly',
        'safety_critical': False
    }
]

selector = ModelSelector()

for scenario in scenarios:
    print("="*70)
    print(f"场景: {scenario['name']}")
    print("="*70)
    
    name = scenario.pop('name')
    model, reason = selector.select_model(scenario)
    
    print(f"✅ 推荐模型: {model}")
    print(f"📝 理由: {reason}")
    print()
```

---

**本章完**
